// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, i8* %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = bitcast i8* %[[VAL_0]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, i8* %[[VAL_4:.*]], i64 0
// CHECK:         %[[VAL_5:.*]] = bitcast i8* %[[VAL_3]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_6:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_7:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_8:.*]] = mul nuw nsw i32 %[[VAL_6]], 256
// CHECK:         %[[VAL_9:.*]] = add nuw nsw i32 %[[VAL_8]], %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = icmp ult i32 %[[VAL_9]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_10]])
// CHECK:         %[[VAL_11:.*]] = mul nuw nsw i32 %[[VAL_9]], 4
// CHECK:         %[[VAL_12:.*]] = udiv i32 %[[VAL_11]], 1
// CHECK:         %[[VAL_13:.*]] = urem i32 %[[VAL_12]], 200
// CHECK:         %[[VAL_14:.*]] = udiv i32 %[[VAL_11]], 200
// CHECK:         %[[VAL_15:.*]] = add nuw nsw i32 %[[VAL_11]], 1
// CHECK:         %[[VAL_16:.*]] = udiv i32 %[[VAL_15]], 1
// CHECK:         %[[VAL_17:.*]] = urem i32 %[[VAL_16]], 200
// CHECK:         %[[VAL_18:.*]] = udiv i32 %[[VAL_15]], 200
// CHECK:         %[[VAL_19:.*]] = add nuw nsw i32 %[[VAL_11]], 2
// CHECK:         %[[VAL_20:.*]] = udiv i32 %[[VAL_19]], 1
// CHECK:         %[[VAL_21:.*]] = urem i32 %[[VAL_20]], 200
// CHECK:         %[[VAL_22:.*]] = udiv i32 %[[VAL_19]], 200
// CHECK:         %[[VAL_23:.*]] = add nuw nsw i32 %[[VAL_11]], 3
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_23]], 1
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 200
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_23]], 200
// CHECK:         %[[VAL_27:.*]] = icmp ult i32 %[[VAL_11]], 20000
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_28:.*]], label %[[VAL_29:.*]]
// CHECK:       r0.in_bounds-after:                               ; preds = %[[VAL_28]], %[[VAL_30:.*]]
// CHECK:         ret void
// CHECK:       r0.in_bounds-true:                                ; preds = %[[VAL_30]]
// CHECK:         %[[VAL_31:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_32:.*]] = getelementptr inbounds float, float* %[[VAL_31]], i32 %[[VAL_11]]
// CHECK:         %[[VAL_33:.*]] = load float, float* %[[VAL_32]], align 4, !invariant.load !94
// CHECK:         %[[VAL_34:.*]] = call float @llvm.fabs.f32(float %[[VAL_33]])
// CHECK:         %[[VAL_35:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_36:.*]] = getelementptr inbounds float, float* %[[VAL_35]], i32 %[[VAL_11]]
// CHECK:         store float %[[VAL_34]], float* %[[VAL_36]], align 4
// CHECK:         %[[VAL_37:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_38:.*]] = getelementptr inbounds float, float* %[[VAL_37]], i32 %[[VAL_15]]
// CHECK:         %[[VAL_39:.*]] = load float, float* %[[VAL_38]], align 4, !invariant.load !94
// CHECK:         %[[VAL_40:.*]] = call float @llvm.fabs.f32(float %[[VAL_39]])
// CHECK:         %[[VAL_41:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds float, float* %[[VAL_41]], i32 %[[VAL_15]]
// CHECK:         store float %[[VAL_40]], float* %[[VAL_42]], align 4
// CHECK:         %[[VAL_43:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_44:.*]] = getelementptr inbounds float, float* %[[VAL_43]], i32 %[[VAL_19]]
// CHECK:         %[[VAL_45:.*]] = load float, float* %[[VAL_44]], align 4, !invariant.load !94
// CHECK:         %[[VAL_46:.*]] = call float @llvm.fabs.f32(float %[[VAL_45]])
// CHECK:         %[[VAL_47:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_48:.*]] = getelementptr inbounds float, float* %[[VAL_47]], i32 %[[VAL_19]]
// CHECK:         store float %[[VAL_46]], float* %[[VAL_48]], align 4
// CHECK:         %[[VAL_49:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds float, float* %[[VAL_49]], i32 %[[VAL_23]]
// CHECK:         %[[VAL_51:.*]] = load float, float* %[[VAL_50]], align 4, !invariant.load !94
// CHECK:         %[[VAL_52:.*]] = call float @llvm.fabs.f32(float %[[VAL_51]])
// CHECK:         %[[VAL_53:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_54:.*]] = getelementptr inbounds float, float* %[[VAL_53]], i32 %[[VAL_23]]
// CHECK:         store float %[[VAL_52]], float* %[[VAL_54]], align 4
// CHECK:         br label %[[VAL_29]]
// CHECK:       entry:
// CHECK:         %[[VAL_55:.*]] = getelementptr inbounds i8, i8* %[[VAL_56:.*]], i64 0
// CHECK:         %[[VAL_57:.*]] = bitcast i8* %[[VAL_55]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_58:.*]] = getelementptr inbounds i8, i8* %[[VAL_59:.*]], i64 0
// CHECK:         %[[VAL_60:.*]] = bitcast i8* %[[VAL_58]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_61:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_62:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_63:.*]] = mul nuw nsw i32 %[[VAL_61]], 256
// CHECK:         %[[VAL_64:.*]] = add nuw nsw i32 %[[VAL_63]], %[[VAL_62]]
// CHECK:         %[[VAL_65:.*]] = icmp ult i32 %[[VAL_64]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_65]])
// CHECK:         %[[VAL_66:.*]] = mul nuw nsw i32 %[[VAL_64]], 4
// CHECK:         %[[VAL_67:.*]] = udiv i32 %[[VAL_66]], 1
// CHECK:         %[[VAL_68:.*]] = urem i32 %[[VAL_67]], 200
// CHECK:         %[[VAL_69:.*]] = udiv i32 %[[VAL_66]], 200
// CHECK:         %[[VAL_70:.*]] = add nuw nsw i32 %[[VAL_66]], 1
// CHECK:         %[[VAL_71:.*]] = udiv i32 %[[VAL_70]], 1
// CHECK:         %[[VAL_72:.*]] = urem i32 %[[VAL_71]], 200
// CHECK:         %[[VAL_73:.*]] = udiv i32 %[[VAL_70]], 200
// CHECK:         %[[VAL_74:.*]] = add nuw nsw i32 %[[VAL_66]], 2
// CHECK:         %[[VAL_75:.*]] = udiv i32 %[[VAL_74]], 1
// CHECK:         %[[VAL_76:.*]] = urem i32 %[[VAL_75]], 200
// CHECK:         %[[VAL_77:.*]] = udiv i32 %[[VAL_74]], 200
// CHECK:         %[[VAL_78:.*]] = add nuw nsw i32 %[[VAL_66]], 3
// CHECK:         %[[VAL_79:.*]] = udiv i32 %[[VAL_78]], 1
// CHECK:         %[[VAL_80:.*]] = urem i32 %[[VAL_79]], 200
// CHECK:         %[[VAL_81:.*]] = udiv i32 %[[VAL_78]], 200
// CHECK:         %[[VAL_82:.*]] = icmp ult i32 %[[VAL_66]], 20000
// CHECK:         br i1 %[[VAL_82]], label %[[VAL_83:.*]], label %[[VAL_84:.*]]
// CHECK:       r1.in_bounds-after:                               ; preds = %[[VAL_83]], %[[VAL_85:.*]]
// CHECK:         ret void
// CHECK:       r1.in_bounds-true:                                ; preds = %[[VAL_85]]
// CHECK:         %[[VAL_86:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_87:.*]] = getelementptr inbounds float, float* %[[VAL_86]], i32 %[[VAL_66]]
// CHECK:         %[[VAL_88:.*]] = load float, float* %[[VAL_87]], align 4, !invariant.load !94
// CHECK:         %[[VAL_89:.*]] = call float @llvm.round.f32(float %[[VAL_88]])
// CHECK:         %[[VAL_90:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_91:.*]] = getelementptr inbounds float, float* %[[VAL_90]], i32 %[[VAL_66]]
// CHECK:         store float %[[VAL_89]], float* %[[VAL_91]], align 4
// CHECK:         %[[VAL_92:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_93:.*]] = getelementptr inbounds float, float* %[[VAL_92]], i32 %[[VAL_70]]
// CHECK:         %[[VAL_94:.*]] = load float, float* %[[VAL_93]], align 4, !invariant.load !94
// CHECK:         %[[VAL_95:.*]] = call float @llvm.round.f32(float %[[VAL_94]])
// CHECK:         %[[VAL_96:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_97:.*]] = getelementptr inbounds float, float* %[[VAL_96]], i32 %[[VAL_70]]
// CHECK:         store float %[[VAL_95]], float* %[[VAL_97]], align 4
// CHECK:         %[[VAL_98:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_99:.*]] = getelementptr inbounds float, float* %[[VAL_98]], i32 %[[VAL_74]]
// CHECK:         %[[VAL_100:.*]] = load float, float* %[[VAL_99]], align 4, !invariant.load !94
// CHECK:         %[[VAL_101:.*]] = call float @llvm.round.f32(float %[[VAL_100]])
// CHECK:         %[[VAL_102:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_103:.*]] = getelementptr inbounds float, float* %[[VAL_102]], i32 %[[VAL_74]]
// CHECK:         store float %[[VAL_101]], float* %[[VAL_103]], align 4
// CHECK:         %[[VAL_104:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_105:.*]] = getelementptr inbounds float, float* %[[VAL_104]], i32 %[[VAL_78]]
// CHECK:         %[[VAL_106:.*]] = load float, float* %[[VAL_105]], align 4, !invariant.load !94
// CHECK:         %[[VAL_107:.*]] = call float @llvm.round.f32(float %[[VAL_106]])
// CHECK:         %[[VAL_108:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_109:.*]] = getelementptr inbounds float, float* %[[VAL_108]], i32 %[[VAL_78]]
// CHECK:         store float %[[VAL_107]], float* %[[VAL_109]], align 4
// CHECK:         br label %[[VAL_84]]
// CHECK:       entry:
// CHECK:         %[[VAL_110:.*]] = getelementptr inbounds i8, i8* %[[VAL_111:.*]], i64 0
// CHECK:         %[[VAL_112:.*]] = bitcast i8* %[[VAL_110]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_113:.*]] = getelementptr inbounds i8, i8* %[[VAL_114:.*]], i64 0
// CHECK:         %[[VAL_115:.*]] = bitcast i8* %[[VAL_113]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_116:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_117:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_118:.*]] = mul nuw nsw i32 %[[VAL_116]], 256
// CHECK:         %[[VAL_119:.*]] = add nuw nsw i32 %[[VAL_118]], %[[VAL_117]]
// CHECK:         %[[VAL_120:.*]] = icmp ult i32 %[[VAL_119]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_120]])
// CHECK:         %[[VAL_121:.*]] = mul nuw nsw i32 %[[VAL_119]], 4
// CHECK:         %[[VAL_122:.*]] = udiv i32 %[[VAL_121]], 1
// CHECK:         %[[VAL_123:.*]] = urem i32 %[[VAL_122]], 200
// CHECK:         %[[VAL_124:.*]] = udiv i32 %[[VAL_121]], 200
// CHECK:         %[[VAL_125:.*]] = add nuw nsw i32 %[[VAL_121]], 1
// CHECK:         %[[VAL_126:.*]] = udiv i32 %[[VAL_125]], 1
// CHECK:         %[[VAL_127:.*]] = urem i32 %[[VAL_126]], 200
// CHECK:         %[[VAL_128:.*]] = udiv i32 %[[VAL_125]], 200
// CHECK:         %[[VAL_129:.*]] = add nuw nsw i32 %[[VAL_121]], 2
// CHECK:         %[[VAL_130:.*]] = udiv i32 %[[VAL_129]], 1
// CHECK:         %[[VAL_131:.*]] = urem i32 %[[VAL_130]], 200
// CHECK:         %[[VAL_132:.*]] = udiv i32 %[[VAL_129]], 200
// CHECK:         %[[VAL_133:.*]] = add nuw nsw i32 %[[VAL_121]], 3
// CHECK:         %[[VAL_134:.*]] = udiv i32 %[[VAL_133]], 1
// CHECK:         %[[VAL_135:.*]] = urem i32 %[[VAL_134]], 200
// CHECK:         %[[VAL_136:.*]] = udiv i32 %[[VAL_133]], 200
// CHECK:         %[[VAL_137:.*]] = icmp ult i32 %[[VAL_121]], 20000
// CHECK:         br i1 %[[VAL_137]], label %[[VAL_138:.*]], label %[[VAL_139:.*]]
// CHECK:       r2.in_bounds-after:                               ; preds = %[[VAL_138]], %[[VAL_140:.*]]
// CHECK:         ret void
// CHECK:       r2.in_bounds-true:                                ; preds = %[[VAL_140]]
// CHECK:         %[[VAL_141:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_142:.*]] = getelementptr inbounds float, float* %[[VAL_141]], i32 %[[VAL_121]]
// CHECK:         %[[VAL_143:.*]] = load float, float* %[[VAL_142]], align 4, !invariant.load !94
// CHECK:         %[[VAL_144:.*]] = call float @llvm.ceil.f32(float %[[VAL_143]])
// CHECK:         %[[VAL_145:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_146:.*]] = getelementptr inbounds float, float* %[[VAL_145]], i32 %[[VAL_121]]
// CHECK:         store float %[[VAL_144]], float* %[[VAL_146]], align 4
// CHECK:         %[[VAL_147:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_148:.*]] = getelementptr inbounds float, float* %[[VAL_147]], i32 %[[VAL_125]]
// CHECK:         %[[VAL_149:.*]] = load float, float* %[[VAL_148]], align 4, !invariant.load !94
// CHECK:         %[[VAL_150:.*]] = call float @llvm.ceil.f32(float %[[VAL_149]])
// CHECK:         %[[VAL_151:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_152:.*]] = getelementptr inbounds float, float* %[[VAL_151]], i32 %[[VAL_125]]
// CHECK:         store float %[[VAL_150]], float* %[[VAL_152]], align 4
// CHECK:         %[[VAL_153:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_154:.*]] = getelementptr inbounds float, float* %[[VAL_153]], i32 %[[VAL_129]]
// CHECK:         %[[VAL_155:.*]] = load float, float* %[[VAL_154]], align 4, !invariant.load !94
// CHECK:         %[[VAL_156:.*]] = call float @llvm.ceil.f32(float %[[VAL_155]])
// CHECK:         %[[VAL_157:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_158:.*]] = getelementptr inbounds float, float* %[[VAL_157]], i32 %[[VAL_129]]
// CHECK:         store float %[[VAL_156]], float* %[[VAL_158]], align 4
// CHECK:         %[[VAL_159:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_160:.*]] = getelementptr inbounds float, float* %[[VAL_159]], i32 %[[VAL_133]]
// CHECK:         %[[VAL_161:.*]] = load float, float* %[[VAL_160]], align 4, !invariant.load !94
// CHECK:         %[[VAL_162:.*]] = call float @llvm.ceil.f32(float %[[VAL_161]])
// CHECK:         %[[VAL_163:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_164:.*]] = getelementptr inbounds float, float* %[[VAL_163]], i32 %[[VAL_133]]
// CHECK:         store float %[[VAL_162]], float* %[[VAL_164]], align 4
// CHECK:         br label %[[VAL_139]]
// CHECK:       entry:
// CHECK:         %[[VAL_165:.*]] = getelementptr inbounds i8, i8* %[[VAL_166:.*]], i64 0
// CHECK:         %[[VAL_167:.*]] = bitcast i8* %[[VAL_165]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_168:.*]] = getelementptr inbounds i8, i8* %[[VAL_169:.*]], i64 0
// CHECK:         %[[VAL_170:.*]] = bitcast i8* %[[VAL_168]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_171:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_172:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_173:.*]] = mul nuw nsw i32 %[[VAL_171]], 256
// CHECK:         %[[VAL_174:.*]] = add nuw nsw i32 %[[VAL_173]], %[[VAL_172]]
// CHECK:         %[[VAL_175:.*]] = icmp ult i32 %[[VAL_174]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_175]])
// CHECK:         %[[VAL_176:.*]] = mul nuw nsw i32 %[[VAL_174]], 4
// CHECK:         %[[VAL_177:.*]] = udiv i32 %[[VAL_176]], 1
// CHECK:         %[[VAL_178:.*]] = urem i32 %[[VAL_177]], 200
// CHECK:         %[[VAL_179:.*]] = udiv i32 %[[VAL_176]], 200
// CHECK:         %[[VAL_180:.*]] = add nuw nsw i32 %[[VAL_176]], 1
// CHECK:         %[[VAL_181:.*]] = udiv i32 %[[VAL_180]], 1
// CHECK:         %[[VAL_182:.*]] = urem i32 %[[VAL_181]], 200
// CHECK:         %[[VAL_183:.*]] = udiv i32 %[[VAL_180]], 200
// CHECK:         %[[VAL_184:.*]] = add nuw nsw i32 %[[VAL_176]], 2
// CHECK:         %[[VAL_185:.*]] = udiv i32 %[[VAL_184]], 1
// CHECK:         %[[VAL_186:.*]] = urem i32 %[[VAL_185]], 200
// CHECK:         %[[VAL_187:.*]] = udiv i32 %[[VAL_184]], 200
// CHECK:         %[[VAL_188:.*]] = add nuw nsw i32 %[[VAL_176]], 3
// CHECK:         %[[VAL_189:.*]] = udiv i32 %[[VAL_188]], 1
// CHECK:         %[[VAL_190:.*]] = urem i32 %[[VAL_189]], 200
// CHECK:         %[[VAL_191:.*]] = udiv i32 %[[VAL_188]], 200
// CHECK:         %[[VAL_192:.*]] = icmp ult i32 %[[VAL_176]], 20000
// CHECK:         br i1 %[[VAL_192]], label %[[VAL_193:.*]], label %[[VAL_194:.*]]
// CHECK:       r3.in_bounds-after:                               ; preds = %[[VAL_193]], %[[VAL_195:.*]]
// CHECK:         ret void
// CHECK:       r3.in_bounds-true:                                ; preds = %[[VAL_195]]
// CHECK:         %[[VAL_196:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_197:.*]] = getelementptr inbounds i32, i32* %[[VAL_196]], i32 %[[VAL_176]]
// CHECK:         %[[VAL_198:.*]] = load i32, i32* %[[VAL_197]], align 4, !invariant.load !94
// CHECK:         %[[VAL_199:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_198]], i1 false)
// CHECK:         %[[VAL_200:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_201:.*]] = getelementptr inbounds i32, i32* %[[VAL_200]], i32 %[[VAL_176]]
// CHECK:         store i32 %[[VAL_199]], i32* %[[VAL_201]], align 4
// CHECK:         %[[VAL_202:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_203:.*]] = getelementptr inbounds i32, i32* %[[VAL_202]], i32 %[[VAL_180]]
// CHECK:         %[[VAL_204:.*]] = load i32, i32* %[[VAL_203]], align 4, !invariant.load !94
// CHECK:         %[[VAL_205:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_204]], i1 false)
// CHECK:         %[[VAL_206:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_207:.*]] = getelementptr inbounds i32, i32* %[[VAL_206]], i32 %[[VAL_180]]
// CHECK:         store i32 %[[VAL_205]], i32* %[[VAL_207]], align 4
// CHECK:         %[[VAL_208:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_209:.*]] = getelementptr inbounds i32, i32* %[[VAL_208]], i32 %[[VAL_184]]
// CHECK:         %[[VAL_210:.*]] = load i32, i32* %[[VAL_209]], align 4, !invariant.load !94
// CHECK:         %[[VAL_211:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_210]], i1 false)
// CHECK:         %[[VAL_212:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_213:.*]] = getelementptr inbounds i32, i32* %[[VAL_212]], i32 %[[VAL_184]]
// CHECK:         store i32 %[[VAL_211]], i32* %[[VAL_213]], align 4
// CHECK:         %[[VAL_214:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_215:.*]] = getelementptr inbounds i32, i32* %[[VAL_214]], i32 %[[VAL_188]]
// CHECK:         %[[VAL_216:.*]] = load i32, i32* %[[VAL_215]], align 4, !invariant.load !94
// CHECK:         %[[VAL_217:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_216]], i1 false)
// CHECK:         %[[VAL_218:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_219:.*]] = getelementptr inbounds i32, i32* %[[VAL_218]], i32 %[[VAL_188]]
// CHECK:         store i32 %[[VAL_217]], i32* %[[VAL_219]], align 4
// CHECK:         br label %[[VAL_194]]
// CHECK:       entry:
// CHECK:         %[[VAL_220:.*]] = getelementptr inbounds i8, i8* %[[VAL_221:.*]], i64 0
// CHECK:         %[[VAL_222:.*]] = bitcast i8* %[[VAL_220]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_223:.*]] = getelementptr inbounds i8, i8* %[[VAL_224:.*]], i64 0
// CHECK:         %[[VAL_225:.*]] = bitcast i8* %[[VAL_223]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_226:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_227:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_228:.*]] = mul nuw nsw i32 %[[VAL_226]], 256
// CHECK:         %[[VAL_229:.*]] = add nuw nsw i32 %[[VAL_228]], %[[VAL_227]]
// CHECK:         %[[VAL_230:.*]] = icmp ult i32 %[[VAL_229]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_230]])
// CHECK:         %[[VAL_231:.*]] = mul nuw nsw i32 %[[VAL_229]], 4
// CHECK:         %[[VAL_232:.*]] = udiv i32 %[[VAL_231]], 1
// CHECK:         %[[VAL_233:.*]] = urem i32 %[[VAL_232]], 200
// CHECK:         %[[VAL_234:.*]] = udiv i32 %[[VAL_231]], 200
// CHECK:         %[[VAL_235:.*]] = add nuw nsw i32 %[[VAL_231]], 1
// CHECK:         %[[VAL_236:.*]] = udiv i32 %[[VAL_235]], 1
// CHECK:         %[[VAL_237:.*]] = urem i32 %[[VAL_236]], 200
// CHECK:         %[[VAL_238:.*]] = udiv i32 %[[VAL_235]], 200
// CHECK:         %[[VAL_239:.*]] = add nuw nsw i32 %[[VAL_231]], 2
// CHECK:         %[[VAL_240:.*]] = udiv i32 %[[VAL_239]], 1
// CHECK:         %[[VAL_241:.*]] = urem i32 %[[VAL_240]], 200
// CHECK:         %[[VAL_242:.*]] = udiv i32 %[[VAL_239]], 200
// CHECK:         %[[VAL_243:.*]] = add nuw nsw i32 %[[VAL_231]], 3
// CHECK:         %[[VAL_244:.*]] = udiv i32 %[[VAL_243]], 1
// CHECK:         %[[VAL_245:.*]] = urem i32 %[[VAL_244]], 200
// CHECK:         %[[VAL_246:.*]] = udiv i32 %[[VAL_243]], 200
// CHECK:         %[[VAL_247:.*]] = icmp ult i32 %[[VAL_231]], 20000
// CHECK:         br i1 %[[VAL_247]], label %[[VAL_248:.*]], label %[[VAL_249:.*]]
// CHECK:       r4.in_bounds-after:                               ; preds = %[[VAL_248]], %[[VAL_250:.*]]
// CHECK:         ret void
// CHECK:       r4.in_bounds-true:                                ; preds = %[[VAL_250]]
// CHECK:         %[[VAL_251:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_252:.*]] = getelementptr inbounds float, float* %[[VAL_251]], i32 %[[VAL_231]]
// CHECK:         %[[VAL_253:.*]] = load float, float* %[[VAL_252]], align 4, !invariant.load !94
// CHECK:         %[[VAL_254:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_255:.*]] = getelementptr inbounds float, float* %[[VAL_254]], i32 %[[VAL_231]]
// CHECK:         store float %[[VAL_253]], float* %[[VAL_255]], align 4
// CHECK:         %[[VAL_256:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_257:.*]] = getelementptr inbounds float, float* %[[VAL_256]], i32 %[[VAL_235]]
// CHECK:         %[[VAL_258:.*]] = load float, float* %[[VAL_257]], align 4, !invariant.load !94
// CHECK:         %[[VAL_259:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_260:.*]] = getelementptr inbounds float, float* %[[VAL_259]], i32 %[[VAL_235]]
// CHECK:         store float %[[VAL_258]], float* %[[VAL_260]], align 4
// CHECK:         %[[VAL_261:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_262:.*]] = getelementptr inbounds float, float* %[[VAL_261]], i32 %[[VAL_239]]
// CHECK:         %[[VAL_263:.*]] = load float, float* %[[VAL_262]], align 4, !invariant.load !94
// CHECK:         %[[VAL_264:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_265:.*]] = getelementptr inbounds float, float* %[[VAL_264]], i32 %[[VAL_239]]
// CHECK:         store float %[[VAL_263]], float* %[[VAL_265]], align 4
// CHECK:         %[[VAL_266:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_267:.*]] = getelementptr inbounds float, float* %[[VAL_266]], i32 %[[VAL_243]]
// CHECK:         %[[VAL_268:.*]] = load float, float* %[[VAL_267]], align 4, !invariant.load !94
// CHECK:         %[[VAL_269:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_270:.*]] = getelementptr inbounds float, float* %[[VAL_269]], i32 %[[VAL_243]]
// CHECK:         store float %[[VAL_268]], float* %[[VAL_270]], align 4
// CHECK:         br label %[[VAL_249]]
// CHECK:       entry:
// CHECK:         %[[VAL_271:.*]] = getelementptr inbounds i8, i8* %[[VAL_272:.*]], i64 0
// CHECK:         %[[VAL_273:.*]] = bitcast i8* %[[VAL_271]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_274:.*]] = getelementptr inbounds i8, i8* %[[VAL_275:.*]], i64 0
// CHECK:         %[[VAL_276:.*]] = bitcast i8* %[[VAL_274]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_277:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_278:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_279:.*]] = mul nuw nsw i32 %[[VAL_277]], 256
// CHECK:         %[[VAL_280:.*]] = add nuw nsw i32 %[[VAL_279]], %[[VAL_278]]
// CHECK:         %[[VAL_281:.*]] = icmp ult i32 %[[VAL_280]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_281]])
// CHECK:         %[[VAL_282:.*]] = mul nuw nsw i32 %[[VAL_280]], 4
// CHECK:         %[[VAL_283:.*]] = udiv i32 %[[VAL_282]], 1
// CHECK:         %[[VAL_284:.*]] = urem i32 %[[VAL_283]], 200
// CHECK:         %[[VAL_285:.*]] = udiv i32 %[[VAL_282]], 200
// CHECK:         %[[VAL_286:.*]] = add nuw nsw i32 %[[VAL_282]], 1
// CHECK:         %[[VAL_287:.*]] = udiv i32 %[[VAL_286]], 1
// CHECK:         %[[VAL_288:.*]] = urem i32 %[[VAL_287]], 200
// CHECK:         %[[VAL_289:.*]] = udiv i32 %[[VAL_286]], 200
// CHECK:         %[[VAL_290:.*]] = add nuw nsw i32 %[[VAL_282]], 2
// CHECK:         %[[VAL_291:.*]] = udiv i32 %[[VAL_290]], 1
// CHECK:         %[[VAL_292:.*]] = urem i32 %[[VAL_291]], 200
// CHECK:         %[[VAL_293:.*]] = udiv i32 %[[VAL_290]], 200
// CHECK:         %[[VAL_294:.*]] = add nuw nsw i32 %[[VAL_282]], 3
// CHECK:         %[[VAL_295:.*]] = udiv i32 %[[VAL_294]], 1
// CHECK:         %[[VAL_296:.*]] = urem i32 %[[VAL_295]], 200
// CHECK:         %[[VAL_297:.*]] = udiv i32 %[[VAL_294]], 200
// CHECK:         %[[VAL_298:.*]] = icmp ult i32 %[[VAL_282]], 20000
// CHECK:         br i1 %[[VAL_298]], label %[[VAL_299:.*]], label %[[VAL_300:.*]]
// CHECK:       r5.in_bounds-after:                               ; preds = %[[VAL_299]], %[[VAL_301:.*]]
// CHECK:         ret void
// CHECK:       r5.in_bounds-true:                                ; preds = %[[VAL_301]]
// CHECK:         %[[VAL_302:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_303:.*]] = getelementptr inbounds float, float* %[[VAL_302]], i32 %[[VAL_282]]
// CHECK:         %[[VAL_304:.*]] = load float, float* %[[VAL_303]], align 4, !invariant.load !94
// CHECK:         %[[VAL_305:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_306:.*]] = getelementptr inbounds float, float* %[[VAL_305]], i32 %[[VAL_282]]
// CHECK:         store float %[[VAL_304]], float* %[[VAL_306]], align 4
// CHECK:         %[[VAL_307:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_308:.*]] = getelementptr inbounds float, float* %[[VAL_307]], i32 %[[VAL_286]]
// CHECK:         %[[VAL_309:.*]] = load float, float* %[[VAL_308]], align 4, !invariant.load !94
// CHECK:         %[[VAL_310:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_311:.*]] = getelementptr inbounds float, float* %[[VAL_310]], i32 %[[VAL_286]]
// CHECK:         store float %[[VAL_309]], float* %[[VAL_311]], align 4
// CHECK:         %[[VAL_312:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_313:.*]] = getelementptr inbounds float, float* %[[VAL_312]], i32 %[[VAL_290]]
// CHECK:         %[[VAL_314:.*]] = load float, float* %[[VAL_313]], align 4, !invariant.load !94
// CHECK:         %[[VAL_315:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_316:.*]] = getelementptr inbounds float, float* %[[VAL_315]], i32 %[[VAL_290]]
// CHECK:         store float %[[VAL_314]], float* %[[VAL_316]], align 4
// CHECK:         %[[VAL_317:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_318:.*]] = getelementptr inbounds float, float* %[[VAL_317]], i32 %[[VAL_294]]
// CHECK:         %[[VAL_319:.*]] = load float, float* %[[VAL_318]], align 4, !invariant.load !94
// CHECK:         %[[VAL_320:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_321:.*]] = getelementptr inbounds float, float* %[[VAL_320]], i32 %[[VAL_294]]
// CHECK:         store float %[[VAL_319]], float* %[[VAL_321]], align 4
// CHECK:         br label %[[VAL_300]]
// CHECK:       entry:
// CHECK:         %[[VAL_322:.*]] = getelementptr inbounds i8, i8* %[[VAL_323:.*]], i64 0
// CHECK:         %[[VAL_324:.*]] = bitcast i8* %[[VAL_322]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_325:.*]] = getelementptr inbounds i8, i8* %[[VAL_326:.*]], i64 0
// CHECK:         %[[VAL_327:.*]] = bitcast i8* %[[VAL_325]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_328:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_329:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_330:.*]] = mul nuw nsw i32 %[[VAL_328]], 1024
// CHECK:         %[[VAL_331:.*]] = add nuw nsw i32 %[[VAL_330]], %[[VAL_329]]
// CHECK:         %[[VAL_332:.*]] = icmp ult i32 %[[VAL_331]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_332]])
// CHECK:         %[[VAL_333:.*]] = udiv i32 %[[VAL_331]], 1
// CHECK:         %[[VAL_334:.*]] = urem i32 %[[VAL_333]], 200
// CHECK:         %[[VAL_335:.*]] = udiv i32 %[[VAL_331]], 200
// CHECK:         %[[VAL_336:.*]] = icmp ult i32 %[[VAL_331]], 20000
// CHECK:         br i1 %[[VAL_336]], label %[[VAL_337:.*]], label %[[VAL_338:.*]]
// CHECK:       r7.in_bounds-after:                               ; preds = %[[VAL_337]], %[[VAL_339:.*]]
// CHECK:         ret void
// CHECK:       r7.in_bounds-true:                                ; preds = %[[VAL_339]]
// CHECK:         %[[VAL_340:.*]] = bitcast [100 x [200 x float]]* %[[VAL_324]] to float*
// CHECK:         %[[VAL_341:.*]] = getelementptr inbounds float, float* %[[VAL_340]], i32 %[[VAL_331]]
// CHECK:         %[[VAL_342:.*]] = load float, float* %[[VAL_341]], align 4, !invariant.load !94
// CHECK:         %[[VAL_343:.*]] = call float @__nv_cosf(float %[[VAL_342]])
// CHECK:         %[[VAL_344:.*]] = bitcast [100 x [200 x float]]* %[[VAL_327]] to float*
// CHECK:         %[[VAL_345:.*]] = getelementptr inbounds float, float* %[[VAL_344]], i32 %[[VAL_331]]
// CHECK:         store float %[[VAL_343]], float* %[[VAL_345]], align 4
// CHECK:         br label %[[VAL_338]]
// CHECK:       entry:
// CHECK:         %[[VAL_346:.*]] = getelementptr inbounds i8, i8* %[[VAL_347:.*]], i64 0
// CHECK:         %[[VAL_348:.*]] = bitcast i8* %[[VAL_346]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_349:.*]] = getelementptr inbounds i8, i8* %[[VAL_350:.*]], i64 0
// CHECK:         %[[VAL_351:.*]] = bitcast i8* %[[VAL_349]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_352:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_353:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_354:.*]] = mul nuw nsw i32 %[[VAL_352]], 256
// CHECK:         %[[VAL_355:.*]] = add nuw nsw i32 %[[VAL_354]], %[[VAL_353]]
// CHECK:         %[[VAL_356:.*]] = icmp ult i32 %[[VAL_355]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_356]])
// CHECK:         %[[VAL_357:.*]] = mul nuw nsw i32 %[[VAL_355]], 4
// CHECK:         %[[VAL_358:.*]] = udiv i32 %[[VAL_357]], 1
// CHECK:         %[[VAL_359:.*]] = urem i32 %[[VAL_358]], 200
// CHECK:         %[[VAL_360:.*]] = udiv i32 %[[VAL_357]], 200
// CHECK:         %[[VAL_361:.*]] = add nuw nsw i32 %[[VAL_357]], 1
// CHECK:         %[[VAL_362:.*]] = udiv i32 %[[VAL_361]], 1
// CHECK:         %[[VAL_363:.*]] = urem i32 %[[VAL_362]], 200
// CHECK:         %[[VAL_364:.*]] = udiv i32 %[[VAL_361]], 200
// CHECK:         %[[VAL_365:.*]] = add nuw nsw i32 %[[VAL_357]], 2
// CHECK:         %[[VAL_366:.*]] = udiv i32 %[[VAL_365]], 1
// CHECK:         %[[VAL_367:.*]] = urem i32 %[[VAL_366]], 200
// CHECK:         %[[VAL_368:.*]] = udiv i32 %[[VAL_365]], 200
// CHECK:         %[[VAL_369:.*]] = add nuw nsw i32 %[[VAL_357]], 3
// CHECK:         %[[VAL_370:.*]] = udiv i32 %[[VAL_369]], 1
// CHECK:         %[[VAL_371:.*]] = urem i32 %[[VAL_370]], 200
// CHECK:         %[[VAL_372:.*]] = udiv i32 %[[VAL_369]], 200
// CHECK:         %[[VAL_373:.*]] = icmp ult i32 %[[VAL_357]], 20000
// CHECK:         br i1 %[[VAL_373]], label %[[VAL_374:.*]], label %[[VAL_375:.*]]
// CHECK:       r8.in_bounds-after:                               ; preds = %[[VAL_374]], %[[VAL_376:.*]]
// CHECK:         ret void
// CHECK:       r8.in_bounds-true:                                ; preds = %[[VAL_376]]
// CHECK:         %[[VAL_377:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_378:.*]] = getelementptr inbounds float, float* %[[VAL_377]], i32 %[[VAL_357]]
// CHECK:         %[[VAL_379:.*]] = load float, float* %[[VAL_378]], align 4, !invariant.load !94
// CHECK:         %[[VAL_380:.*]] = call float @__nv_expf(float %[[VAL_379]])
// CHECK:         %[[VAL_381:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_382:.*]] = getelementptr inbounds float, float* %[[VAL_381]], i32 %[[VAL_357]]
// CHECK:         store float %[[VAL_380]], float* %[[VAL_382]], align 4
// CHECK:         %[[VAL_383:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_384:.*]] = getelementptr inbounds float, float* %[[VAL_383]], i32 %[[VAL_361]]
// CHECK:         %[[VAL_385:.*]] = load float, float* %[[VAL_384]], align 4, !invariant.load !94
// CHECK:         %[[VAL_386:.*]] = call float @__nv_expf(float %[[VAL_385]])
// CHECK:         %[[VAL_387:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_388:.*]] = getelementptr inbounds float, float* %[[VAL_387]], i32 %[[VAL_361]]
// CHECK:         store float %[[VAL_386]], float* %[[VAL_388]], align 4
// CHECK:         %[[VAL_389:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_390:.*]] = getelementptr inbounds float, float* %[[VAL_389]], i32 %[[VAL_365]]
// CHECK:         %[[VAL_391:.*]] = load float, float* %[[VAL_390]], align 4, !invariant.load !94
// CHECK:         %[[VAL_392:.*]] = call float @__nv_expf(float %[[VAL_391]])
// CHECK:         %[[VAL_393:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_394:.*]] = getelementptr inbounds float, float* %[[VAL_393]], i32 %[[VAL_365]]
// CHECK:         store float %[[VAL_392]], float* %[[VAL_394]], align 4
// CHECK:         %[[VAL_395:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_396:.*]] = getelementptr inbounds float, float* %[[VAL_395]], i32 %[[VAL_369]]
// CHECK:         %[[VAL_397:.*]] = load float, float* %[[VAL_396]], align 4, !invariant.load !94
// CHECK:         %[[VAL_398:.*]] = call float @__nv_expf(float %[[VAL_397]])
// CHECK:         %[[VAL_399:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_400:.*]] = getelementptr inbounds float, float* %[[VAL_399]], i32 %[[VAL_369]]
// CHECK:         store float %[[VAL_398]], float* %[[VAL_400]], align 4
// CHECK:         br label %[[VAL_375]]
// CHECK:       entry:
// CHECK:         %[[VAL_401:.*]] = getelementptr inbounds i8, i8* %[[VAL_402:.*]], i64 0
// CHECK:         %[[VAL_403:.*]] = bitcast i8* %[[VAL_401]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_404:.*]] = getelementptr inbounds i8, i8* %[[VAL_405:.*]], i64 0
// CHECK:         %[[VAL_406:.*]] = bitcast i8* %[[VAL_404]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_407:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_408:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_409:.*]] = mul nuw nsw i32 %[[VAL_407]], 256
// CHECK:         %[[VAL_410:.*]] = add nuw nsw i32 %[[VAL_409]], %[[VAL_408]]
// CHECK:         %[[VAL_411:.*]] = icmp ult i32 %[[VAL_410]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_411]])
// CHECK:         %[[VAL_412:.*]] = mul nuw nsw i32 %[[VAL_410]], 4
// CHECK:         %[[VAL_413:.*]] = udiv i32 %[[VAL_412]], 1
// CHECK:         %[[VAL_414:.*]] = urem i32 %[[VAL_413]], 200
// CHECK:         %[[VAL_415:.*]] = udiv i32 %[[VAL_412]], 200
// CHECK:         %[[VAL_416:.*]] = add nuw nsw i32 %[[VAL_412]], 1
// CHECK:         %[[VAL_417:.*]] = udiv i32 %[[VAL_416]], 1
// CHECK:         %[[VAL_418:.*]] = urem i32 %[[VAL_417]], 200
// CHECK:         %[[VAL_419:.*]] = udiv i32 %[[VAL_416]], 200
// CHECK:         %[[VAL_420:.*]] = add nuw nsw i32 %[[VAL_412]], 2
// CHECK:         %[[VAL_421:.*]] = udiv i32 %[[VAL_420]], 1
// CHECK:         %[[VAL_422:.*]] = urem i32 %[[VAL_421]], 200
// CHECK:         %[[VAL_423:.*]] = udiv i32 %[[VAL_420]], 200
// CHECK:         %[[VAL_424:.*]] = add nuw nsw i32 %[[VAL_412]], 3
// CHECK:         %[[VAL_425:.*]] = udiv i32 %[[VAL_424]], 1
// CHECK:         %[[VAL_426:.*]] = urem i32 %[[VAL_425]], 200
// CHECK:         %[[VAL_427:.*]] = udiv i32 %[[VAL_424]], 200
// CHECK:         %[[VAL_428:.*]] = icmp ult i32 %[[VAL_412]], 20000
// CHECK:         br i1 %[[VAL_428]], label %[[VAL_429:.*]], label %[[VAL_430:.*]]
// CHECK:       r9.in_bounds-after:                               ; preds = %[[VAL_429]], %[[VAL_431:.*]]
// CHECK:         ret void
// CHECK:       r9.in_bounds-true:                                ; preds = %[[VAL_431]]
// CHECK:         %[[VAL_432:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_433:.*]] = getelementptr inbounds float, float* %[[VAL_432]], i32 %[[VAL_412]]
// CHECK:         %[[VAL_434:.*]] = load float, float* %[[VAL_433]], align 4, !invariant.load !94
// CHECK:         %[[VAL_435:.*]] = call float @__nv_expm1f(float %[[VAL_434]])
// CHECK:         %[[VAL_436:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_437:.*]] = getelementptr inbounds float, float* %[[VAL_436]], i32 %[[VAL_412]]
// CHECK:         store float %[[VAL_435]], float* %[[VAL_437]], align 4
// CHECK:         %[[VAL_438:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_439:.*]] = getelementptr inbounds float, float* %[[VAL_438]], i32 %[[VAL_416]]
// CHECK:         %[[VAL_440:.*]] = load float, float* %[[VAL_439]], align 4, !invariant.load !94
// CHECK:         %[[VAL_441:.*]] = call float @__nv_expm1f(float %[[VAL_440]])
// CHECK:         %[[VAL_442:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_443:.*]] = getelementptr inbounds float, float* %[[VAL_442]], i32 %[[VAL_416]]
// CHECK:         store float %[[VAL_441]], float* %[[VAL_443]], align 4
// CHECK:         %[[VAL_444:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_445:.*]] = getelementptr inbounds float, float* %[[VAL_444]], i32 %[[VAL_420]]
// CHECK:         %[[VAL_446:.*]] = load float, float* %[[VAL_445]], align 4, !invariant.load !94
// CHECK:         %[[VAL_447:.*]] = call float @__nv_expm1f(float %[[VAL_446]])
// CHECK:         %[[VAL_448:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_449:.*]] = getelementptr inbounds float, float* %[[VAL_448]], i32 %[[VAL_420]]
// CHECK:         store float %[[VAL_447]], float* %[[VAL_449]], align 4
// CHECK:         %[[VAL_450:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_451:.*]] = getelementptr inbounds float, float* %[[VAL_450]], i32 %[[VAL_424]]
// CHECK:         %[[VAL_452:.*]] = load float, float* %[[VAL_451]], align 4, !invariant.load !94
// CHECK:         %[[VAL_453:.*]] = call float @__nv_expm1f(float %[[VAL_452]])
// CHECK:         %[[VAL_454:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_455:.*]] = getelementptr inbounds float, float* %[[VAL_454]], i32 %[[VAL_424]]
// CHECK:         store float %[[VAL_453]], float* %[[VAL_455]], align 4
// CHECK:         br label %[[VAL_430]]
// CHECK:       entry:
// CHECK:         %[[VAL_456:.*]] = getelementptr inbounds i8, i8* %[[VAL_457:.*]], i64 0
// CHECK:         %[[VAL_458:.*]] = bitcast i8* %[[VAL_456]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_459:.*]] = getelementptr inbounds i8, i8* %[[VAL_460:.*]], i64 0
// CHECK:         %[[VAL_461:.*]] = bitcast i8* %[[VAL_459]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_462:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_463:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_464:.*]] = mul nuw nsw i32 %[[VAL_462]], 256
// CHECK:         %[[VAL_465:.*]] = add nuw nsw i32 %[[VAL_464]], %[[VAL_463]]
// CHECK:         %[[VAL_466:.*]] = icmp ult i32 %[[VAL_465]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_466]])
// CHECK:         %[[VAL_467:.*]] = mul nuw nsw i32 %[[VAL_465]], 4
// CHECK:         %[[VAL_468:.*]] = udiv i32 %[[VAL_467]], 1
// CHECK:         %[[VAL_469:.*]] = urem i32 %[[VAL_468]], 200
// CHECK:         %[[VAL_470:.*]] = udiv i32 %[[VAL_467]], 200
// CHECK:         %[[VAL_471:.*]] = add nuw nsw i32 %[[VAL_467]], 1
// CHECK:         %[[VAL_472:.*]] = udiv i32 %[[VAL_471]], 1
// CHECK:         %[[VAL_473:.*]] = urem i32 %[[VAL_472]], 200
// CHECK:         %[[VAL_474:.*]] = udiv i32 %[[VAL_471]], 200
// CHECK:         %[[VAL_475:.*]] = add nuw nsw i32 %[[VAL_467]], 2
// CHECK:         %[[VAL_476:.*]] = udiv i32 %[[VAL_475]], 1
// CHECK:         %[[VAL_477:.*]] = urem i32 %[[VAL_476]], 200
// CHECK:         %[[VAL_478:.*]] = udiv i32 %[[VAL_475]], 200
// CHECK:         %[[VAL_479:.*]] = add nuw nsw i32 %[[VAL_467]], 3
// CHECK:         %[[VAL_480:.*]] = udiv i32 %[[VAL_479]], 1
// CHECK:         %[[VAL_481:.*]] = urem i32 %[[VAL_480]], 200
// CHECK:         %[[VAL_482:.*]] = udiv i32 %[[VAL_479]], 200
// CHECK:         %[[VAL_483:.*]] = icmp ult i32 %[[VAL_467]], 20000
// CHECK:         br i1 %[[VAL_483]], label %[[VAL_484:.*]], label %[[VAL_485:.*]]
// CHECK:       r10.in_bounds-after:                              ; preds = %[[VAL_484]], %[[VAL_486:.*]]
// CHECK:         ret void
// CHECK:       r10.in_bounds-true:                               ; preds = %[[VAL_486]]
// CHECK:         %[[VAL_487:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_488:.*]] = getelementptr inbounds float, float* %[[VAL_487]], i32 %[[VAL_467]]
// CHECK:         %[[VAL_489:.*]] = load float, float* %[[VAL_488]], align 4, !invariant.load !94
// CHECK:         %[[VAL_490:.*]] = call float @llvm.floor.f32(float %[[VAL_489]])
// CHECK:         %[[VAL_491:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_492:.*]] = getelementptr inbounds float, float* %[[VAL_491]], i32 %[[VAL_467]]
// CHECK:         store float %[[VAL_490]], float* %[[VAL_492]], align 4
// CHECK:         %[[VAL_493:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_494:.*]] = getelementptr inbounds float, float* %[[VAL_493]], i32 %[[VAL_471]]
// CHECK:         %[[VAL_495:.*]] = load float, float* %[[VAL_494]], align 4, !invariant.load !94
// CHECK:         %[[VAL_496:.*]] = call float @llvm.floor.f32(float %[[VAL_495]])
// CHECK:         %[[VAL_497:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_498:.*]] = getelementptr inbounds float, float* %[[VAL_497]], i32 %[[VAL_471]]
// CHECK:         store float %[[VAL_496]], float* %[[VAL_498]], align 4
// CHECK:         %[[VAL_499:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_500:.*]] = getelementptr inbounds float, float* %[[VAL_499]], i32 %[[VAL_475]]
// CHECK:         %[[VAL_501:.*]] = load float, float* %[[VAL_500]], align 4, !invariant.load !94
// CHECK:         %[[VAL_502:.*]] = call float @llvm.floor.f32(float %[[VAL_501]])
// CHECK:         %[[VAL_503:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_504:.*]] = getelementptr inbounds float, float* %[[VAL_503]], i32 %[[VAL_475]]
// CHECK:         store float %[[VAL_502]], float* %[[VAL_504]], align 4
// CHECK:         %[[VAL_505:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_506:.*]] = getelementptr inbounds float, float* %[[VAL_505]], i32 %[[VAL_479]]
// CHECK:         %[[VAL_507:.*]] = load float, float* %[[VAL_506]], align 4, !invariant.load !94
// CHECK:         %[[VAL_508:.*]] = call float @llvm.floor.f32(float %[[VAL_507]])
// CHECK:         %[[VAL_509:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_510:.*]] = getelementptr inbounds float, float* %[[VAL_509]], i32 %[[VAL_479]]
// CHECK:         store float %[[VAL_508]], float* %[[VAL_510]], align 4
// CHECK:         br label %[[VAL_485]]
// CHECK:       entry:
// CHECK:         %[[VAL_511:.*]] = getelementptr inbounds i8, i8* %[[VAL_512:.*]], i64 0
// CHECK:         %[[VAL_513:.*]] = bitcast i8* %[[VAL_511]] to [100 x [200 x %[[VAL_514:.*]]]]*
// CHECK:         %[[VAL_515:.*]] = getelementptr inbounds i8, i8* %[[VAL_516:.*]], i64 0
// CHECK:         %[[VAL_517:.*]] = bitcast i8* %[[VAL_515]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_518:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_519:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_520:.*]] = mul nuw nsw i32 %[[VAL_518]], 256
// CHECK:         %[[VAL_521:.*]] = add nuw nsw i32 %[[VAL_520]], %[[VAL_519]]
// CHECK:         %[[VAL_522:.*]] = icmp ult i32 %[[VAL_521]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_522]])
// CHECK:         %[[VAL_523:.*]] = mul nuw nsw i32 %[[VAL_521]], 4
// CHECK:         %[[VAL_524:.*]] = udiv i32 %[[VAL_523]], 1
// CHECK:         %[[VAL_525:.*]] = urem i32 %[[VAL_524]], 200
// CHECK:         %[[VAL_526:.*]] = udiv i32 %[[VAL_523]], 200
// CHECK:         %[[VAL_527:.*]] = add nuw nsw i32 %[[VAL_523]], 1
// CHECK:         %[[VAL_528:.*]] = udiv i32 %[[VAL_527]], 1
// CHECK:         %[[VAL_529:.*]] = urem i32 %[[VAL_528]], 200
// CHECK:         %[[VAL_530:.*]] = udiv i32 %[[VAL_527]], 200
// CHECK:         %[[VAL_531:.*]] = add nuw nsw i32 %[[VAL_523]], 2
// CHECK:         %[[VAL_532:.*]] = udiv i32 %[[VAL_531]], 1
// CHECK:         %[[VAL_533:.*]] = urem i32 %[[VAL_532]], 200
// CHECK:         %[[VAL_534:.*]] = udiv i32 %[[VAL_531]], 200
// CHECK:         %[[VAL_535:.*]] = add nuw nsw i32 %[[VAL_523]], 3
// CHECK:         %[[VAL_536:.*]] = udiv i32 %[[VAL_535]], 1
// CHECK:         %[[VAL_537:.*]] = urem i32 %[[VAL_536]], 200
// CHECK:         %[[VAL_538:.*]] = udiv i32 %[[VAL_535]], 200
// CHECK:         %[[VAL_539:.*]] = icmp ult i32 %[[VAL_523]], 20000
// CHECK:         br i1 %[[VAL_539]], label %[[VAL_540:.*]], label %[[VAL_541:.*]]
// CHECK:       r11.in_bounds-after:                              ; preds = %[[VAL_540]], %[[VAL_542:.*]]
// CHECK:         ret void
// CHECK:       r11.in_bounds-true:                               ; preds = %[[VAL_542]]
// CHECK:         %[[VAL_543:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_544:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_543]], i32 %[[VAL_523]]
// CHECK:         %[[VAL_545:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_544]], align 1, !invariant.load !94
// CHECK:         %[[VAL_546:.*]] = extractvalue %[[VAL_514]] %[[VAL_545]], 1
// CHECK:         %[[VAL_547:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_548:.*]] = getelementptr inbounds float, float* %[[VAL_547]], i32 %[[VAL_523]]
// CHECK:         store float %[[VAL_546]], float* %[[VAL_548]], align 4
// CHECK:         %[[VAL_549:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_550:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_549]], i32 %[[VAL_527]]
// CHECK:         %[[VAL_551:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_550]], align 1, !invariant.load !94
// CHECK:         %[[VAL_552:.*]] = extractvalue %[[VAL_514]] %[[VAL_551]], 1
// CHECK:         %[[VAL_553:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_554:.*]] = getelementptr inbounds float, float* %[[VAL_553]], i32 %[[VAL_527]]
// CHECK:         store float %[[VAL_552]], float* %[[VAL_554]], align 4
// CHECK:         %[[VAL_555:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_556:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_555]], i32 %[[VAL_531]]
// CHECK:         %[[VAL_557:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_556]], align 1, !invariant.load !94
// CHECK:         %[[VAL_558:.*]] = extractvalue %[[VAL_514]] %[[VAL_557]], 1
// CHECK:         %[[VAL_559:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_560:.*]] = getelementptr inbounds float, float* %[[VAL_559]], i32 %[[VAL_531]]
// CHECK:         store float %[[VAL_558]], float* %[[VAL_560]], align 4
// CHECK:         %[[VAL_561:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_562:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_561]], i32 %[[VAL_535]]
// CHECK:         %[[VAL_563:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_562]], align 1, !invariant.load !94
// CHECK:         %[[VAL_564:.*]] = extractvalue %[[VAL_514]] %[[VAL_563]], 1
// CHECK:         %[[VAL_565:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_566:.*]] = getelementptr inbounds float, float* %[[VAL_565]], i32 %[[VAL_535]]
// CHECK:         store float %[[VAL_564]], float* %[[VAL_566]], align 4
// CHECK:         br label %[[VAL_541]]
// CHECK:       entry:
// CHECK:         %[[VAL_567:.*]] = getelementptr inbounds i8, i8* %[[VAL_568:.*]], i64 0
// CHECK:         %[[VAL_569:.*]] = bitcast i8* %[[VAL_567]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_570:.*]] = getelementptr inbounds i8, i8* %[[VAL_571:.*]], i64 0
// CHECK:         %[[VAL_572:.*]] = bitcast i8* %[[VAL_570]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_573:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_574:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_575:.*]] = mul nuw nsw i32 %[[VAL_573]], 256
// CHECK:         %[[VAL_576:.*]] = add nuw nsw i32 %[[VAL_575]], %[[VAL_574]]
// CHECK:         %[[VAL_577:.*]] = icmp ult i32 %[[VAL_576]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_577]])
// CHECK:         %[[VAL_578:.*]] = mul nuw nsw i32 %[[VAL_576]], 4
// CHECK:         %[[VAL_579:.*]] = udiv i32 %[[VAL_578]], 1
// CHECK:         %[[VAL_580:.*]] = urem i32 %[[VAL_579]], 200
// CHECK:         %[[VAL_581:.*]] = udiv i32 %[[VAL_578]], 200
// CHECK:         %[[VAL_582:.*]] = add nuw nsw i32 %[[VAL_578]], 1
// CHECK:         %[[VAL_583:.*]] = udiv i32 %[[VAL_582]], 1
// CHECK:         %[[VAL_584:.*]] = urem i32 %[[VAL_583]], 200
// CHECK:         %[[VAL_585:.*]] = udiv i32 %[[VAL_582]], 200
// CHECK:         %[[VAL_586:.*]] = add nuw nsw i32 %[[VAL_578]], 2
// CHECK:         %[[VAL_587:.*]] = udiv i32 %[[VAL_586]], 1
// CHECK:         %[[VAL_588:.*]] = urem i32 %[[VAL_587]], 200
// CHECK:         %[[VAL_589:.*]] = udiv i32 %[[VAL_586]], 200
// CHECK:         %[[VAL_590:.*]] = add nuw nsw i32 %[[VAL_578]], 3
// CHECK:         %[[VAL_591:.*]] = udiv i32 %[[VAL_590]], 1
// CHECK:         %[[VAL_592:.*]] = urem i32 %[[VAL_591]], 200
// CHECK:         %[[VAL_593:.*]] = udiv i32 %[[VAL_590]], 200
// CHECK:         %[[VAL_594:.*]] = icmp ult i32 %[[VAL_578]], 20000
// CHECK:         br i1 %[[VAL_594]], label %[[VAL_595:.*]], label %[[VAL_596:.*]]
// CHECK:       r12.in_bounds-after:                              ; preds = %[[VAL_595]], %[[VAL_597:.*]]
// CHECK:         ret void
// CHECK:       r12.in_bounds-true:                               ; preds = %[[VAL_597]]
// CHECK:         %[[VAL_598:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_599:.*]] = getelementptr inbounds float, float* %[[VAL_598]], i32 %[[VAL_578]]
// CHECK:         %[[VAL_600:.*]] = load float, float* %[[VAL_599]], align 4, !invariant.load !94
// CHECK:         %[[VAL_601:.*]] = call float @llvm.fabs.f32(float %[[VAL_600]])
// CHECK:         %[[VAL_602:.*]] = fcmp one float %[[VAL_601]], 0x7FF0000000000000
// CHECK:         %[[VAL_603:.*]] = zext i1 %[[VAL_602]] to i8
// CHECK:         %[[VAL_604:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_605:.*]] = getelementptr inbounds i8, i8* %[[VAL_604]], i32 %[[VAL_578]]
// CHECK:         store i8 %[[VAL_603]], i8* %[[VAL_605]], align 1
// CHECK:         %[[VAL_606:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_607:.*]] = getelementptr inbounds float, float* %[[VAL_606]], i32 %[[VAL_582]]
// CHECK:         %[[VAL_608:.*]] = load float, float* %[[VAL_607]], align 4, !invariant.load !94
// CHECK:         %[[VAL_609:.*]] = call float @llvm.fabs.f32(float %[[VAL_608]])
// CHECK:         %[[VAL_610:.*]] = fcmp one float %[[VAL_609]], 0x7FF0000000000000
// CHECK:         %[[VAL_611:.*]] = zext i1 %[[VAL_610]] to i8
// CHECK:         %[[VAL_612:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_613:.*]] = getelementptr inbounds i8, i8* %[[VAL_612]], i32 %[[VAL_582]]
// CHECK:         store i8 %[[VAL_611]], i8* %[[VAL_613]], align 1
// CHECK:         %[[VAL_614:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_615:.*]] = getelementptr inbounds float, float* %[[VAL_614]], i32 %[[VAL_586]]
// CHECK:         %[[VAL_616:.*]] = load float, float* %[[VAL_615]], align 4, !invariant.load !94
// CHECK:         %[[VAL_617:.*]] = call float @llvm.fabs.f32(float %[[VAL_616]])
// CHECK:         %[[VAL_618:.*]] = fcmp one float %[[VAL_617]], 0x7FF0000000000000
// CHECK:         %[[VAL_619:.*]] = zext i1 %[[VAL_618]] to i8
// CHECK:         %[[VAL_620:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_621:.*]] = getelementptr inbounds i8, i8* %[[VAL_620]], i32 %[[VAL_586]]
// CHECK:         store i8 %[[VAL_619]], i8* %[[VAL_621]], align 1
// CHECK:         %[[VAL_622:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_623:.*]] = getelementptr inbounds float, float* %[[VAL_622]], i32 %[[VAL_590]]
// CHECK:         %[[VAL_624:.*]] = load float, float* %[[VAL_623]], align 4, !invariant.load !94
// CHECK:         %[[VAL_625:.*]] = call float @llvm.fabs.f32(float %[[VAL_624]])
// CHECK:         %[[VAL_626:.*]] = fcmp one float %[[VAL_625]], 0x7FF0000000000000
// CHECK:         %[[VAL_627:.*]] = zext i1 %[[VAL_626]] to i8
// CHECK:         %[[VAL_628:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_629:.*]] = getelementptr inbounds i8, i8* %[[VAL_628]], i32 %[[VAL_590]]
// CHECK:         store i8 %[[VAL_627]], i8* %[[VAL_629]], align 1
// CHECK:         br label %[[VAL_596]]
// CHECK:       entry:
// CHECK:         %[[VAL_630:.*]] = getelementptr inbounds i8, i8* %[[VAL_631:.*]], i64 0
// CHECK:         %[[VAL_632:.*]] = bitcast i8* %[[VAL_630]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_633:.*]] = getelementptr inbounds i8, i8* %[[VAL_634:.*]], i64 0
// CHECK:         %[[VAL_635:.*]] = bitcast i8* %[[VAL_633]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_636:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_637:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_638:.*]] = mul nuw nsw i32 %[[VAL_636]], 256
// CHECK:         %[[VAL_639:.*]] = add nuw nsw i32 %[[VAL_638]], %[[VAL_637]]
// CHECK:         %[[VAL_640:.*]] = icmp ult i32 %[[VAL_639]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_640]])
// CHECK:         %[[VAL_641:.*]] = mul nuw nsw i32 %[[VAL_639]], 4
// CHECK:         %[[VAL_642:.*]] = udiv i32 %[[VAL_641]], 1
// CHECK:         %[[VAL_643:.*]] = urem i32 %[[VAL_642]], 200
// CHECK:         %[[VAL_644:.*]] = udiv i32 %[[VAL_641]], 200
// CHECK:         %[[VAL_645:.*]] = add nuw nsw i32 %[[VAL_641]], 1
// CHECK:         %[[VAL_646:.*]] = udiv i32 %[[VAL_645]], 1
// CHECK:         %[[VAL_647:.*]] = urem i32 %[[VAL_646]], 200
// CHECK:         %[[VAL_648:.*]] = udiv i32 %[[VAL_645]], 200
// CHECK:         %[[VAL_649:.*]] = add nuw nsw i32 %[[VAL_641]], 2
// CHECK:         %[[VAL_650:.*]] = udiv i32 %[[VAL_649]], 1
// CHECK:         %[[VAL_651:.*]] = urem i32 %[[VAL_650]], 200
// CHECK:         %[[VAL_652:.*]] = udiv i32 %[[VAL_649]], 200
// CHECK:         %[[VAL_653:.*]] = add nuw nsw i32 %[[VAL_641]], 3
// CHECK:         %[[VAL_654:.*]] = udiv i32 %[[VAL_653]], 1
// CHECK:         %[[VAL_655:.*]] = urem i32 %[[VAL_654]], 200
// CHECK:         %[[VAL_656:.*]] = udiv i32 %[[VAL_653]], 200
// CHECK:         %[[VAL_657:.*]] = icmp ult i32 %[[VAL_641]], 20000
// CHECK:         br i1 %[[VAL_657]], label %[[VAL_658:.*]], label %[[VAL_659:.*]]
// CHECK:       r13.in_bounds-after:                              ; preds = %[[VAL_658]], %[[VAL_660:.*]]
// CHECK:         ret void
// CHECK:       r13.in_bounds-true:                               ; preds = %[[VAL_660]]
// CHECK:         %[[VAL_661:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_662:.*]] = getelementptr inbounds float, float* %[[VAL_661]], i32 %[[VAL_641]]
// CHECK:         %[[VAL_663:.*]] = load float, float* %[[VAL_662]], align 4, !invariant.load !94
// CHECK:         %[[VAL_664:.*]] = call float @__nv_logf(float %[[VAL_663]])
// CHECK:         %[[VAL_665:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_666:.*]] = getelementptr inbounds float, float* %[[VAL_665]], i32 %[[VAL_641]]
// CHECK:         store float %[[VAL_664]], float* %[[VAL_666]], align 4
// CHECK:         %[[VAL_667:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_668:.*]] = getelementptr inbounds float, float* %[[VAL_667]], i32 %[[VAL_645]]
// CHECK:         %[[VAL_669:.*]] = load float, float* %[[VAL_668]], align 4, !invariant.load !94
// CHECK:         %[[VAL_670:.*]] = call float @__nv_logf(float %[[VAL_669]])
// CHECK:         %[[VAL_671:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_672:.*]] = getelementptr inbounds float, float* %[[VAL_671]], i32 %[[VAL_645]]
// CHECK:         store float %[[VAL_670]], float* %[[VAL_672]], align 4
// CHECK:         %[[VAL_673:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_674:.*]] = getelementptr inbounds float, float* %[[VAL_673]], i32 %[[VAL_649]]
// CHECK:         %[[VAL_675:.*]] = load float, float* %[[VAL_674]], align 4, !invariant.load !94
// CHECK:         %[[VAL_676:.*]] = call float @__nv_logf(float %[[VAL_675]])
// CHECK:         %[[VAL_677:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_678:.*]] = getelementptr inbounds float, float* %[[VAL_677]], i32 %[[VAL_649]]
// CHECK:         store float %[[VAL_676]], float* %[[VAL_678]], align 4
// CHECK:         %[[VAL_679:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_680:.*]] = getelementptr inbounds float, float* %[[VAL_679]], i32 %[[VAL_653]]
// CHECK:         %[[VAL_681:.*]] = load float, float* %[[VAL_680]], align 4, !invariant.load !94
// CHECK:         %[[VAL_682:.*]] = call float @__nv_logf(float %[[VAL_681]])
// CHECK:         %[[VAL_683:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_684:.*]] = getelementptr inbounds float, float* %[[VAL_683]], i32 %[[VAL_653]]
// CHECK:         store float %[[VAL_682]], float* %[[VAL_684]], align 4
// CHECK:         br label %[[VAL_659]]
// CHECK:       entry:
// CHECK:         %[[VAL_685:.*]] = getelementptr inbounds i8, i8* %[[VAL_686:.*]], i64 0
// CHECK:         %[[VAL_687:.*]] = bitcast i8* %[[VAL_685]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_688:.*]] = getelementptr inbounds i8, i8* %[[VAL_689:.*]], i64 0
// CHECK:         %[[VAL_690:.*]] = bitcast i8* %[[VAL_688]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_691:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_692:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_693:.*]] = mul nuw nsw i32 %[[VAL_691]], 256
// CHECK:         %[[VAL_694:.*]] = add nuw nsw i32 %[[VAL_693]], %[[VAL_692]]
// CHECK:         %[[VAL_695:.*]] = icmp ult i32 %[[VAL_694]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_695]])
// CHECK:         %[[VAL_696:.*]] = mul nuw nsw i32 %[[VAL_694]], 4
// CHECK:         %[[VAL_697:.*]] = udiv i32 %[[VAL_696]], 1
// CHECK:         %[[VAL_698:.*]] = urem i32 %[[VAL_697]], 200
// CHECK:         %[[VAL_699:.*]] = udiv i32 %[[VAL_696]], 200
// CHECK:         %[[VAL_700:.*]] = add nuw nsw i32 %[[VAL_696]], 1
// CHECK:         %[[VAL_701:.*]] = udiv i32 %[[VAL_700]], 1
// CHECK:         %[[VAL_702:.*]] = urem i32 %[[VAL_701]], 200
// CHECK:         %[[VAL_703:.*]] = udiv i32 %[[VAL_700]], 200
// CHECK:         %[[VAL_704:.*]] = add nuw nsw i32 %[[VAL_696]], 2
// CHECK:         %[[VAL_705:.*]] = udiv i32 %[[VAL_704]], 1
// CHECK:         %[[VAL_706:.*]] = urem i32 %[[VAL_705]], 200
// CHECK:         %[[VAL_707:.*]] = udiv i32 %[[VAL_704]], 200
// CHECK:         %[[VAL_708:.*]] = add nuw nsw i32 %[[VAL_696]], 3
// CHECK:         %[[VAL_709:.*]] = udiv i32 %[[VAL_708]], 1
// CHECK:         %[[VAL_710:.*]] = urem i32 %[[VAL_709]], 200
// CHECK:         %[[VAL_711:.*]] = udiv i32 %[[VAL_708]], 200
// CHECK:         %[[VAL_712:.*]] = icmp ult i32 %[[VAL_696]], 20000
// CHECK:         br i1 %[[VAL_712]], label %[[VAL_713:.*]], label %[[VAL_714:.*]]
// CHECK:       r14.in_bounds-after:                              ; preds = %[[VAL_713]], %[[VAL_715:.*]]
// CHECK:         ret void
// CHECK:       r14.in_bounds-true:                               ; preds = %[[VAL_715]]
// CHECK:         %[[VAL_716:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_717:.*]] = getelementptr inbounds float, float* %[[VAL_716]], i32 %[[VAL_696]]
// CHECK:         %[[VAL_718:.*]] = load float, float* %[[VAL_717]], align 4, !invariant.load !94
// CHECK:         %[[VAL_719:.*]] = call float @__nv_log1pf(float %[[VAL_718]])
// CHECK:         %[[VAL_720:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_721:.*]] = getelementptr inbounds float, float* %[[VAL_720]], i32 %[[VAL_696]]
// CHECK:         store float %[[VAL_719]], float* %[[VAL_721]], align 4
// CHECK:         %[[VAL_722:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_723:.*]] = getelementptr inbounds float, float* %[[VAL_722]], i32 %[[VAL_700]]
// CHECK:         %[[VAL_724:.*]] = load float, float* %[[VAL_723]], align 4, !invariant.load !94
// CHECK:         %[[VAL_725:.*]] = call float @__nv_log1pf(float %[[VAL_724]])
// CHECK:         %[[VAL_726:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_727:.*]] = getelementptr inbounds float, float* %[[VAL_726]], i32 %[[VAL_700]]
// CHECK:         store float %[[VAL_725]], float* %[[VAL_727]], align 4
// CHECK:         %[[VAL_728:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_729:.*]] = getelementptr inbounds float, float* %[[VAL_728]], i32 %[[VAL_704]]
// CHECK:         %[[VAL_730:.*]] = load float, float* %[[VAL_729]], align 4, !invariant.load !94
// CHECK:         %[[VAL_731:.*]] = call float @__nv_log1pf(float %[[VAL_730]])
// CHECK:         %[[VAL_732:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_733:.*]] = getelementptr inbounds float, float* %[[VAL_732]], i32 %[[VAL_704]]
// CHECK:         store float %[[VAL_731]], float* %[[VAL_733]], align 4
// CHECK:         %[[VAL_734:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_735:.*]] = getelementptr inbounds float, float* %[[VAL_734]], i32 %[[VAL_708]]
// CHECK:         %[[VAL_736:.*]] = load float, float* %[[VAL_735]], align 4, !invariant.load !94
// CHECK:         %[[VAL_737:.*]] = call float @__nv_log1pf(float %[[VAL_736]])
// CHECK:         %[[VAL_738:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_739:.*]] = getelementptr inbounds float, float* %[[VAL_738]], i32 %[[VAL_708]]
// CHECK:         store float %[[VAL_737]], float* %[[VAL_739]], align 4
// CHECK:         br label %[[VAL_714]]
// CHECK:       entry:
// CHECK:         %[[VAL_740:.*]] = getelementptr inbounds i8, i8* %[[VAL_741:.*]], i64 0
// CHECK:         %[[VAL_742:.*]] = bitcast i8* %[[VAL_740]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_743:.*]] = getelementptr inbounds i8, i8* %[[VAL_744:.*]], i64 0
// CHECK:         %[[VAL_745:.*]] = bitcast i8* %[[VAL_743]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_746:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_747:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_748:.*]] = mul nuw nsw i32 %[[VAL_746]], 256
// CHECK:         %[[VAL_749:.*]] = add nuw nsw i32 %[[VAL_748]], %[[VAL_747]]
// CHECK:         %[[VAL_750:.*]] = icmp ult i32 %[[VAL_749]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_750]])
// CHECK:         %[[VAL_751:.*]] = mul nuw nsw i32 %[[VAL_749]], 4
// CHECK:         %[[VAL_752:.*]] = udiv i32 %[[VAL_751]], 1
// CHECK:         %[[VAL_753:.*]] = urem i32 %[[VAL_752]], 200
// CHECK:         %[[VAL_754:.*]] = udiv i32 %[[VAL_751]], 200
// CHECK:         %[[VAL_755:.*]] = add nuw nsw i32 %[[VAL_751]], 1
// CHECK:         %[[VAL_756:.*]] = udiv i32 %[[VAL_755]], 1
// CHECK:         %[[VAL_757:.*]] = urem i32 %[[VAL_756]], 200
// CHECK:         %[[VAL_758:.*]] = udiv i32 %[[VAL_755]], 200
// CHECK:         %[[VAL_759:.*]] = add nuw nsw i32 %[[VAL_751]], 2
// CHECK:         %[[VAL_760:.*]] = udiv i32 %[[VAL_759]], 1
// CHECK:         %[[VAL_761:.*]] = urem i32 %[[VAL_760]], 200
// CHECK:         %[[VAL_762:.*]] = udiv i32 %[[VAL_759]], 200
// CHECK:         %[[VAL_763:.*]] = add nuw nsw i32 %[[VAL_751]], 3
// CHECK:         %[[VAL_764:.*]] = udiv i32 %[[VAL_763]], 1
// CHECK:         %[[VAL_765:.*]] = urem i32 %[[VAL_764]], 200
// CHECK:         %[[VAL_766:.*]] = udiv i32 %[[VAL_763]], 200
// CHECK:         %[[VAL_767:.*]] = icmp ult i32 %[[VAL_751]], 20000
// CHECK:         br i1 %[[VAL_767]], label %[[VAL_768:.*]], label %[[VAL_769:.*]]
// CHECK:       r15.in_bounds-after:                              ; preds = %[[VAL_768]], %[[VAL_770:.*]]
// CHECK:         ret void
// CHECK:       r15.in_bounds-true:                               ; preds = %[[VAL_770]]
// CHECK:         %[[VAL_771:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_772:.*]] = getelementptr inbounds i8, i8* %[[VAL_771]], i32 %[[VAL_751]]
// CHECK:         %[[VAL_773:.*]] = load i8, i8* %[[VAL_772]], align 1, !invariant.load !94
// CHECK:         %[[VAL_774:.*]] = trunc i8 %[[VAL_773]] to i1
// CHECK:         %[[VAL_775:.*]] = xor i1 %[[VAL_774]], true
// CHECK:         %[[VAL_776:.*]] = zext i1 %[[VAL_775]] to i8
// CHECK:         %[[VAL_777:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_778:.*]] = getelementptr inbounds i8, i8* %[[VAL_777]], i32 %[[VAL_751]]
// CHECK:         store i8 %[[VAL_776]], i8* %[[VAL_778]], align 1
// CHECK:         %[[VAL_779:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_780:.*]] = getelementptr inbounds i8, i8* %[[VAL_779]], i32 %[[VAL_755]]
// CHECK:         %[[VAL_781:.*]] = load i8, i8* %[[VAL_780]], align 1, !invariant.load !94
// CHECK:         %[[VAL_782:.*]] = trunc i8 %[[VAL_781]] to i1
// CHECK:         %[[VAL_783:.*]] = xor i1 %[[VAL_782]], true
// CHECK:         %[[VAL_784:.*]] = zext i1 %[[VAL_783]] to i8
// CHECK:         %[[VAL_785:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_786:.*]] = getelementptr inbounds i8, i8* %[[VAL_785]], i32 %[[VAL_755]]
// CHECK:         store i8 %[[VAL_784]], i8* %[[VAL_786]], align 1
// CHECK:         %[[VAL_787:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_788:.*]] = getelementptr inbounds i8, i8* %[[VAL_787]], i32 %[[VAL_759]]
// CHECK:         %[[VAL_789:.*]] = load i8, i8* %[[VAL_788]], align 1, !invariant.load !94
// CHECK:         %[[VAL_790:.*]] = trunc i8 %[[VAL_789]] to i1
// CHECK:         %[[VAL_791:.*]] = xor i1 %[[VAL_790]], true
// CHECK:         %[[VAL_792:.*]] = zext i1 %[[VAL_791]] to i8
// CHECK:         %[[VAL_793:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_794:.*]] = getelementptr inbounds i8, i8* %[[VAL_793]], i32 %[[VAL_759]]
// CHECK:         store i8 %[[VAL_792]], i8* %[[VAL_794]], align 1
// CHECK:         %[[VAL_795:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_796:.*]] = getelementptr inbounds i8, i8* %[[VAL_795]], i32 %[[VAL_763]]
// CHECK:         %[[VAL_797:.*]] = load i8, i8* %[[VAL_796]], align 1, !invariant.load !94
// CHECK:         %[[VAL_798:.*]] = trunc i8 %[[VAL_797]] to i1
// CHECK:         %[[VAL_799:.*]] = xor i1 %[[VAL_798]], true
// CHECK:         %[[VAL_800:.*]] = zext i1 %[[VAL_799]] to i8
// CHECK:         %[[VAL_801:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_802:.*]] = getelementptr inbounds i8, i8* %[[VAL_801]], i32 %[[VAL_763]]
// CHECK:         store i8 %[[VAL_800]], i8* %[[VAL_802]], align 1
// CHECK:         br label %[[VAL_769]]
// CHECK:       entry:
// CHECK:         %[[VAL_803:.*]] = getelementptr inbounds i8, i8* %[[VAL_804:.*]], i64 0
// CHECK:         %[[VAL_805:.*]] = bitcast i8* %[[VAL_803]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_806:.*]] = getelementptr inbounds i8, i8* %[[VAL_807:.*]], i64 0
// CHECK:         %[[VAL_808:.*]] = bitcast i8* %[[VAL_806]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_809:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_810:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_811:.*]] = mul nuw nsw i32 %[[VAL_809]], 256
// CHECK:         %[[VAL_812:.*]] = add nuw nsw i32 %[[VAL_811]], %[[VAL_810]]
// CHECK:         %[[VAL_813:.*]] = icmp ult i32 %[[VAL_812]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_813]])
// CHECK:         %[[VAL_814:.*]] = mul nuw nsw i32 %[[VAL_812]], 4
// CHECK:         %[[VAL_815:.*]] = udiv i32 %[[VAL_814]], 1
// CHECK:         %[[VAL_816:.*]] = urem i32 %[[VAL_815]], 200
// CHECK:         %[[VAL_817:.*]] = udiv i32 %[[VAL_814]], 200
// CHECK:         %[[VAL_818:.*]] = add nuw nsw i32 %[[VAL_814]], 1
// CHECK:         %[[VAL_819:.*]] = udiv i32 %[[VAL_818]], 1
// CHECK:         %[[VAL_820:.*]] = urem i32 %[[VAL_819]], 200
// CHECK:         %[[VAL_821:.*]] = udiv i32 %[[VAL_818]], 200
// CHECK:         %[[VAL_822:.*]] = add nuw nsw i32 %[[VAL_814]], 2
// CHECK:         %[[VAL_823:.*]] = udiv i32 %[[VAL_822]], 1
// CHECK:         %[[VAL_824:.*]] = urem i32 %[[VAL_823]], 200
// CHECK:         %[[VAL_825:.*]] = udiv i32 %[[VAL_822]], 200
// CHECK:         %[[VAL_826:.*]] = add nuw nsw i32 %[[VAL_814]], 3
// CHECK:         %[[VAL_827:.*]] = udiv i32 %[[VAL_826]], 1
// CHECK:         %[[VAL_828:.*]] = urem i32 %[[VAL_827]], 200
// CHECK:         %[[VAL_829:.*]] = udiv i32 %[[VAL_826]], 200
// CHECK:         %[[VAL_830:.*]] = icmp ult i32 %[[VAL_814]], 20000
// CHECK:         br i1 %[[VAL_830]], label %[[VAL_831:.*]], label %[[VAL_832:.*]]
// CHECK:       r16.in_bounds-after:                              ; preds = %[[VAL_831]], %[[VAL_833:.*]]
// CHECK:         ret void
// CHECK:       r16.in_bounds-true:                               ; preds = %[[VAL_833]]
// CHECK:         %[[VAL_834:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_835:.*]] = getelementptr inbounds float, float* %[[VAL_834]], i32 %[[VAL_814]]
// CHECK:         %[[VAL_836:.*]] = load float, float* %[[VAL_835]], align 4, !invariant.load !94
// CHECK:         %[[VAL_837:.*]] = fneg float %[[VAL_836]]
// CHECK:         %[[VAL_838:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_839:.*]] = getelementptr inbounds float, float* %[[VAL_838]], i32 %[[VAL_814]]
// CHECK:         store float %[[VAL_837]], float* %[[VAL_839]], align 4
// CHECK:         %[[VAL_840:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_841:.*]] = getelementptr inbounds float, float* %[[VAL_840]], i32 %[[VAL_818]]
// CHECK:         %[[VAL_842:.*]] = load float, float* %[[VAL_841]], align 4, !invariant.load !94
// CHECK:         %[[VAL_843:.*]] = fneg float %[[VAL_842]]
// CHECK:         %[[VAL_844:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_845:.*]] = getelementptr inbounds float, float* %[[VAL_844]], i32 %[[VAL_818]]
// CHECK:         store float %[[VAL_843]], float* %[[VAL_845]], align 4
// CHECK:         %[[VAL_846:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_847:.*]] = getelementptr inbounds float, float* %[[VAL_846]], i32 %[[VAL_822]]
// CHECK:         %[[VAL_848:.*]] = load float, float* %[[VAL_847]], align 4, !invariant.load !94
// CHECK:         %[[VAL_849:.*]] = fneg float %[[VAL_848]]
// CHECK:         %[[VAL_850:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_851:.*]] = getelementptr inbounds float, float* %[[VAL_850]], i32 %[[VAL_822]]
// CHECK:         store float %[[VAL_849]], float* %[[VAL_851]], align 4
// CHECK:         %[[VAL_852:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_853:.*]] = getelementptr inbounds float, float* %[[VAL_852]], i32 %[[VAL_826]]
// CHECK:         %[[VAL_854:.*]] = load float, float* %[[VAL_853]], align 4, !invariant.load !94
// CHECK:         %[[VAL_855:.*]] = fneg float %[[VAL_854]]
// CHECK:         %[[VAL_856:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_857:.*]] = getelementptr inbounds float, float* %[[VAL_856]], i32 %[[VAL_826]]
// CHECK:         store float %[[VAL_855]], float* %[[VAL_857]], align 4
// CHECK:         br label %[[VAL_832]]
// CHECK:       entry:
// CHECK:         %[[VAL_858:.*]] = getelementptr inbounds i8, i8* %[[VAL_859:.*]], i64 0
// CHECK:         %[[VAL_860:.*]] = bitcast i8* %[[VAL_858]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_861:.*]] = getelementptr inbounds i8, i8* %[[VAL_862:.*]], i64 0
// CHECK:         %[[VAL_863:.*]] = bitcast i8* %[[VAL_861]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_864:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_865:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_866:.*]] = mul nuw nsw i32 %[[VAL_864]], 256
// CHECK:         %[[VAL_867:.*]] = add nuw nsw i32 %[[VAL_866]], %[[VAL_865]]
// CHECK:         %[[VAL_868:.*]] = icmp ult i32 %[[VAL_867]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_868]])
// CHECK:         %[[VAL_869:.*]] = mul nuw nsw i32 %[[VAL_867]], 4
// CHECK:         %[[VAL_870:.*]] = udiv i32 %[[VAL_869]], 1
// CHECK:         %[[VAL_871:.*]] = urem i32 %[[VAL_870]], 200
// CHECK:         %[[VAL_872:.*]] = udiv i32 %[[VAL_869]], 200
// CHECK:         %[[VAL_873:.*]] = add nuw nsw i32 %[[VAL_869]], 1
// CHECK:         %[[VAL_874:.*]] = udiv i32 %[[VAL_873]], 1
// CHECK:         %[[VAL_875:.*]] = urem i32 %[[VAL_874]], 200
// CHECK:         %[[VAL_876:.*]] = udiv i32 %[[VAL_873]], 200
// CHECK:         %[[VAL_877:.*]] = add nuw nsw i32 %[[VAL_869]], 2
// CHECK:         %[[VAL_878:.*]] = udiv i32 %[[VAL_877]], 1
// CHECK:         %[[VAL_879:.*]] = urem i32 %[[VAL_878]], 200
// CHECK:         %[[VAL_880:.*]] = udiv i32 %[[VAL_877]], 200
// CHECK:         %[[VAL_881:.*]] = add nuw nsw i32 %[[VAL_869]], 3
// CHECK:         %[[VAL_882:.*]] = udiv i32 %[[VAL_881]], 1
// CHECK:         %[[VAL_883:.*]] = urem i32 %[[VAL_882]], 200
// CHECK:         %[[VAL_884:.*]] = udiv i32 %[[VAL_881]], 200
// CHECK:         %[[VAL_885:.*]] = icmp ult i32 %[[VAL_869]], 20000
// CHECK:         br i1 %[[VAL_885]], label %[[VAL_886:.*]], label %[[VAL_887:.*]]
// CHECK:       r17.in_bounds-after:                              ; preds = %[[VAL_886]], %[[VAL_888:.*]]
// CHECK:         ret void
// CHECK:       r17.in_bounds-true:                               ; preds = %[[VAL_888]]
// CHECK:         %[[VAL_889:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_890:.*]] = getelementptr inbounds i32, i32* %[[VAL_889]], i32 %[[VAL_869]]
// CHECK:         %[[VAL_891:.*]] = load i32, i32* %[[VAL_890]], align 4, !invariant.load !94
// CHECK:         %[[VAL_892:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_891]])
// CHECK:         %[[VAL_893:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_894:.*]] = getelementptr inbounds i32, i32* %[[VAL_893]], i32 %[[VAL_869]]
// CHECK:         store i32 %[[VAL_892]], i32* %[[VAL_894]], align 4
// CHECK:         %[[VAL_895:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_896:.*]] = getelementptr inbounds i32, i32* %[[VAL_895]], i32 %[[VAL_873]]
// CHECK:         %[[VAL_897:.*]] = load i32, i32* %[[VAL_896]], align 4, !invariant.load !94
// CHECK:         %[[VAL_898:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_897]])
// CHECK:         %[[VAL_899:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_900:.*]] = getelementptr inbounds i32, i32* %[[VAL_899]], i32 %[[VAL_873]]
// CHECK:         store i32 %[[VAL_898]], i32* %[[VAL_900]], align 4
// CHECK:         %[[VAL_901:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_902:.*]] = getelementptr inbounds i32, i32* %[[VAL_901]], i32 %[[VAL_877]]
// CHECK:         %[[VAL_903:.*]] = load i32, i32* %[[VAL_902]], align 4, !invariant.load !94
// CHECK:         %[[VAL_904:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_903]])
// CHECK:         %[[VAL_905:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_906:.*]] = getelementptr inbounds i32, i32* %[[VAL_905]], i32 %[[VAL_877]]
// CHECK:         store i32 %[[VAL_904]], i32* %[[VAL_906]], align 4
// CHECK:         %[[VAL_907:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_908:.*]] = getelementptr inbounds i32, i32* %[[VAL_907]], i32 %[[VAL_881]]
// CHECK:         %[[VAL_909:.*]] = load i32, i32* %[[VAL_908]], align 4, !invariant.load !94
// CHECK:         %[[VAL_910:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_909]])
// CHECK:         %[[VAL_911:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_912:.*]] = getelementptr inbounds i32, i32* %[[VAL_911]], i32 %[[VAL_881]]
// CHECK:         store i32 %[[VAL_910]], i32* %[[VAL_912]], align 4
// CHECK:         br label %[[VAL_887]]
// CHECK:       entry:
// CHECK:         %[[VAL_913:.*]] = getelementptr inbounds i8, i8* %[[VAL_914:.*]], i64 0
// CHECK:         %[[VAL_915:.*]] = bitcast i8* %[[VAL_913]] to [100 x [200 x %[[VAL_916:.*]]]]*
// CHECK:         %[[VAL_917:.*]] = getelementptr inbounds i8, i8* %[[VAL_918:.*]], i64 0
// CHECK:         %[[VAL_919:.*]] = bitcast i8* %[[VAL_917]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_920:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_921:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_922:.*]] = mul nuw nsw i32 %[[VAL_920]], 256
// CHECK:         %[[VAL_923:.*]] = add nuw nsw i32 %[[VAL_922]], %[[VAL_921]]
// CHECK:         %[[VAL_924:.*]] = icmp ult i32 %[[VAL_923]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_924]])
// CHECK:         %[[VAL_925:.*]] = mul nuw nsw i32 %[[VAL_923]], 4
// CHECK:         %[[VAL_926:.*]] = udiv i32 %[[VAL_925]], 1
// CHECK:         %[[VAL_927:.*]] = urem i32 %[[VAL_926]], 200
// CHECK:         %[[VAL_928:.*]] = udiv i32 %[[VAL_925]], 200
// CHECK:         %[[VAL_929:.*]] = add nuw nsw i32 %[[VAL_925]], 1
// CHECK:         %[[VAL_930:.*]] = udiv i32 %[[VAL_929]], 1
// CHECK:         %[[VAL_931:.*]] = urem i32 %[[VAL_930]], 200
// CHECK:         %[[VAL_932:.*]] = udiv i32 %[[VAL_929]], 200
// CHECK:         %[[VAL_933:.*]] = add nuw nsw i32 %[[VAL_925]], 2
// CHECK:         %[[VAL_934:.*]] = udiv i32 %[[VAL_933]], 1
// CHECK:         %[[VAL_935:.*]] = urem i32 %[[VAL_934]], 200
// CHECK:         %[[VAL_936:.*]] = udiv i32 %[[VAL_933]], 200
// CHECK:         %[[VAL_937:.*]] = add nuw nsw i32 %[[VAL_925]], 3
// CHECK:         %[[VAL_938:.*]] = udiv i32 %[[VAL_937]], 1
// CHECK:         %[[VAL_939:.*]] = urem i32 %[[VAL_938]], 200
// CHECK:         %[[VAL_940:.*]] = udiv i32 %[[VAL_937]], 200
// CHECK:         %[[VAL_941:.*]] = icmp ult i32 %[[VAL_925]], 20000
// CHECK:         br i1 %[[VAL_941]], label %[[VAL_942:.*]], label %[[VAL_943:.*]]
// CHECK:       r18.in_bounds-after:                              ; preds = %[[VAL_942]], %[[VAL_944:.*]]
// CHECK:         ret void
// CHECK:       r18.in_bounds-true:                               ; preds = %[[VAL_944]]
// CHECK:         %[[VAL_945:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_946:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_945]], i32 %[[VAL_925]]
// CHECK:         %[[VAL_947:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_946]], align 1, !invariant.load !94
// CHECK:         %[[VAL_948:.*]] = extractvalue %[[VAL_916]] %[[VAL_947]], 0
// CHECK:         %[[VAL_949:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_950:.*]] = getelementptr inbounds float, float* %[[VAL_949]], i32 %[[VAL_925]]
// CHECK:         store float %[[VAL_948]], float* %[[VAL_950]], align 4
// CHECK:         %[[VAL_951:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_952:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_951]], i32 %[[VAL_929]]
// CHECK:         %[[VAL_953:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_952]], align 1, !invariant.load !94
// CHECK:         %[[VAL_954:.*]] = extractvalue %[[VAL_916]] %[[VAL_953]], 0
// CHECK:         %[[VAL_955:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_956:.*]] = getelementptr inbounds float, float* %[[VAL_955]], i32 %[[VAL_929]]
// CHECK:         store float %[[VAL_954]], float* %[[VAL_956]], align 4
// CHECK:         %[[VAL_957:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_958:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_957]], i32 %[[VAL_933]]
// CHECK:         %[[VAL_959:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_958]], align 1, !invariant.load !94
// CHECK:         %[[VAL_960:.*]] = extractvalue %[[VAL_916]] %[[VAL_959]], 0
// CHECK:         %[[VAL_961:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_962:.*]] = getelementptr inbounds float, float* %[[VAL_961]], i32 %[[VAL_933]]
// CHECK:         store float %[[VAL_960]], float* %[[VAL_962]], align 4
// CHECK:         %[[VAL_963:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_964:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_963]], i32 %[[VAL_937]]
// CHECK:         %[[VAL_965:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_964]], align 1, !invariant.load !94
// CHECK:         %[[VAL_966:.*]] = extractvalue %[[VAL_916]] %[[VAL_965]], 0
// CHECK:         %[[VAL_967:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_968:.*]] = getelementptr inbounds float, float* %[[VAL_967]], i32 %[[VAL_937]]
// CHECK:         store float %[[VAL_966]], float* %[[VAL_968]], align 4
// CHECK:         br label %[[VAL_943]]
// CHECK:       entry:
// CHECK:         %[[VAL_969:.*]] = getelementptr inbounds i8, i8* %[[VAL_970:.*]], i64 0
// CHECK:         %[[VAL_971:.*]] = bitcast i8* %[[VAL_969]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_972:.*]] = getelementptr inbounds i8, i8* %[[VAL_973:.*]], i64 0
// CHECK:         %[[VAL_974:.*]] = bitcast i8* %[[VAL_972]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_975:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_976:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_977:.*]] = mul nuw nsw i32 %[[VAL_975]], 256
// CHECK:         %[[VAL_978:.*]] = add nuw nsw i32 %[[VAL_977]], %[[VAL_976]]
// CHECK:         %[[VAL_979:.*]] = icmp ult i32 %[[VAL_978]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_979]])
// CHECK:         %[[VAL_980:.*]] = mul nuw nsw i32 %[[VAL_978]], 4
// CHECK:         %[[VAL_981:.*]] = udiv i32 %[[VAL_980]], 1
// CHECK:         %[[VAL_982:.*]] = urem i32 %[[VAL_981]], 200
// CHECK:         %[[VAL_983:.*]] = udiv i32 %[[VAL_980]], 200
// CHECK:         %[[VAL_984:.*]] = add nuw nsw i32 %[[VAL_980]], 1
// CHECK:         %[[VAL_985:.*]] = udiv i32 %[[VAL_984]], 1
// CHECK:         %[[VAL_986:.*]] = urem i32 %[[VAL_985]], 200
// CHECK:         %[[VAL_987:.*]] = udiv i32 %[[VAL_984]], 200
// CHECK:         %[[VAL_988:.*]] = add nuw nsw i32 %[[VAL_980]], 2
// CHECK:         %[[VAL_989:.*]] = udiv i32 %[[VAL_988]], 1
// CHECK:         %[[VAL_990:.*]] = urem i32 %[[VAL_989]], 200
// CHECK:         %[[VAL_991:.*]] = udiv i32 %[[VAL_988]], 200
// CHECK:         %[[VAL_992:.*]] = add nuw nsw i32 %[[VAL_980]], 3
// CHECK:         %[[VAL_993:.*]] = udiv i32 %[[VAL_992]], 1
// CHECK:         %[[VAL_994:.*]] = urem i32 %[[VAL_993]], 200
// CHECK:         %[[VAL_995:.*]] = udiv i32 %[[VAL_992]], 200
// CHECK:         %[[VAL_996:.*]] = icmp ult i32 %[[VAL_980]], 20000
// CHECK:         br i1 %[[VAL_996]], label %[[VAL_997:.*]], label %[[VAL_998:.*]]
// CHECK:       r19.in_bounds-after:                              ; preds = %[[VAL_997]], %[[VAL_999:.*]]
// CHECK:         ret void
// CHECK:       r19.in_bounds-true:                               ; preds = %[[VAL_999]]
// CHECK:         %[[VAL_1000:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1001:.*]] = getelementptr inbounds float, float* %[[VAL_1000]], i32 %[[VAL_980]]
// CHECK:         %[[VAL_1002:.*]] = load float, float* %[[VAL_1001]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1003:.*]] = bitcast float %[[VAL_1002]] to i32
// CHECK:         %[[VAL_1004:.*]] = and i32 %[[VAL_1003]], 2048
// CHECK:         %[[VAL_1005:.*]] = lshr i32 %[[VAL_1004]], 11
// CHECK:         %[[VAL_1006:.*]] = add i32 %[[VAL_1005]], 1023
// CHECK:         %[[VAL_1007:.*]] = add i32 %[[VAL_1003]], %[[VAL_1006]]
// CHECK:         %[[VAL_1008:.*]] = and i32 %[[VAL_1007]], -2048
// CHECK:         %[[VAL_1009:.*]] = and i32 %[[VAL_1008]], 2139095040
// CHECK:         %[[VAL_1010:.*]] = icmp ugt i32 %[[VAL_1009]], 1191182336
// CHECK:         %[[VAL_1011:.*]] = icmp ule i32 %[[VAL_1009]], 939524096
// CHECK:         %[[VAL_1012:.*]] = and i32 %[[VAL_1008]], -2147483648
// CHECK:         %[[VAL_1013:.*]] = or i32 %[[VAL_1012]], 2139095040
// CHECK:         %[[VAL_1014:.*]] = select i1 %[[VAL_1010]], i32 %[[VAL_1013]], i32 %[[VAL_1008]]
// CHECK:         %[[VAL_1015:.*]] = select i1 %[[VAL_1011]], i32 %[[VAL_1012]], i32 %[[VAL_1014]]
// CHECK:         %[[VAL_1016:.*]] = bitcast i32 %[[VAL_1015]] to float
// CHECK:         %[[VAL_1017:.*]] = fcmp uno float %[[VAL_1002]], %[[VAL_1002]]
// CHECK:         %[[VAL_1018:.*]] = select i1 %[[VAL_1017]], float %[[VAL_1002]], float %[[VAL_1016]]
// CHECK:         %[[VAL_1019:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1020:.*]] = getelementptr inbounds float, float* %[[VAL_1019]], i32 %[[VAL_980]]
// CHECK:         store float %[[VAL_1018]], float* %[[VAL_1020]], align 4
// CHECK:         %[[VAL_1021:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1022:.*]] = getelementptr inbounds float, float* %[[VAL_1021]], i32 %[[VAL_984]]
// CHECK:         %[[VAL_1023:.*]] = load float, float* %[[VAL_1022]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1024:.*]] = bitcast float %[[VAL_1023]] to i32
// CHECK:         %[[VAL_1025:.*]] = and i32 %[[VAL_1024]], 2048
// CHECK:         %[[VAL_1026:.*]] = lshr i32 %[[VAL_1025]], 11
// CHECK:         %[[VAL_1027:.*]] = add i32 %[[VAL_1026]], 1023
// CHECK:         %[[VAL_1028:.*]] = add i32 %[[VAL_1024]], %[[VAL_1027]]
// CHECK:         %[[VAL_1029:.*]] = and i32 %[[VAL_1028]], -2048
// CHECK:         %[[VAL_1030:.*]] = and i32 %[[VAL_1029]], 2139095040
// CHECK:         %[[VAL_1031:.*]] = icmp ugt i32 %[[VAL_1030]], 1191182336
// CHECK:         %[[VAL_1032:.*]] = icmp ule i32 %[[VAL_1030]], 939524096
// CHECK:         %[[VAL_1033:.*]] = and i32 %[[VAL_1029]], -2147483648
// CHECK:         %[[VAL_1034:.*]] = or i32 %[[VAL_1033]], 2139095040
// CHECK:         %[[VAL_1035:.*]] = select i1 %[[VAL_1031]], i32 %[[VAL_1034]], i32 %[[VAL_1029]]
// CHECK:         %[[VAL_1036:.*]] = select i1 %[[VAL_1032]], i32 %[[VAL_1033]], i32 %[[VAL_1035]]
// CHECK:         %[[VAL_1037:.*]] = bitcast i32 %[[VAL_1036]] to float
// CHECK:         %[[VAL_1038:.*]] = fcmp uno float %[[VAL_1023]], %[[VAL_1023]]
// CHECK:         %[[VAL_1039:.*]] = select i1 %[[VAL_1038]], float %[[VAL_1023]], float %[[VAL_1037]]
// CHECK:         %[[VAL_1040:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1041:.*]] = getelementptr inbounds float, float* %[[VAL_1040]], i32 %[[VAL_984]]
// CHECK:         store float %[[VAL_1039]], float* %[[VAL_1041]], align 4
// CHECK:         %[[VAL_1042:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1043:.*]] = getelementptr inbounds float, float* %[[VAL_1042]], i32 %[[VAL_988]]
// CHECK:         %[[VAL_1044:.*]] = load float, float* %[[VAL_1043]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1045:.*]] = bitcast float %[[VAL_1044]] to i32
// CHECK:         %[[VAL_1046:.*]] = and i32 %[[VAL_1045]], 2048
// CHECK:         %[[VAL_1047:.*]] = lshr i32 %[[VAL_1046]], 11
// CHECK:         %[[VAL_1048:.*]] = add i32 %[[VAL_1047]], 1023
// CHECK:         %[[VAL_1049:.*]] = add i32 %[[VAL_1045]], %[[VAL_1048]]
// CHECK:         %[[VAL_1050:.*]] = and i32 %[[VAL_1049]], -2048
// CHECK:         %[[VAL_1051:.*]] = and i32 %[[VAL_1050]], 2139095040
// CHECK:         %[[VAL_1052:.*]] = icmp ugt i32 %[[VAL_1051]], 1191182336
// CHECK:         %[[VAL_1053:.*]] = icmp ule i32 %[[VAL_1051]], 939524096
// CHECK:         %[[VAL_1054:.*]] = and i32 %[[VAL_1050]], -2147483648
// CHECK:         %[[VAL_1055:.*]] = or i32 %[[VAL_1054]], 2139095040
// CHECK:         %[[VAL_1056:.*]] = select i1 %[[VAL_1052]], i32 %[[VAL_1055]], i32 %[[VAL_1050]]
// CHECK:         %[[VAL_1057:.*]] = select i1 %[[VAL_1053]], i32 %[[VAL_1054]], i32 %[[VAL_1056]]
// CHECK:         %[[VAL_1058:.*]] = bitcast i32 %[[VAL_1057]] to float
// CHECK:         %[[VAL_1059:.*]] = fcmp uno float %[[VAL_1044]], %[[VAL_1044]]
// CHECK:         %[[VAL_1060:.*]] = select i1 %[[VAL_1059]], float %[[VAL_1044]], float %[[VAL_1058]]
// CHECK:         %[[VAL_1061:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1062:.*]] = getelementptr inbounds float, float* %[[VAL_1061]], i32 %[[VAL_988]]
// CHECK:         store float %[[VAL_1060]], float* %[[VAL_1062]], align 4
// CHECK:         %[[VAL_1063:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1064:.*]] = getelementptr inbounds float, float* %[[VAL_1063]], i32 %[[VAL_992]]
// CHECK:         %[[VAL_1065:.*]] = load float, float* %[[VAL_1064]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1066:.*]] = bitcast float %[[VAL_1065]] to i32
// CHECK:         %[[VAL_1067:.*]] = and i32 %[[VAL_1066]], 2048
// CHECK:         %[[VAL_1068:.*]] = lshr i32 %[[VAL_1067]], 11
// CHECK:         %[[VAL_1069:.*]] = add i32 %[[VAL_1068]], 1023
// CHECK:         %[[VAL_1070:.*]] = add i32 %[[VAL_1066]], %[[VAL_1069]]
// CHECK:         %[[VAL_1071:.*]] = and i32 %[[VAL_1070]], -2048
// CHECK:         %[[VAL_1072:.*]] = and i32 %[[VAL_1071]], 2139095040
// CHECK:         %[[VAL_1073:.*]] = icmp ugt i32 %[[VAL_1072]], 1191182336
// CHECK:         %[[VAL_1074:.*]] = icmp ule i32 %[[VAL_1072]], 939524096
// CHECK:         %[[VAL_1075:.*]] = and i32 %[[VAL_1071]], -2147483648
// CHECK:         %[[VAL_1076:.*]] = or i32 %[[VAL_1075]], 2139095040
// CHECK:         %[[VAL_1077:.*]] = select i1 %[[VAL_1073]], i32 %[[VAL_1076]], i32 %[[VAL_1071]]
// CHECK:         %[[VAL_1078:.*]] = select i1 %[[VAL_1074]], i32 %[[VAL_1075]], i32 %[[VAL_1077]]
// CHECK:         %[[VAL_1079:.*]] = bitcast i32 %[[VAL_1078]] to float
// CHECK:         %[[VAL_1080:.*]] = fcmp uno float %[[VAL_1065]], %[[VAL_1065]]
// CHECK:         %[[VAL_1081:.*]] = select i1 %[[VAL_1080]], float %[[VAL_1065]], float %[[VAL_1079]]
// CHECK:         %[[VAL_1082:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1083:.*]] = getelementptr inbounds float, float* %[[VAL_1082]], i32 %[[VAL_992]]
// CHECK:         store float %[[VAL_1081]], float* %[[VAL_1083]], align 4
// CHECK:         br label %[[VAL_998]]
// CHECK:       entry:
// CHECK:         %[[VAL_1084:.*]] = getelementptr inbounds i8, i8* %[[VAL_1085:.*]], i64 0
// CHECK:         %[[VAL_1086:.*]] = bitcast i8* %[[VAL_1084]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1087:.*]] = getelementptr inbounds i8, i8* %[[VAL_1088:.*]], i64 0
// CHECK:         %[[VAL_1089:.*]] = bitcast i8* %[[VAL_1087]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1090:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1091:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1092:.*]] = mul nuw nsw i32 %[[VAL_1090]], 256
// CHECK:         %[[VAL_1093:.*]] = add nuw nsw i32 %[[VAL_1092]], %[[VAL_1091]]
// CHECK:         %[[VAL_1094:.*]] = icmp ult i32 %[[VAL_1093]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1094]])
// CHECK:         %[[VAL_1095:.*]] = mul nuw nsw i32 %[[VAL_1093]], 4
// CHECK:         %[[VAL_1096:.*]] = udiv i32 %[[VAL_1095]], 1
// CHECK:         %[[VAL_1097:.*]] = urem i32 %[[VAL_1096]], 200
// CHECK:         %[[VAL_1098:.*]] = udiv i32 %[[VAL_1095]], 200
// CHECK:         %[[VAL_1099:.*]] = add nuw nsw i32 %[[VAL_1095]], 1
// CHECK:         %[[VAL_1100:.*]] = udiv i32 %[[VAL_1099]], 1
// CHECK:         %[[VAL_1101:.*]] = urem i32 %[[VAL_1100]], 200
// CHECK:         %[[VAL_1102:.*]] = udiv i32 %[[VAL_1099]], 200
// CHECK:         %[[VAL_1103:.*]] = add nuw nsw i32 %[[VAL_1095]], 2
// CHECK:         %[[VAL_1104:.*]] = udiv i32 %[[VAL_1103]], 1
// CHECK:         %[[VAL_1105:.*]] = urem i32 %[[VAL_1104]], 200
// CHECK:         %[[VAL_1106:.*]] = udiv i32 %[[VAL_1103]], 200
// CHECK:         %[[VAL_1107:.*]] = add nuw nsw i32 %[[VAL_1095]], 3
// CHECK:         %[[VAL_1108:.*]] = udiv i32 %[[VAL_1107]], 1
// CHECK:         %[[VAL_1109:.*]] = urem i32 %[[VAL_1108]], 200
// CHECK:         %[[VAL_1110:.*]] = udiv i32 %[[VAL_1107]], 200
// CHECK:         %[[VAL_1111:.*]] = icmp ult i32 %[[VAL_1095]], 20000
// CHECK:         br i1 %[[VAL_1111]], label %[[VAL_1112:.*]], label %[[VAL_1113:.*]]
// CHECK:       r20.in_bounds-after:                              ; preds = %[[VAL_1112]], %[[VAL_1114:.*]]
// CHECK:         ret void
// CHECK:       r20.in_bounds-true:                               ; preds = %[[VAL_1114]]
// CHECK:         %[[VAL_1115:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1086]] to float*
// CHECK:         %[[VAL_1116:.*]] = getelementptr inbounds float, float* %[[VAL_1115]], i32 %[[VAL_1095]]
// CHECK:         %[[VAL_1117:.*]] = load float, float* %[[VAL_1116]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1118:.*]] = call float @__nv_rsqrtf(float %[[VAL_1117]])
// CHECK:         %[[VAL_1119:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1089]] to float*
// CHECK:         %[[VAL_1120:.*]] = getelementptr inbounds float, float* %[[VAL_1119]], i32 %[[VAL_1095]]
// CHECK:         store float %[[VAL_1118]], float* %[[VAL_1120]], align 4
// CHECK:         %[[VAL_1121:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1086]] to float*
// CHECK:         %[[VAL_1122:.*]] = getelementptr inbounds float, float* %[[VAL_1121]], i32 %[[VAL_1099]]
// CHECK:         %[[VAL_1123:.*]] = load float, float* %[[VAL_1122]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1124:.*]] = call float @__nv_rsqrtf(float %[[VAL_1123]])
// CHECK:         %[[VAL_1125:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1089]] to float*
// CHECK:         %[[VAL_1126:.*]] = getelementptr inbounds float, float* %[[VAL_1125]], i32 %[[VAL_1099]]
// CHECK:         store float %[[VAL_1124]], float* %[[VAL_1126]], align 4
// CHECK:         %[[VAL_1127:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1086]] to float*
// CHECK:         %[[VAL_1128:.*]] = getelementptr inbounds float, float* %[[VAL_1127]], i32 %[[VAL_1103]]
// CHECK:         %[[VAL_1129:.*]] = load float, float* %[[VAL_1128]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1130:.*]] = call float @__nv_rsqrtf(float %[[VAL_1129]])
// CHECK:         %[[VAL_1131:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1089]] to float*
// CHECK:         %[[VAL_1132:.*]] = getelementptr inbounds float, float* %[[VAL_1131]], i32 %[[VAL_1103]]
// CHECK:         store float %[[VAL_1130]], float* %[[VAL_1132]], align 4
// CHECK:         %[[VAL_1133:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1086]] to float*
// CHECK:         %[[VAL_1134:.*]] = getelementptr inbounds float, float* %[[VAL_1133]], i32 %[[VAL_1107]]
// CHECK:         %[[VAL_1135:.*]] = load float, float* %[[VAL_1134]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1136:.*]] = call float @__nv_rsqrtf(float %[[VAL_1135]])
// CHECK:         %[[VAL_1137:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1089]] to float*
// CHECK:         %[[VAL_1138:.*]] = getelementptr inbounds float, float* %[[VAL_1137]], i32 %[[VAL_1107]]
// CHECK:         store float %[[VAL_1136]], float* %[[VAL_1138]], align 4
// CHECK:         br label %[[VAL_1113]]
// CHECK:       entry:
// CHECK:         %[[VAL_1139:.*]] = getelementptr inbounds i8, i8* %[[VAL_1140:.*]], i64 0
// CHECK:         %[[VAL_1141:.*]] = bitcast i8* %[[VAL_1139]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1142:.*]] = getelementptr inbounds i8, i8* %[[VAL_1143:.*]], i64 0
// CHECK:         %[[VAL_1144:.*]] = bitcast i8* %[[VAL_1142]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1145:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1146:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1147:.*]] = mul nuw nsw i32 %[[VAL_1145]], 256
// CHECK:         %[[VAL_1148:.*]] = add nuw nsw i32 %[[VAL_1147]], %[[VAL_1146]]
// CHECK:         %[[VAL_1149:.*]] = icmp ult i32 %[[VAL_1148]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1149]])
// CHECK:         %[[VAL_1150:.*]] = mul nuw nsw i32 %[[VAL_1148]], 4
// CHECK:         %[[VAL_1151:.*]] = udiv i32 %[[VAL_1150]], 1
// CHECK:         %[[VAL_1152:.*]] = urem i32 %[[VAL_1151]], 200
// CHECK:         %[[VAL_1153:.*]] = udiv i32 %[[VAL_1150]], 200
// CHECK:         %[[VAL_1154:.*]] = add nuw nsw i32 %[[VAL_1150]], 1
// CHECK:         %[[VAL_1155:.*]] = udiv i32 %[[VAL_1154]], 1
// CHECK:         %[[VAL_1156:.*]] = urem i32 %[[VAL_1155]], 200
// CHECK:         %[[VAL_1157:.*]] = udiv i32 %[[VAL_1154]], 200
// CHECK:         %[[VAL_1158:.*]] = add nuw nsw i32 %[[VAL_1150]], 2
// CHECK:         %[[VAL_1159:.*]] = udiv i32 %[[VAL_1158]], 1
// CHECK:         %[[VAL_1160:.*]] = urem i32 %[[VAL_1159]], 200
// CHECK:         %[[VAL_1161:.*]] = udiv i32 %[[VAL_1158]], 200
// CHECK:         %[[VAL_1162:.*]] = add nuw nsw i32 %[[VAL_1150]], 3
// CHECK:         %[[VAL_1163:.*]] = udiv i32 %[[VAL_1162]], 1
// CHECK:         %[[VAL_1164:.*]] = urem i32 %[[VAL_1163]], 200
// CHECK:         %[[VAL_1165:.*]] = udiv i32 %[[VAL_1162]], 200
// CHECK:         %[[VAL_1166:.*]] = icmp ult i32 %[[VAL_1150]], 20000
// CHECK:         br i1 %[[VAL_1166]], label %[[VAL_1167:.*]], label %[[VAL_1168:.*]]
// CHECK:       r22.in_bounds-after:                              ; preds = %[[VAL_1167]], %[[VAL_1169:.*]]
// CHECK:         ret void
// CHECK:       r22.in_bounds-true:                               ; preds = %[[VAL_1169]]
// CHECK:         %[[VAL_1170:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1141]] to float*
// CHECK:         %[[VAL_1171:.*]] = getelementptr inbounds float, float* %[[VAL_1170]], i32 %[[VAL_1150]]
// CHECK:         %[[VAL_1172:.*]] = load float, float* %[[VAL_1171]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1173:.*]] = fcmp one float %[[VAL_1172]], 0.000000e+00
// CHECK:         %[[VAL_1174:.*]] = uitofp i1 %[[VAL_1173]] to float
// CHECK:         %[[VAL_1175:.*]] = call float @llvm.copysign.f32(float %[[VAL_1174]], float %[[VAL_1172]])
// CHECK:         %[[VAL_1176:.*]] = fcmp uno float %[[VAL_1172]], %[[VAL_1172]]
// CHECK:         %[[VAL_1177:.*]] = select i1 %[[VAL_1176]], float %[[VAL_1172]], float %[[VAL_1175]]
// CHECK:         %[[VAL_1178:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1144]] to float*
// CHECK:         %[[VAL_1179:.*]] = getelementptr inbounds float, float* %[[VAL_1178]], i32 %[[VAL_1150]]
// CHECK:         store float %[[VAL_1177]], float* %[[VAL_1179]], align 4
// CHECK:         %[[VAL_1180:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1141]] to float*
// CHECK:         %[[VAL_1181:.*]] = getelementptr inbounds float, float* %[[VAL_1180]], i32 %[[VAL_1154]]
// CHECK:         %[[VAL_1182:.*]] = load float, float* %[[VAL_1181]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1183:.*]] = fcmp one float %[[VAL_1182]], 0.000000e+00
// CHECK:         %[[VAL_1184:.*]] = uitofp i1 %[[VAL_1183]] to float
// CHECK:         %[[VAL_1185:.*]] = call float @llvm.copysign.f32(float %[[VAL_1184]], float %[[VAL_1182]])
// CHECK:         %[[VAL_1186:.*]] = fcmp uno float %[[VAL_1182]], %[[VAL_1182]]
// CHECK:         %[[VAL_1187:.*]] = select i1 %[[VAL_1186]], float %[[VAL_1182]], float %[[VAL_1185]]
// CHECK:         %[[VAL_1188:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1144]] to float*
// CHECK:         %[[VAL_1189:.*]] = getelementptr inbounds float, float* %[[VAL_1188]], i32 %[[VAL_1154]]
// CHECK:         store float %[[VAL_1187]], float* %[[VAL_1189]], align 4
// CHECK:         %[[VAL_1190:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1141]] to float*
// CHECK:         %[[VAL_1191:.*]] = getelementptr inbounds float, float* %[[VAL_1190]], i32 %[[VAL_1158]]
// CHECK:         %[[VAL_1192:.*]] = load float, float* %[[VAL_1191]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1193:.*]] = fcmp one float %[[VAL_1192]], 0.000000e+00
// CHECK:         %[[VAL_1194:.*]] = uitofp i1 %[[VAL_1193]] to float
// CHECK:         %[[VAL_1195:.*]] = call float @llvm.copysign.f32(float %[[VAL_1194]], float %[[VAL_1192]])
// CHECK:         %[[VAL_1196:.*]] = fcmp uno float %[[VAL_1192]], %[[VAL_1192]]
// CHECK:         %[[VAL_1197:.*]] = select i1 %[[VAL_1196]], float %[[VAL_1192]], float %[[VAL_1195]]
// CHECK:         %[[VAL_1198:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1144]] to float*
// CHECK:         %[[VAL_1199:.*]] = getelementptr inbounds float, float* %[[VAL_1198]], i32 %[[VAL_1158]]
// CHECK:         store float %[[VAL_1197]], float* %[[VAL_1199]], align 4
// CHECK:         %[[VAL_1200:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1141]] to float*
// CHECK:         %[[VAL_1201:.*]] = getelementptr inbounds float, float* %[[VAL_1200]], i32 %[[VAL_1162]]
// CHECK:         %[[VAL_1202:.*]] = load float, float* %[[VAL_1201]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1203:.*]] = fcmp one float %[[VAL_1202]], 0.000000e+00
// CHECK:         %[[VAL_1204:.*]] = uitofp i1 %[[VAL_1203]] to float
// CHECK:         %[[VAL_1205:.*]] = call float @llvm.copysign.f32(float %[[VAL_1204]], float %[[VAL_1202]])
// CHECK:         %[[VAL_1206:.*]] = fcmp uno float %[[VAL_1202]], %[[VAL_1202]]
// CHECK:         %[[VAL_1207:.*]] = select i1 %[[VAL_1206]], float %[[VAL_1202]], float %[[VAL_1205]]
// CHECK:         %[[VAL_1208:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1144]] to float*
// CHECK:         %[[VAL_1209:.*]] = getelementptr inbounds float, float* %[[VAL_1208]], i32 %[[VAL_1162]]
// CHECK:         store float %[[VAL_1207]], float* %[[VAL_1209]], align 4
// CHECK:         br label %[[VAL_1168]]
// CHECK:       entry:
// CHECK:         %[[VAL_1210:.*]] = getelementptr inbounds i8, i8* %[[VAL_1211:.*]], i64 0
// CHECK:         %[[VAL_1212:.*]] = bitcast i8* %[[VAL_1210]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1213:.*]] = getelementptr inbounds i8, i8* %[[VAL_1214:.*]], i64 0
// CHECK:         %[[VAL_1215:.*]] = bitcast i8* %[[VAL_1213]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1216:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1217:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_1218:.*]] = mul nuw nsw i32 %[[VAL_1216]], 1024
// CHECK:         %[[VAL_1219:.*]] = add nuw nsw i32 %[[VAL_1218]], %[[VAL_1217]]
// CHECK:         %[[VAL_1220:.*]] = icmp ult i32 %[[VAL_1219]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_1220]])
// CHECK:         %[[VAL_1221:.*]] = udiv i32 %[[VAL_1219]], 1
// CHECK:         %[[VAL_1222:.*]] = urem i32 %[[VAL_1221]], 200
// CHECK:         %[[VAL_1223:.*]] = udiv i32 %[[VAL_1219]], 200
// CHECK:         %[[VAL_1224:.*]] = icmp ult i32 %[[VAL_1219]], 20000
// CHECK:         br i1 %[[VAL_1224]], label %[[VAL_1225:.*]], label %[[VAL_1226:.*]]
// CHECK:       r23.in_bounds-after:                              ; preds = %[[VAL_1225]], %[[VAL_1227:.*]]
// CHECK:         ret void
// CHECK:       r23.in_bounds-true:                               ; preds = %[[VAL_1227]]
// CHECK:         %[[VAL_1228:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1212]] to float*
// CHECK:         %[[VAL_1229:.*]] = getelementptr inbounds float, float* %[[VAL_1228]], i32 %[[VAL_1219]]
// CHECK:         %[[VAL_1230:.*]] = load float, float* %[[VAL_1229]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1231:.*]] = call float @__nv_sinf(float %[[VAL_1230]])
// CHECK:         %[[VAL_1232:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1215]] to float*
// CHECK:         %[[VAL_1233:.*]] = getelementptr inbounds float, float* %[[VAL_1232]], i32 %[[VAL_1219]]
// CHECK:         store float %[[VAL_1231]], float* %[[VAL_1233]], align 4
// CHECK:         br label %[[VAL_1226]]
// CHECK:       entry:
// CHECK:         %[[VAL_1234:.*]] = getelementptr inbounds i8, i8* %[[VAL_1235:.*]], i64 0
// CHECK:         %[[VAL_1236:.*]] = bitcast i8* %[[VAL_1234]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1237:.*]] = getelementptr inbounds i8, i8* %[[VAL_1238:.*]], i64 0
// CHECK:         %[[VAL_1239:.*]] = bitcast i8* %[[VAL_1237]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1240:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1241:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1242:.*]] = mul nuw nsw i32 %[[VAL_1240]], 256
// CHECK:         %[[VAL_1243:.*]] = add nuw nsw i32 %[[VAL_1242]], %[[VAL_1241]]
// CHECK:         %[[VAL_1244:.*]] = icmp ult i32 %[[VAL_1243]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1244]])
// CHECK:         %[[VAL_1245:.*]] = mul nuw nsw i32 %[[VAL_1243]], 4
// CHECK:         %[[VAL_1246:.*]] = udiv i32 %[[VAL_1245]], 1
// CHECK:         %[[VAL_1247:.*]] = urem i32 %[[VAL_1246]], 200
// CHECK:         %[[VAL_1248:.*]] = udiv i32 %[[VAL_1245]], 200
// CHECK:         %[[VAL_1249:.*]] = add nuw nsw i32 %[[VAL_1245]], 1
// CHECK:         %[[VAL_1250:.*]] = udiv i32 %[[VAL_1249]], 1
// CHECK:         %[[VAL_1251:.*]] = urem i32 %[[VAL_1250]], 200
// CHECK:         %[[VAL_1252:.*]] = udiv i32 %[[VAL_1249]], 200
// CHECK:         %[[VAL_1253:.*]] = add nuw nsw i32 %[[VAL_1245]], 2
// CHECK:         %[[VAL_1254:.*]] = udiv i32 %[[VAL_1253]], 1
// CHECK:         %[[VAL_1255:.*]] = urem i32 %[[VAL_1254]], 200
// CHECK:         %[[VAL_1256:.*]] = udiv i32 %[[VAL_1253]], 200
// CHECK:         %[[VAL_1257:.*]] = add nuw nsw i32 %[[VAL_1245]], 3
// CHECK:         %[[VAL_1258:.*]] = udiv i32 %[[VAL_1257]], 1
// CHECK:         %[[VAL_1259:.*]] = urem i32 %[[VAL_1258]], 200
// CHECK:         %[[VAL_1260:.*]] = udiv i32 %[[VAL_1257]], 200
// CHECK:         %[[VAL_1261:.*]] = icmp ult i32 %[[VAL_1245]], 20000
// CHECK:         br i1 %[[VAL_1261]], label %[[VAL_1262:.*]], label %[[VAL_1263:.*]]
// CHECK:       r24.in_bounds-after:                              ; preds = %[[VAL_1262]], %[[VAL_1264:.*]]
// CHECK:         ret void
// CHECK:       r24.in_bounds-true:                               ; preds = %[[VAL_1264]]
// CHECK:         %[[VAL_1265:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1236]] to float*
// CHECK:         %[[VAL_1266:.*]] = getelementptr inbounds float, float* %[[VAL_1265]], i32 %[[VAL_1245]]
// CHECK:         %[[VAL_1267:.*]] = load float, float* %[[VAL_1266]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1268:.*]] = call float @__nv_sqrtf(float %[[VAL_1267]])
// CHECK:         %[[VAL_1269:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1239]] to float*
// CHECK:         %[[VAL_1270:.*]] = getelementptr inbounds float, float* %[[VAL_1269]], i32 %[[VAL_1245]]
// CHECK:         store float %[[VAL_1268]], float* %[[VAL_1270]], align 4
// CHECK:         %[[VAL_1271:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1236]] to float*
// CHECK:         %[[VAL_1272:.*]] = getelementptr inbounds float, float* %[[VAL_1271]], i32 %[[VAL_1249]]
// CHECK:         %[[VAL_1273:.*]] = load float, float* %[[VAL_1272]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1274:.*]] = call float @__nv_sqrtf(float %[[VAL_1273]])
// CHECK:         %[[VAL_1275:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1239]] to float*
// CHECK:         %[[VAL_1276:.*]] = getelementptr inbounds float, float* %[[VAL_1275]], i32 %[[VAL_1249]]
// CHECK:         store float %[[VAL_1274]], float* %[[VAL_1276]], align 4
// CHECK:         %[[VAL_1277:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1236]] to float*
// CHECK:         %[[VAL_1278:.*]] = getelementptr inbounds float, float* %[[VAL_1277]], i32 %[[VAL_1253]]
// CHECK:         %[[VAL_1279:.*]] = load float, float* %[[VAL_1278]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1280:.*]] = call float @__nv_sqrtf(float %[[VAL_1279]])
// CHECK:         %[[VAL_1281:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1239]] to float*
// CHECK:         %[[VAL_1282:.*]] = getelementptr inbounds float, float* %[[VAL_1281]], i32 %[[VAL_1253]]
// CHECK:         store float %[[VAL_1280]], float* %[[VAL_1282]], align 4
// CHECK:         %[[VAL_1283:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1236]] to float*
// CHECK:         %[[VAL_1284:.*]] = getelementptr inbounds float, float* %[[VAL_1283]], i32 %[[VAL_1257]]
// CHECK:         %[[VAL_1285:.*]] = load float, float* %[[VAL_1284]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1286:.*]] = call float @__nv_sqrtf(float %[[VAL_1285]])
// CHECK:         %[[VAL_1287:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1239]] to float*
// CHECK:         %[[VAL_1288:.*]] = getelementptr inbounds float, float* %[[VAL_1287]], i32 %[[VAL_1257]]
// CHECK:         store float %[[VAL_1286]], float* %[[VAL_1288]], align 4
// CHECK:         br label %[[VAL_1263]]
// CHECK:       entry:
// CHECK:         %[[VAL_1289:.*]] = getelementptr inbounds i8, i8* %[[VAL_1290:.*]], i64 0
// CHECK:         %[[VAL_1291:.*]] = bitcast i8* %[[VAL_1289]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1292:.*]] = getelementptr inbounds i8, i8* %[[VAL_1293:.*]], i64 0
// CHECK:         %[[VAL_1294:.*]] = bitcast i8* %[[VAL_1292]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1295:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1296:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1297:.*]] = mul nuw nsw i32 %[[VAL_1295]], 256
// CHECK:         %[[VAL_1298:.*]] = add nuw nsw i32 %[[VAL_1297]], %[[VAL_1296]]
// CHECK:         %[[VAL_1299:.*]] = icmp ult i32 %[[VAL_1298]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1299]])
// CHECK:         %[[VAL_1300:.*]] = mul nuw nsw i32 %[[VAL_1298]], 4
// CHECK:         %[[VAL_1301:.*]] = udiv i32 %[[VAL_1300]], 1
// CHECK:         %[[VAL_1302:.*]] = urem i32 %[[VAL_1301]], 200
// CHECK:         %[[VAL_1303:.*]] = udiv i32 %[[VAL_1300]], 200
// CHECK:         %[[VAL_1304:.*]] = add nuw nsw i32 %[[VAL_1300]], 1
// CHECK:         %[[VAL_1305:.*]] = udiv i32 %[[VAL_1304]], 1
// CHECK:         %[[VAL_1306:.*]] = urem i32 %[[VAL_1305]], 200
// CHECK:         %[[VAL_1307:.*]] = udiv i32 %[[VAL_1304]], 200
// CHECK:         %[[VAL_1308:.*]] = add nuw nsw i32 %[[VAL_1300]], 2
// CHECK:         %[[VAL_1309:.*]] = udiv i32 %[[VAL_1308]], 1
// CHECK:         %[[VAL_1310:.*]] = urem i32 %[[VAL_1309]], 200
// CHECK:         %[[VAL_1311:.*]] = udiv i32 %[[VAL_1308]], 200
// CHECK:         %[[VAL_1312:.*]] = add nuw nsw i32 %[[VAL_1300]], 3
// CHECK:         %[[VAL_1313:.*]] = udiv i32 %[[VAL_1312]], 1
// CHECK:         %[[VAL_1314:.*]] = urem i32 %[[VAL_1313]], 200
// CHECK:         %[[VAL_1315:.*]] = udiv i32 %[[VAL_1312]], 200
// CHECK:         %[[VAL_1316:.*]] = icmp ult i32 %[[VAL_1300]], 20000
// CHECK:         br i1 %[[VAL_1316]], label %[[VAL_1317:.*]], label %[[VAL_1318:.*]]
// CHECK:       r25.in_bounds-after:                              ; preds = %[[VAL_1317]], %[[VAL_1319:.*]]
// CHECK:         ret void
// CHECK:       r25.in_bounds-true:                               ; preds = %[[VAL_1319]]
// CHECK:         %[[VAL_1320:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1291]] to float*
// CHECK:         %[[VAL_1321:.*]] = getelementptr inbounds float, float* %[[VAL_1320]], i32 %[[VAL_1300]]
// CHECK:         %[[VAL_1322:.*]] = load float, float* %[[VAL_1321]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1323:.*]] = call float @llvm.fabs.f32(float %[[VAL_1322]])
// CHECK:         %[[VAL_1324:.*]] = call float @__nv_powf(float %[[VAL_1323]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1325:.*]] = call float @llvm.copysign.f32(float %[[VAL_1324]], float %[[VAL_1322]])
// CHECK:         %[[VAL_1326:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1294]] to float*
// CHECK:         %[[VAL_1327:.*]] = getelementptr inbounds float, float* %[[VAL_1326]], i32 %[[VAL_1300]]
// CHECK:         store float %[[VAL_1325]], float* %[[VAL_1327]], align 4
// CHECK:         %[[VAL_1328:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1291]] to float*
// CHECK:         %[[VAL_1329:.*]] = getelementptr inbounds float, float* %[[VAL_1328]], i32 %[[VAL_1304]]
// CHECK:         %[[VAL_1330:.*]] = load float, float* %[[VAL_1329]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1331:.*]] = call float @llvm.fabs.f32(float %[[VAL_1330]])
// CHECK:         %[[VAL_1332:.*]] = call float @__nv_powf(float %[[VAL_1331]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1333:.*]] = call float @llvm.copysign.f32(float %[[VAL_1332]], float %[[VAL_1330]])
// CHECK:         %[[VAL_1334:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1294]] to float*
// CHECK:         %[[VAL_1335:.*]] = getelementptr inbounds float, float* %[[VAL_1334]], i32 %[[VAL_1304]]
// CHECK:         store float %[[VAL_1333]], float* %[[VAL_1335]], align 4
// CHECK:         %[[VAL_1336:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1291]] to float*
// CHECK:         %[[VAL_1337:.*]] = getelementptr inbounds float, float* %[[VAL_1336]], i32 %[[VAL_1308]]
// CHECK:         %[[VAL_1338:.*]] = load float, float* %[[VAL_1337]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1339:.*]] = call float @llvm.fabs.f32(float %[[VAL_1338]])
// CHECK:         %[[VAL_1340:.*]] = call float @__nv_powf(float %[[VAL_1339]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1341:.*]] = call float @llvm.copysign.f32(float %[[VAL_1340]], float %[[VAL_1338]])
// CHECK:         %[[VAL_1342:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1294]] to float*
// CHECK:         %[[VAL_1343:.*]] = getelementptr inbounds float, float* %[[VAL_1342]], i32 %[[VAL_1308]]
// CHECK:         store float %[[VAL_1341]], float* %[[VAL_1343]], align 4
// CHECK:         %[[VAL_1344:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1291]] to float*
// CHECK:         %[[VAL_1345:.*]] = getelementptr inbounds float, float* %[[VAL_1344]], i32 %[[VAL_1312]]
// CHECK:         %[[VAL_1346:.*]] = load float, float* %[[VAL_1345]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1347:.*]] = call float @llvm.fabs.f32(float %[[VAL_1346]])
// CHECK:         %[[VAL_1348:.*]] = call float @__nv_powf(float %[[VAL_1347]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1349:.*]] = call float @llvm.copysign.f32(float %[[VAL_1348]], float %[[VAL_1346]])
// CHECK:         %[[VAL_1350:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1294]] to float*
// CHECK:         %[[VAL_1351:.*]] = getelementptr inbounds float, float* %[[VAL_1350]], i32 %[[VAL_1312]]
// CHECK:         store float %[[VAL_1349]], float* %[[VAL_1351]], align 4
// CHECK:         br label %[[VAL_1318]]
// CHECK:       entry:
// CHECK:         %[[VAL_1352:.*]] = getelementptr inbounds i8, i8* %[[VAL_1353:.*]], i64 0
// CHECK:         %[[VAL_1354:.*]] = bitcast i8* %[[VAL_1352]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1355:.*]] = getelementptr inbounds i8, i8* %[[VAL_1356:.*]], i64 0
// CHECK:         %[[VAL_1357:.*]] = bitcast i8* %[[VAL_1355]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1358:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1359:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1360:.*]] = mul nuw nsw i32 %[[VAL_1358]], 256
// CHECK:         %[[VAL_1361:.*]] = add nuw nsw i32 %[[VAL_1360]], %[[VAL_1359]]
// CHECK:         %[[VAL_1362:.*]] = icmp ult i32 %[[VAL_1361]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1362]])
// CHECK:         %[[VAL_1363:.*]] = mul nuw nsw i32 %[[VAL_1361]], 4
// CHECK:         %[[VAL_1364:.*]] = udiv i32 %[[VAL_1363]], 1
// CHECK:         %[[VAL_1365:.*]] = urem i32 %[[VAL_1364]], 200
// CHECK:         %[[VAL_1366:.*]] = udiv i32 %[[VAL_1363]], 200
// CHECK:         %[[VAL_1367:.*]] = add nuw nsw i32 %[[VAL_1363]], 1
// CHECK:         %[[VAL_1368:.*]] = udiv i32 %[[VAL_1367]], 1
// CHECK:         %[[VAL_1369:.*]] = urem i32 %[[VAL_1368]], 200
// CHECK:         %[[VAL_1370:.*]] = udiv i32 %[[VAL_1367]], 200
// CHECK:         %[[VAL_1371:.*]] = add nuw nsw i32 %[[VAL_1363]], 2
// CHECK:         %[[VAL_1372:.*]] = udiv i32 %[[VAL_1371]], 1
// CHECK:         %[[VAL_1373:.*]] = urem i32 %[[VAL_1372]], 200
// CHECK:         %[[VAL_1374:.*]] = udiv i32 %[[VAL_1371]], 200
// CHECK:         %[[VAL_1375:.*]] = add nuw nsw i32 %[[VAL_1363]], 3
// CHECK:         %[[VAL_1376:.*]] = udiv i32 %[[VAL_1375]], 1
// CHECK:         %[[VAL_1377:.*]] = urem i32 %[[VAL_1376]], 200
// CHECK:         %[[VAL_1378:.*]] = udiv i32 %[[VAL_1375]], 200
// CHECK:         %[[VAL_1379:.*]] = icmp ult i32 %[[VAL_1363]], 20000
// CHECK:         br i1 %[[VAL_1379]], label %[[VAL_1380:.*]], label %[[VAL_1381:.*]]
// CHECK:       r26.in_bounds-after:                              ; preds = %[[VAL_1380]], %[[VAL_1382:.*]]
// CHECK:         ret void
// CHECK:       r26.in_bounds-true:                               ; preds = %[[VAL_1382]]
// CHECK:         %[[VAL_1383:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1354]] to float*
// CHECK:         %[[VAL_1384:.*]] = getelementptr inbounds float, float* %[[VAL_1383]], i32 %[[VAL_1363]]
// CHECK:         %[[VAL_1385:.*]] = load float, float* %[[VAL_1384]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1386:.*]] = call float @llvm.fabs.f32(float %[[VAL_1385]])
// CHECK:         %[[VAL_1387:.*]] = call float @llvm.fabs.f32(float %[[VAL_1385]])
// CHECK:         %[[VAL_1388:.*]] = fcmp olt float %[[VAL_1387]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1389:.*]] = fcmp uge float %[[VAL_1385]], -9.000000e+00
// CHECK:         %[[VAL_1390:.*]] = select i1 %[[VAL_1389]], float %[[VAL_1385]], float -9.000000e+00
// CHECK:         %[[VAL_1391:.*]] = fcmp ule float %[[VAL_1390]], 9.000000e+00
// CHECK:         %[[VAL_1392:.*]] = select i1 %[[VAL_1391]], float %[[VAL_1390]], float 9.000000e+00
// CHECK:         %[[VAL_1393:.*]] = fmul float %[[VAL_1392]], %[[VAL_1392]]
// CHECK:         %[[VAL_1394:.*]] = fmul float %[[VAL_1393]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1395:.*]] = fadd float %[[VAL_1394]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1396:.*]] = fmul float %[[VAL_1393]], %[[VAL_1395]]
// CHECK:         %[[VAL_1397:.*]] = fadd float %[[VAL_1396]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1398:.*]] = fmul float %[[VAL_1393]], %[[VAL_1397]]
// CHECK:         %[[VAL_1399:.*]] = fadd float %[[VAL_1398]], 0x3E6B800820000000
// CHECK:         %[[VAL_1400:.*]] = fmul float %[[VAL_1393]], %[[VAL_1399]]
// CHECK:         %[[VAL_1401:.*]] = fadd float %[[VAL_1400]], 0x3EEF286940000000
// CHECK:         %[[VAL_1402:.*]] = fmul float %[[VAL_1393]], %[[VAL_1401]]
// CHECK:         %[[VAL_1403:.*]] = fadd float %[[VAL_1402]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1404:.*]] = fmul float %[[VAL_1393]], %[[VAL_1403]]
// CHECK:         %[[VAL_1405:.*]] = fadd float %[[VAL_1404]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1406:.*]] = fmul float %[[VAL_1392]], %[[VAL_1405]]
// CHECK:         %[[VAL_1407:.*]] = fmul float %[[VAL_1393]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1408:.*]] = fadd float %[[VAL_1407]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1409:.*]] = fmul float %[[VAL_1393]], %[[VAL_1408]]
// CHECK:         %[[VAL_1410:.*]] = fadd float %[[VAL_1409]], 0x3F629540A0000000
// CHECK:         %[[VAL_1411:.*]] = fmul float %[[VAL_1393]], %[[VAL_1410]]
// CHECK:         %[[VAL_1412:.*]] = fadd float %[[VAL_1411]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1413:.*]] = fdiv float %[[VAL_1406]], %[[VAL_1412]]
// CHECK:         %[[VAL_1414:.*]] = select i1 %[[VAL_1388]], float %[[VAL_1385]], float %[[VAL_1413]]
// CHECK:         %[[VAL_1415:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1385]])
// CHECK:         %[[VAL_1416:.*]] = fcmp ult float %[[VAL_1386]], 2.000000e+01
// CHECK:         %[[VAL_1417:.*]] = select i1 %[[VAL_1416]], float %[[VAL_1414]], float %[[VAL_1415]]
// CHECK:         %[[VAL_1418:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1357]] to float*
// CHECK:         %[[VAL_1419:.*]] = getelementptr inbounds float, float* %[[VAL_1418]], i32 %[[VAL_1363]]
// CHECK:         store float %[[VAL_1417]], float* %[[VAL_1419]], align 4
// CHECK:         %[[VAL_1420:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1354]] to float*
// CHECK:         %[[VAL_1421:.*]] = getelementptr inbounds float, float* %[[VAL_1420]], i32 %[[VAL_1367]]
// CHECK:         %[[VAL_1422:.*]] = load float, float* %[[VAL_1421]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1423:.*]] = call float @llvm.fabs.f32(float %[[VAL_1422]])
// CHECK:         %[[VAL_1424:.*]] = call float @llvm.fabs.f32(float %[[VAL_1422]])
// CHECK:         %[[VAL_1425:.*]] = fcmp olt float %[[VAL_1424]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1426:.*]] = fcmp uge float %[[VAL_1422]], -9.000000e+00
// CHECK:         %[[VAL_1427:.*]] = select i1 %[[VAL_1426]], float %[[VAL_1422]], float -9.000000e+00
// CHECK:         %[[VAL_1428:.*]] = fcmp ule float %[[VAL_1427]], 9.000000e+00
// CHECK:         %[[VAL_1429:.*]] = select i1 %[[VAL_1428]], float %[[VAL_1427]], float 9.000000e+00
// CHECK:         %[[VAL_1430:.*]] = fmul float %[[VAL_1429]], %[[VAL_1429]]
// CHECK:         %[[VAL_1431:.*]] = fmul float %[[VAL_1430]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1432:.*]] = fadd float %[[VAL_1431]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1433:.*]] = fmul float %[[VAL_1430]], %[[VAL_1432]]
// CHECK:         %[[VAL_1434:.*]] = fadd float %[[VAL_1433]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1435:.*]] = fmul float %[[VAL_1430]], %[[VAL_1434]]
// CHECK:         %[[VAL_1436:.*]] = fadd float %[[VAL_1435]], 0x3E6B800820000000
// CHECK:         %[[VAL_1437:.*]] = fmul float %[[VAL_1430]], %[[VAL_1436]]
// CHECK:         %[[VAL_1438:.*]] = fadd float %[[VAL_1437]], 0x3EEF286940000000
// CHECK:         %[[VAL_1439:.*]] = fmul float %[[VAL_1430]], %[[VAL_1438]]
// CHECK:         %[[VAL_1440:.*]] = fadd float %[[VAL_1439]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1441:.*]] = fmul float %[[VAL_1430]], %[[VAL_1440]]
// CHECK:         %[[VAL_1442:.*]] = fadd float %[[VAL_1441]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1443:.*]] = fmul float %[[VAL_1429]], %[[VAL_1442]]
// CHECK:         %[[VAL_1444:.*]] = fmul float %[[VAL_1430]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1445:.*]] = fadd float %[[VAL_1444]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1446:.*]] = fmul float %[[VAL_1430]], %[[VAL_1445]]
// CHECK:         %[[VAL_1447:.*]] = fadd float %[[VAL_1446]], 0x3F629540A0000000
// CHECK:         %[[VAL_1448:.*]] = fmul float %[[VAL_1430]], %[[VAL_1447]]
// CHECK:         %[[VAL_1449:.*]] = fadd float %[[VAL_1448]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1450:.*]] = fdiv float %[[VAL_1443]], %[[VAL_1449]]
// CHECK:         %[[VAL_1451:.*]] = select i1 %[[VAL_1425]], float %[[VAL_1422]], float %[[VAL_1450]]
// CHECK:         %[[VAL_1452:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1422]])
// CHECK:         %[[VAL_1453:.*]] = fcmp ult float %[[VAL_1423]], 2.000000e+01
// CHECK:         %[[VAL_1454:.*]] = select i1 %[[VAL_1453]], float %[[VAL_1451]], float %[[VAL_1452]]
// CHECK:         %[[VAL_1455:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1357]] to float*
// CHECK:         %[[VAL_1456:.*]] = getelementptr inbounds float, float* %[[VAL_1455]], i32 %[[VAL_1367]]
// CHECK:         store float %[[VAL_1454]], float* %[[VAL_1456]], align 4
// CHECK:         %[[VAL_1457:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1354]] to float*
// CHECK:         %[[VAL_1458:.*]] = getelementptr inbounds float, float* %[[VAL_1457]], i32 %[[VAL_1371]]
// CHECK:         %[[VAL_1459:.*]] = load float, float* %[[VAL_1458]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1460:.*]] = call float @llvm.fabs.f32(float %[[VAL_1459]])
// CHECK:         %[[VAL_1461:.*]] = call float @llvm.fabs.f32(float %[[VAL_1459]])
// CHECK:         %[[VAL_1462:.*]] = fcmp olt float %[[VAL_1461]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1463:.*]] = fcmp uge float %[[VAL_1459]], -9.000000e+00
// CHECK:         %[[VAL_1464:.*]] = select i1 %[[VAL_1463]], float %[[VAL_1459]], float -9.000000e+00
// CHECK:         %[[VAL_1465:.*]] = fcmp ule float %[[VAL_1464]], 9.000000e+00
// CHECK:         %[[VAL_1466:.*]] = select i1 %[[VAL_1465]], float %[[VAL_1464]], float 9.000000e+00
// CHECK:         %[[VAL_1467:.*]] = fmul float %[[VAL_1466]], %[[VAL_1466]]
// CHECK:         %[[VAL_1468:.*]] = fmul float %[[VAL_1467]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1469:.*]] = fadd float %[[VAL_1468]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1470:.*]] = fmul float %[[VAL_1467]], %[[VAL_1469]]
// CHECK:         %[[VAL_1471:.*]] = fadd float %[[VAL_1470]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1472:.*]] = fmul float %[[VAL_1467]], %[[VAL_1471]]
// CHECK:         %[[VAL_1473:.*]] = fadd float %[[VAL_1472]], 0x3E6B800820000000
// CHECK:         %[[VAL_1474:.*]] = fmul float %[[VAL_1467]], %[[VAL_1473]]
// CHECK:         %[[VAL_1475:.*]] = fadd float %[[VAL_1474]], 0x3EEF286940000000
// CHECK:         %[[VAL_1476:.*]] = fmul float %[[VAL_1467]], %[[VAL_1475]]
// CHECK:         %[[VAL_1477:.*]] = fadd float %[[VAL_1476]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1478:.*]] = fmul float %[[VAL_1467]], %[[VAL_1477]]
// CHECK:         %[[VAL_1479:.*]] = fadd float %[[VAL_1478]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1480:.*]] = fmul float %[[VAL_1466]], %[[VAL_1479]]
// CHECK:         %[[VAL_1481:.*]] = fmul float %[[VAL_1467]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1482:.*]] = fadd float %[[VAL_1481]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1483:.*]] = fmul float %[[VAL_1467]], %[[VAL_1482]]
// CHECK:         %[[VAL_1484:.*]] = fadd float %[[VAL_1483]], 0x3F629540A0000000
// CHECK:         %[[VAL_1485:.*]] = fmul float %[[VAL_1467]], %[[VAL_1484]]
// CHECK:         %[[VAL_1486:.*]] = fadd float %[[VAL_1485]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1487:.*]] = fdiv float %[[VAL_1480]], %[[VAL_1486]]
// CHECK:         %[[VAL_1488:.*]] = select i1 %[[VAL_1462]], float %[[VAL_1459]], float %[[VAL_1487]]
// CHECK:         %[[VAL_1489:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1459]])
// CHECK:         %[[VAL_1490:.*]] = fcmp ult float %[[VAL_1460]], 2.000000e+01
// CHECK:         %[[VAL_1491:.*]] = select i1 %[[VAL_1490]], float %[[VAL_1488]], float %[[VAL_1489]]
// CHECK:         %[[VAL_1492:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1357]] to float*
// CHECK:         %[[VAL_1493:.*]] = getelementptr inbounds float, float* %[[VAL_1492]], i32 %[[VAL_1371]]
// CHECK:         store float %[[VAL_1491]], float* %[[VAL_1493]], align 4
// CHECK:         %[[VAL_1494:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1354]] to float*
// CHECK:         %[[VAL_1495:.*]] = getelementptr inbounds float, float* %[[VAL_1494]], i32 %[[VAL_1375]]
// CHECK:         %[[VAL_1496:.*]] = load float, float* %[[VAL_1495]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1497:.*]] = call float @llvm.fabs.f32(float %[[VAL_1496]])
// CHECK:         %[[VAL_1498:.*]] = call float @llvm.fabs.f32(float %[[VAL_1496]])
// CHECK:         %[[VAL_1499:.*]] = fcmp olt float %[[VAL_1498]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1500:.*]] = fcmp uge float %[[VAL_1496]], -9.000000e+00
// CHECK:         %[[VAL_1501:.*]] = select i1 %[[VAL_1500]], float %[[VAL_1496]], float -9.000000e+00
// CHECK:         %[[VAL_1502:.*]] = fcmp ule float %[[VAL_1501]], 9.000000e+00
// CHECK:         %[[VAL_1503:.*]] = select i1 %[[VAL_1502]], float %[[VAL_1501]], float 9.000000e+00
// CHECK:         %[[VAL_1504:.*]] = fmul float %[[VAL_1503]], %[[VAL_1503]]
// CHECK:         %[[VAL_1505:.*]] = fmul float %[[VAL_1504]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1506:.*]] = fadd float %[[VAL_1505]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1507:.*]] = fmul float %[[VAL_1504]], %[[VAL_1506]]
// CHECK:         %[[VAL_1508:.*]] = fadd float %[[VAL_1507]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1509:.*]] = fmul float %[[VAL_1504]], %[[VAL_1508]]
// CHECK:         %[[VAL_1510:.*]] = fadd float %[[VAL_1509]], 0x3E6B800820000000
// CHECK:         %[[VAL_1511:.*]] = fmul float %[[VAL_1504]], %[[VAL_1510]]
// CHECK:         %[[VAL_1512:.*]] = fadd float %[[VAL_1511]], 0x3EEF286940000000
// CHECK:         %[[VAL_1513:.*]] = fmul float %[[VAL_1504]], %[[VAL_1512]]
// CHECK:         %[[VAL_1514:.*]] = fadd float %[[VAL_1513]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1515:.*]] = fmul float %[[VAL_1504]], %[[VAL_1514]]
// CHECK:         %[[VAL_1516:.*]] = fadd float %[[VAL_1515]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1517:.*]] = fmul float %[[VAL_1503]], %[[VAL_1516]]
// CHECK:         %[[VAL_1518:.*]] = fmul float %[[VAL_1504]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1519:.*]] = fadd float %[[VAL_1518]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1520:.*]] = fmul float %[[VAL_1504]], %[[VAL_1519]]
// CHECK:         %[[VAL_1521:.*]] = fadd float %[[VAL_1520]], 0x3F629540A0000000
// CHECK:         %[[VAL_1522:.*]] = fmul float %[[VAL_1504]], %[[VAL_1521]]
// CHECK:         %[[VAL_1523:.*]] = fadd float %[[VAL_1522]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1524:.*]] = fdiv float %[[VAL_1517]], %[[VAL_1523]]
// CHECK:         %[[VAL_1525:.*]] = select i1 %[[VAL_1499]], float %[[VAL_1496]], float %[[VAL_1524]]
// CHECK:         %[[VAL_1526:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1496]])
// CHECK:         %[[VAL_1527:.*]] = fcmp ult float %[[VAL_1497]], 2.000000e+01
// CHECK:         %[[VAL_1528:.*]] = select i1 %[[VAL_1527]], float %[[VAL_1525]], float %[[VAL_1526]]
// CHECK:         %[[VAL_1529:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1357]] to float*
// CHECK:         %[[VAL_1530:.*]] = getelementptr inbounds float, float* %[[VAL_1529]], i32 %[[VAL_1375]]
// CHECK:         store float %[[VAL_1528]], float* %[[VAL_1530]], align 4
// CHECK:         br label %[[VAL_1381]]
// CHECK:       entry:
// CHECK:         %[[VAL_1531:.*]] = getelementptr inbounds i8, i8* %[[VAL_1532:.*]], i64 0
// CHECK:         %[[VAL_1533:.*]] = bitcast i8* %[[VAL_1531]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1534:.*]] = getelementptr inbounds i8, i8* %[[VAL_1535:.*]], i64 0
// CHECK:         %[[VAL_1536:.*]] = bitcast i8* %[[VAL_1534]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1537:.*]] = getelementptr inbounds i8, i8* %[[VAL_1538:.*]], i64 0
// CHECK:         %[[VAL_1539:.*]] = bitcast i8* %[[VAL_1537]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1540:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1541:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1542:.*]] = mul nuw nsw i32 %[[VAL_1540]], 256
// CHECK:         %[[VAL_1543:.*]] = add nuw nsw i32 %[[VAL_1542]], %[[VAL_1541]]
// CHECK:         %[[VAL_1544:.*]] = icmp ult i32 %[[VAL_1543]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1544]])
// CHECK:         %[[VAL_1545:.*]] = mul nuw nsw i32 %[[VAL_1543]], 4
// CHECK:         %[[VAL_1546:.*]] = udiv i32 %[[VAL_1545]], 1
// CHECK:         %[[VAL_1547:.*]] = urem i32 %[[VAL_1546]], 200
// CHECK:         %[[VAL_1548:.*]] = udiv i32 %[[VAL_1545]], 200
// CHECK:         %[[VAL_1549:.*]] = add nuw nsw i32 %[[VAL_1545]], 1
// CHECK:         %[[VAL_1550:.*]] = udiv i32 %[[VAL_1549]], 1
// CHECK:         %[[VAL_1551:.*]] = urem i32 %[[VAL_1550]], 200
// CHECK:         %[[VAL_1552:.*]] = udiv i32 %[[VAL_1549]], 200
// CHECK:         %[[VAL_1553:.*]] = add nuw nsw i32 %[[VAL_1545]], 2
// CHECK:         %[[VAL_1554:.*]] = udiv i32 %[[VAL_1553]], 1
// CHECK:         %[[VAL_1555:.*]] = urem i32 %[[VAL_1554]], 200
// CHECK:         %[[VAL_1556:.*]] = udiv i32 %[[VAL_1553]], 200
// CHECK:         %[[VAL_1557:.*]] = add nuw nsw i32 %[[VAL_1545]], 3
// CHECK:         %[[VAL_1558:.*]] = udiv i32 %[[VAL_1557]], 1
// CHECK:         %[[VAL_1559:.*]] = urem i32 %[[VAL_1558]], 200
// CHECK:         %[[VAL_1560:.*]] = udiv i32 %[[VAL_1557]], 200
// CHECK:         %[[VAL_1561:.*]] = icmp ult i32 %[[VAL_1545]], 20000
// CHECK:         br i1 %[[VAL_1561]], label %[[VAL_1562:.*]], label %[[VAL_1563:.*]]
// CHECK:       r27.in_bounds-after:                              ; preds = %[[VAL_1562]], %[[VAL_1564:.*]]
// CHECK:         ret void
// CHECK:       r27.in_bounds-true:                               ; preds = %[[VAL_1564]]
// CHECK:         %[[VAL_1565:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1533]] to float*
// CHECK:         %[[VAL_1566:.*]] = getelementptr inbounds float, float* %[[VAL_1565]], i32 %[[VAL_1545]]
// CHECK:         %[[VAL_1567:.*]] = load float, float* %[[VAL_1566]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1568:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1536]] to float*
// CHECK:         %[[VAL_1569:.*]] = getelementptr inbounds float, float* %[[VAL_1568]], i32 %[[VAL_1545]]
// CHECK:         %[[VAL_1570:.*]] = load float, float* %[[VAL_1569]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1571:.*]] = fadd float %[[VAL_1567]], %[[VAL_1570]]
// CHECK:         %[[VAL_1572:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1539]] to float*
// CHECK:         %[[VAL_1573:.*]] = getelementptr inbounds float, float* %[[VAL_1572]], i32 %[[VAL_1545]]
// CHECK:         store float %[[VAL_1571]], float* %[[VAL_1573]], align 4
// CHECK:         %[[VAL_1574:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1533]] to float*
// CHECK:         %[[VAL_1575:.*]] = getelementptr inbounds float, float* %[[VAL_1574]], i32 %[[VAL_1549]]
// CHECK:         %[[VAL_1576:.*]] = load float, float* %[[VAL_1575]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1577:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1536]] to float*
// CHECK:         %[[VAL_1578:.*]] = getelementptr inbounds float, float* %[[VAL_1577]], i32 %[[VAL_1549]]
// CHECK:         %[[VAL_1579:.*]] = load float, float* %[[VAL_1578]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1580:.*]] = fadd float %[[VAL_1576]], %[[VAL_1579]]
// CHECK:         %[[VAL_1581:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1539]] to float*
// CHECK:         %[[VAL_1582:.*]] = getelementptr inbounds float, float* %[[VAL_1581]], i32 %[[VAL_1549]]
// CHECK:         store float %[[VAL_1580]], float* %[[VAL_1582]], align 4
// CHECK:         %[[VAL_1583:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1533]] to float*
// CHECK:         %[[VAL_1584:.*]] = getelementptr inbounds float, float* %[[VAL_1583]], i32 %[[VAL_1553]]
// CHECK:         %[[VAL_1585:.*]] = load float, float* %[[VAL_1584]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1586:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1536]] to float*
// CHECK:         %[[VAL_1587:.*]] = getelementptr inbounds float, float* %[[VAL_1586]], i32 %[[VAL_1553]]
// CHECK:         %[[VAL_1588:.*]] = load float, float* %[[VAL_1587]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1589:.*]] = fadd float %[[VAL_1585]], %[[VAL_1588]]
// CHECK:         %[[VAL_1590:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1539]] to float*
// CHECK:         %[[VAL_1591:.*]] = getelementptr inbounds float, float* %[[VAL_1590]], i32 %[[VAL_1553]]
// CHECK:         store float %[[VAL_1589]], float* %[[VAL_1591]], align 4
// CHECK:         %[[VAL_1592:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1533]] to float*
// CHECK:         %[[VAL_1593:.*]] = getelementptr inbounds float, float* %[[VAL_1592]], i32 %[[VAL_1557]]
// CHECK:         %[[VAL_1594:.*]] = load float, float* %[[VAL_1593]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1595:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1536]] to float*
// CHECK:         %[[VAL_1596:.*]] = getelementptr inbounds float, float* %[[VAL_1595]], i32 %[[VAL_1557]]
// CHECK:         %[[VAL_1597:.*]] = load float, float* %[[VAL_1596]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1598:.*]] = fadd float %[[VAL_1594]], %[[VAL_1597]]
// CHECK:         %[[VAL_1599:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1539]] to float*
// CHECK:         %[[VAL_1600:.*]] = getelementptr inbounds float, float* %[[VAL_1599]], i32 %[[VAL_1557]]
// CHECK:         store float %[[VAL_1598]], float* %[[VAL_1600]], align 4
// CHECK:         br label %[[VAL_1563]]
// CHECK:       entry:
// CHECK:         %[[VAL_1601:.*]] = getelementptr inbounds i8, i8* %[[VAL_1602:.*]], i64 0
// CHECK:         %[[VAL_1603:.*]] = bitcast i8* %[[VAL_1601]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1604:.*]] = getelementptr inbounds i8, i8* %[[VAL_1605:.*]], i64 0
// CHECK:         %[[VAL_1606:.*]] = bitcast i8* %[[VAL_1604]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1607:.*]] = getelementptr inbounds i8, i8* %[[VAL_1608:.*]], i64 0
// CHECK:         %[[VAL_1609:.*]] = bitcast i8* %[[VAL_1607]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1610:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1611:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_1612:.*]] = mul nuw nsw i32 %[[VAL_1610]], 1024
// CHECK:         %[[VAL_1613:.*]] = add nuw nsw i32 %[[VAL_1612]], %[[VAL_1611]]
// CHECK:         %[[VAL_1614:.*]] = icmp ult i32 %[[VAL_1613]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_1614]])
// CHECK:         %[[VAL_1615:.*]] = udiv i32 %[[VAL_1613]], 1
// CHECK:         %[[VAL_1616:.*]] = urem i32 %[[VAL_1615]], 200
// CHECK:         %[[VAL_1617:.*]] = udiv i32 %[[VAL_1613]], 200
// CHECK:         %[[VAL_1618:.*]] = icmp ult i32 %[[VAL_1613]], 20000
// CHECK:         br i1 %[[VAL_1618]], label %[[VAL_1619:.*]], label %[[VAL_1620:.*]]
// CHECK:       r28.in_bounds-after:                              ; preds = %[[VAL_1619]], %[[VAL_1621:.*]]
// CHECK:         ret void
// CHECK:       r28.in_bounds-true:                               ; preds = %[[VAL_1621]]
// CHECK:         %[[VAL_1622:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1603]] to float*
// CHECK:         %[[VAL_1623:.*]] = getelementptr inbounds float, float* %[[VAL_1622]], i32 %[[VAL_1613]]
// CHECK:         %[[VAL_1624:.*]] = load float, float* %[[VAL_1623]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1625:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1606]] to float*
// CHECK:         %[[VAL_1626:.*]] = getelementptr inbounds float, float* %[[VAL_1625]], i32 %[[VAL_1613]]
// CHECK:         %[[VAL_1627:.*]] = load float, float* %[[VAL_1626]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1628:.*]] = call float @__nv_atan2f(float %[[VAL_1624]], float %[[VAL_1627]])
// CHECK:         %[[VAL_1629:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1609]] to float*
// CHECK:         %[[VAL_1630:.*]] = getelementptr inbounds float, float* %[[VAL_1629]], i32 %[[VAL_1613]]
// CHECK:         store float %[[VAL_1628]], float* %[[VAL_1630]], align 4
// CHECK:         br label %[[VAL_1620]]
// CHECK:       entry:
// CHECK:         %[[VAL_1631:.*]] = getelementptr inbounds i8, i8* %[[VAL_1632:.*]], i64 0
// CHECK:         %[[VAL_1633:.*]] = bitcast i8* %[[VAL_1631]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1634:.*]] = getelementptr inbounds i8, i8* %[[VAL_1635:.*]], i64 0
// CHECK:         %[[VAL_1636:.*]] = bitcast i8* %[[VAL_1634]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1637:.*]] = getelementptr inbounds i8, i8* %[[VAL_1638:.*]], i64 0
// CHECK:         %[[VAL_1639:.*]] = bitcast i8* %[[VAL_1637]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_1640:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1641:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1642:.*]] = mul nuw nsw i32 %[[VAL_1640]], 256
// CHECK:         %[[VAL_1643:.*]] = add nuw nsw i32 %[[VAL_1642]], %[[VAL_1641]]
// CHECK:         %[[VAL_1644:.*]] = icmp ult i32 %[[VAL_1643]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1644]])
// CHECK:         %[[VAL_1645:.*]] = mul nuw nsw i32 %[[VAL_1643]], 4
// CHECK:         %[[VAL_1646:.*]] = udiv i32 %[[VAL_1645]], 1
// CHECK:         %[[VAL_1647:.*]] = urem i32 %[[VAL_1646]], 200
// CHECK:         %[[VAL_1648:.*]] = udiv i32 %[[VAL_1645]], 200
// CHECK:         %[[VAL_1649:.*]] = add nuw nsw i32 %[[VAL_1645]], 1
// CHECK:         %[[VAL_1650:.*]] = udiv i32 %[[VAL_1649]], 1
// CHECK:         %[[VAL_1651:.*]] = urem i32 %[[VAL_1650]], 200
// CHECK:         %[[VAL_1652:.*]] = udiv i32 %[[VAL_1649]], 200
// CHECK:         %[[VAL_1653:.*]] = add nuw nsw i32 %[[VAL_1645]], 2
// CHECK:         %[[VAL_1654:.*]] = udiv i32 %[[VAL_1653]], 1
// CHECK:         %[[VAL_1655:.*]] = urem i32 %[[VAL_1654]], 200
// CHECK:         %[[VAL_1656:.*]] = udiv i32 %[[VAL_1653]], 200
// CHECK:         %[[VAL_1657:.*]] = add nuw nsw i32 %[[VAL_1645]], 3
// CHECK:         %[[VAL_1658:.*]] = udiv i32 %[[VAL_1657]], 1
// CHECK:         %[[VAL_1659:.*]] = urem i32 %[[VAL_1658]], 200
// CHECK:         %[[VAL_1660:.*]] = udiv i32 %[[VAL_1657]], 200
// CHECK:         %[[VAL_1661:.*]] = icmp ult i32 %[[VAL_1645]], 20000
// CHECK:         br i1 %[[VAL_1661]], label %[[VAL_1662:.*]], label %[[VAL_1663:.*]]
// CHECK:       r29.in_bounds-after:                              ; preds = %[[VAL_1662]], %[[VAL_1664:.*]]
// CHECK:         ret void
// CHECK:       r29.in_bounds-true:                               ; preds = %[[VAL_1664]]
// CHECK:         %[[VAL_1665:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1633]] to float*
// CHECK:         %[[VAL_1666:.*]] = getelementptr inbounds float, float* %[[VAL_1665]], i32 %[[VAL_1645]]
// CHECK:         %[[VAL_1667:.*]] = load float, float* %[[VAL_1666]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1668:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1636]] to float*
// CHECK:         %[[VAL_1669:.*]] = getelementptr inbounds float, float* %[[VAL_1668]], i32 %[[VAL_1645]]
// CHECK:         %[[VAL_1670:.*]] = load float, float* %[[VAL_1669]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1671:.*]] = fcmp oeq float %[[VAL_1667]], %[[VAL_1670]]
// CHECK:         %[[VAL_1672:.*]] = zext i1 %[[VAL_1671]] to i8
// CHECK:         %[[VAL_1673:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1639]] to i8*
// CHECK:         %[[VAL_1674:.*]] = getelementptr inbounds i8, i8* %[[VAL_1673]], i32 %[[VAL_1645]]
// CHECK:         store i8 %[[VAL_1672]], i8* %[[VAL_1674]], align 1
// CHECK:         %[[VAL_1675:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1633]] to float*
// CHECK:         %[[VAL_1676:.*]] = getelementptr inbounds float, float* %[[VAL_1675]], i32 %[[VAL_1649]]
// CHECK:         %[[VAL_1677:.*]] = load float, float* %[[VAL_1676]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1678:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1636]] to float*
// CHECK:         %[[VAL_1679:.*]] = getelementptr inbounds float, float* %[[VAL_1678]], i32 %[[VAL_1649]]
// CHECK:         %[[VAL_1680:.*]] = load float, float* %[[VAL_1679]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1681:.*]] = fcmp oeq float %[[VAL_1677]], %[[VAL_1680]]
// CHECK:         %[[VAL_1682:.*]] = zext i1 %[[VAL_1681]] to i8
// CHECK:         %[[VAL_1683:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1639]] to i8*
// CHECK:         %[[VAL_1684:.*]] = getelementptr inbounds i8, i8* %[[VAL_1683]], i32 %[[VAL_1649]]
// CHECK:         store i8 %[[VAL_1682]], i8* %[[VAL_1684]], align 1
// CHECK:         %[[VAL_1685:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1633]] to float*
// CHECK:         %[[VAL_1686:.*]] = getelementptr inbounds float, float* %[[VAL_1685]], i32 %[[VAL_1653]]
// CHECK:         %[[VAL_1687:.*]] = load float, float* %[[VAL_1686]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1688:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1636]] to float*
// CHECK:         %[[VAL_1689:.*]] = getelementptr inbounds float, float* %[[VAL_1688]], i32 %[[VAL_1653]]
// CHECK:         %[[VAL_1690:.*]] = load float, float* %[[VAL_1689]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1691:.*]] = fcmp oeq float %[[VAL_1687]], %[[VAL_1690]]
// CHECK:         %[[VAL_1692:.*]] = zext i1 %[[VAL_1691]] to i8
// CHECK:         %[[VAL_1693:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1639]] to i8*
// CHECK:         %[[VAL_1694:.*]] = getelementptr inbounds i8, i8* %[[VAL_1693]], i32 %[[VAL_1653]]
// CHECK:         store i8 %[[VAL_1692]], i8* %[[VAL_1694]], align 1
// CHECK:         %[[VAL_1695:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1633]] to float*
// CHECK:         %[[VAL_1696:.*]] = getelementptr inbounds float, float* %[[VAL_1695]], i32 %[[VAL_1657]]
// CHECK:         %[[VAL_1697:.*]] = load float, float* %[[VAL_1696]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1698:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1636]] to float*
// CHECK:         %[[VAL_1699:.*]] = getelementptr inbounds float, float* %[[VAL_1698]], i32 %[[VAL_1657]]
// CHECK:         %[[VAL_1700:.*]] = load float, float* %[[VAL_1699]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1701:.*]] = fcmp oeq float %[[VAL_1697]], %[[VAL_1700]]
// CHECK:         %[[VAL_1702:.*]] = zext i1 %[[VAL_1701]] to i8
// CHECK:         %[[VAL_1703:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1639]] to i8*
// CHECK:         %[[VAL_1704:.*]] = getelementptr inbounds i8, i8* %[[VAL_1703]], i32 %[[VAL_1657]]
// CHECK:         store i8 %[[VAL_1702]], i8* %[[VAL_1704]], align 1
// CHECK:         br label %[[VAL_1663]]
// CHECK:       entry:
// CHECK:         %[[VAL_1705:.*]] = getelementptr inbounds i8, i8* %[[VAL_1706:.*]], i64 0
// CHECK:         %[[VAL_1707:.*]] = bitcast i8* %[[VAL_1705]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1708:.*]] = getelementptr inbounds i8, i8* %[[VAL_1709:.*]], i64 0
// CHECK:         %[[VAL_1710:.*]] = bitcast i8* %[[VAL_1708]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1711:.*]] = getelementptr inbounds i8, i8* %[[VAL_1712:.*]], i64 0
// CHECK:         %[[VAL_1713:.*]] = bitcast i8* %[[VAL_1711]] to [100 x [200 x %[[VAL_1714:.*]]]]*
// CHECK:         %[[VAL_1715:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1716:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1717:.*]] = mul nuw nsw i32 %[[VAL_1715]], 256
// CHECK:         %[[VAL_1718:.*]] = add nuw nsw i32 %[[VAL_1717]], %[[VAL_1716]]
// CHECK:         %[[VAL_1719:.*]] = icmp ult i32 %[[VAL_1718]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1719]])
// CHECK:         %[[VAL_1720:.*]] = mul nuw nsw i32 %[[VAL_1718]], 4
// CHECK:         %[[VAL_1721:.*]] = udiv i32 %[[VAL_1720]], 1
// CHECK:         %[[VAL_1722:.*]] = urem i32 %[[VAL_1721]], 200
// CHECK:         %[[VAL_1723:.*]] = udiv i32 %[[VAL_1720]], 200
// CHECK:         %[[VAL_1724:.*]] = add nuw nsw i32 %[[VAL_1720]], 1
// CHECK:         %[[VAL_1725:.*]] = udiv i32 %[[VAL_1724]], 1
// CHECK:         %[[VAL_1726:.*]] = urem i32 %[[VAL_1725]], 200
// CHECK:         %[[VAL_1727:.*]] = udiv i32 %[[VAL_1724]], 200
// CHECK:         %[[VAL_1728:.*]] = add nuw nsw i32 %[[VAL_1720]], 2
// CHECK:         %[[VAL_1729:.*]] = udiv i32 %[[VAL_1728]], 1
// CHECK:         %[[VAL_1730:.*]] = urem i32 %[[VAL_1729]], 200
// CHECK:         %[[VAL_1731:.*]] = udiv i32 %[[VAL_1728]], 200
// CHECK:         %[[VAL_1732:.*]] = add nuw nsw i32 %[[VAL_1720]], 3
// CHECK:         %[[VAL_1733:.*]] = udiv i32 %[[VAL_1732]], 1
// CHECK:         %[[VAL_1734:.*]] = urem i32 %[[VAL_1733]], 200
// CHECK:         %[[VAL_1735:.*]] = udiv i32 %[[VAL_1732]], 200
// CHECK:         %[[VAL_1736:.*]] = icmp ult i32 %[[VAL_1720]], 20000
// CHECK:         br i1 %[[VAL_1736]], label %[[VAL_1737:.*]], label %[[VAL_1738:.*]]
// CHECK:       r30.in_bounds-after:                              ; preds = %[[VAL_1737]], %[[VAL_1739:.*]]
// CHECK:         ret void
// CHECK:       r30.in_bounds-true:                               ; preds = %[[VAL_1739]]
// CHECK:         %[[VAL_1740:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1707]] to float*
// CHECK:         %[[VAL_1741:.*]] = getelementptr inbounds float, float* %[[VAL_1740]], i32 %[[VAL_1720]]
// CHECK:         %[[VAL_1742:.*]] = load float, float* %[[VAL_1741]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1743:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1710]] to float*
// CHECK:         %[[VAL_1744:.*]] = getelementptr inbounds float, float* %[[VAL_1743]], i32 %[[VAL_1720]]
// CHECK:         %[[VAL_1745:.*]] = load float, float* %[[VAL_1744]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1746:.*]] = insertvalue %[[VAL_1714]] zeroinitializer, float %[[VAL_1742]], 0
// CHECK:         %[[VAL_1747:.*]] = insertvalue %[[VAL_1714]] %[[VAL_1746]], float %[[VAL_1745]], 1
// CHECK:         %[[VAL_1748:.*]] = bitcast [100 x [200 x %[[VAL_1714]]]]* %[[VAL_1713]] to %[[VAL_1714]]*
// CHECK:         %[[VAL_1749:.*]] = getelementptr inbounds %[[VAL_1714]], %[[VAL_1714]]* %[[VAL_1748]], i32 %[[VAL_1720]]
// CHECK:         store %[[VAL_1714]] %[[VAL_1747]], %[[VAL_1714]]* %[[VAL_1749]], align 1
// CHECK:         %[[VAL_1750:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1707]] to float*
// CHECK:         %[[VAL_1751:.*]] = getelementptr inbounds float, float* %[[VAL_1750]], i32 %[[VAL_1724]]
// CHECK:         %[[VAL_1752:.*]] = load float, float* %[[VAL_1751]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1753:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1710]] to float*
// CHECK:         %[[VAL_1754:.*]] = getelementptr inbounds float, float* %[[VAL_1753]], i32 %[[VAL_1724]]
// CHECK:         %[[VAL_1755:.*]] = load float, float* %[[VAL_1754]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1756:.*]] = insertvalue %[[VAL_1714]] zeroinitializer, float %[[VAL_1752]], 0
// CHECK:         %[[VAL_1757:.*]] = insertvalue %[[VAL_1714]] %[[VAL_1756]], float %[[VAL_1755]], 1
// CHECK:         %[[VAL_1758:.*]] = bitcast [100 x [200 x %[[VAL_1714]]]]* %[[VAL_1713]] to %[[VAL_1714]]*
// CHECK:         %[[VAL_1759:.*]] = getelementptr inbounds %[[VAL_1714]], %[[VAL_1714]]* %[[VAL_1758]], i32 %[[VAL_1724]]
// CHECK:         store %[[VAL_1714]] %[[VAL_1757]], %[[VAL_1714]]* %[[VAL_1759]], align 1
// CHECK:         %[[VAL_1760:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1707]] to float*
// CHECK:         %[[VAL_1761:.*]] = getelementptr inbounds float, float* %[[VAL_1760]], i32 %[[VAL_1728]]
// CHECK:         %[[VAL_1762:.*]] = load float, float* %[[VAL_1761]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1763:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1710]] to float*
// CHECK:         %[[VAL_1764:.*]] = getelementptr inbounds float, float* %[[VAL_1763]], i32 %[[VAL_1728]]
// CHECK:         %[[VAL_1765:.*]] = load float, float* %[[VAL_1764]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1766:.*]] = insertvalue %[[VAL_1714]] zeroinitializer, float %[[VAL_1762]], 0
// CHECK:         %[[VAL_1767:.*]] = insertvalue %[[VAL_1714]] %[[VAL_1766]], float %[[VAL_1765]], 1
// CHECK:         %[[VAL_1768:.*]] = bitcast [100 x [200 x %[[VAL_1714]]]]* %[[VAL_1713]] to %[[VAL_1714]]*
// CHECK:         %[[VAL_1769:.*]] = getelementptr inbounds %[[VAL_1714]], %[[VAL_1714]]* %[[VAL_1768]], i32 %[[VAL_1728]]
// CHECK:         store %[[VAL_1714]] %[[VAL_1767]], %[[VAL_1714]]* %[[VAL_1769]], align 1
// CHECK:         %[[VAL_1770:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1707]] to float*
// CHECK:         %[[VAL_1771:.*]] = getelementptr inbounds float, float* %[[VAL_1770]], i32 %[[VAL_1732]]
// CHECK:         %[[VAL_1772:.*]] = load float, float* %[[VAL_1771]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1773:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1710]] to float*
// CHECK:         %[[VAL_1774:.*]] = getelementptr inbounds float, float* %[[VAL_1773]], i32 %[[VAL_1732]]
// CHECK:         %[[VAL_1775:.*]] = load float, float* %[[VAL_1774]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1776:.*]] = insertvalue %[[VAL_1714]] zeroinitializer, float %[[VAL_1772]], 0
// CHECK:         %[[VAL_1777:.*]] = insertvalue %[[VAL_1714]] %[[VAL_1776]], float %[[VAL_1775]], 1
// CHECK:         %[[VAL_1778:.*]] = bitcast [100 x [200 x %[[VAL_1714]]]]* %[[VAL_1713]] to %[[VAL_1714]]*
// CHECK:         %[[VAL_1779:.*]] = getelementptr inbounds %[[VAL_1714]], %[[VAL_1714]]* %[[VAL_1778]], i32 %[[VAL_1732]]
// CHECK:         store %[[VAL_1714]] %[[VAL_1777]], %[[VAL_1714]]* %[[VAL_1779]], align 1
// CHECK:         br label %[[VAL_1738]]
// CHECK:       entry:
// CHECK:         %[[VAL_1780:.*]] = getelementptr inbounds i8, i8* %[[VAL_1781:.*]], i64 0
// CHECK:         %[[VAL_1782:.*]] = bitcast i8* %[[VAL_1780]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1783:.*]] = getelementptr inbounds i8, i8* %[[VAL_1784:.*]], i64 0
// CHECK:         %[[VAL_1785:.*]] = bitcast i8* %[[VAL_1783]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1786:.*]] = getelementptr inbounds i8, i8* %[[VAL_1787:.*]], i64 0
// CHECK:         %[[VAL_1788:.*]] = bitcast i8* %[[VAL_1786]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1789:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1790:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1791:.*]] = mul nuw nsw i32 %[[VAL_1789]], 256
// CHECK:         %[[VAL_1792:.*]] = add nuw nsw i32 %[[VAL_1791]], %[[VAL_1790]]
// CHECK:         %[[VAL_1793:.*]] = icmp ult i32 %[[VAL_1792]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1793]])
// CHECK:         %[[VAL_1794:.*]] = mul nuw nsw i32 %[[VAL_1792]], 4
// CHECK:         %[[VAL_1795:.*]] = udiv i32 %[[VAL_1794]], 1
// CHECK:         %[[VAL_1796:.*]] = urem i32 %[[VAL_1795]], 200
// CHECK:         %[[VAL_1797:.*]] = udiv i32 %[[VAL_1794]], 200
// CHECK:         %[[VAL_1798:.*]] = add nuw nsw i32 %[[VAL_1794]], 1
// CHECK:         %[[VAL_1799:.*]] = udiv i32 %[[VAL_1798]], 1
// CHECK:         %[[VAL_1800:.*]] = urem i32 %[[VAL_1799]], 200
// CHECK:         %[[VAL_1801:.*]] = udiv i32 %[[VAL_1798]], 200
// CHECK:         %[[VAL_1802:.*]] = add nuw nsw i32 %[[VAL_1794]], 2
// CHECK:         %[[VAL_1803:.*]] = udiv i32 %[[VAL_1802]], 1
// CHECK:         %[[VAL_1804:.*]] = urem i32 %[[VAL_1803]], 200
// CHECK:         %[[VAL_1805:.*]] = udiv i32 %[[VAL_1802]], 200
// CHECK:         %[[VAL_1806:.*]] = add nuw nsw i32 %[[VAL_1794]], 3
// CHECK:         %[[VAL_1807:.*]] = udiv i32 %[[VAL_1806]], 1
// CHECK:         %[[VAL_1808:.*]] = urem i32 %[[VAL_1807]], 200
// CHECK:         %[[VAL_1809:.*]] = udiv i32 %[[VAL_1806]], 200
// CHECK:         %[[VAL_1810:.*]] = icmp ult i32 %[[VAL_1794]], 20000
// CHECK:         br i1 %[[VAL_1810]], label %[[VAL_1811:.*]], label %[[VAL_1812:.*]]
// CHECK:       r31.in_bounds-after:                              ; preds = %[[VAL_1811]], %[[VAL_1813:.*]]
// CHECK:         ret void
// CHECK:       r31.in_bounds-true:                               ; preds = %[[VAL_1813]]
// CHECK:         %[[VAL_1814:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1782]] to float*
// CHECK:         %[[VAL_1815:.*]] = getelementptr inbounds float, float* %[[VAL_1814]], i32 %[[VAL_1794]]
// CHECK:         %[[VAL_1816:.*]] = load float, float* %[[VAL_1815]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1817:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1785]] to float*
// CHECK:         %[[VAL_1818:.*]] = getelementptr inbounds float, float* %[[VAL_1817]], i32 %[[VAL_1794]]
// CHECK:         %[[VAL_1819:.*]] = load float, float* %[[VAL_1818]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1820:.*]] = fdiv float %[[VAL_1816]], %[[VAL_1819]]
// CHECK:         %[[VAL_1821:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1788]] to float*
// CHECK:         %[[VAL_1822:.*]] = getelementptr inbounds float, float* %[[VAL_1821]], i32 %[[VAL_1794]]
// CHECK:         store float %[[VAL_1820]], float* %[[VAL_1822]], align 4
// CHECK:         %[[VAL_1823:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1782]] to float*
// CHECK:         %[[VAL_1824:.*]] = getelementptr inbounds float, float* %[[VAL_1823]], i32 %[[VAL_1798]]
// CHECK:         %[[VAL_1825:.*]] = load float, float* %[[VAL_1824]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1826:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1785]] to float*
// CHECK:         %[[VAL_1827:.*]] = getelementptr inbounds float, float* %[[VAL_1826]], i32 %[[VAL_1798]]
// CHECK:         %[[VAL_1828:.*]] = load float, float* %[[VAL_1827]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1829:.*]] = fdiv float %[[VAL_1825]], %[[VAL_1828]]
// CHECK:         %[[VAL_1830:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1788]] to float*
// CHECK:         %[[VAL_1831:.*]] = getelementptr inbounds float, float* %[[VAL_1830]], i32 %[[VAL_1798]]
// CHECK:         store float %[[VAL_1829]], float* %[[VAL_1831]], align 4
// CHECK:         %[[VAL_1832:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1782]] to float*
// CHECK:         %[[VAL_1833:.*]] = getelementptr inbounds float, float* %[[VAL_1832]], i32 %[[VAL_1802]]
// CHECK:         %[[VAL_1834:.*]] = load float, float* %[[VAL_1833]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1835:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1785]] to float*
// CHECK:         %[[VAL_1836:.*]] = getelementptr inbounds float, float* %[[VAL_1835]], i32 %[[VAL_1802]]
// CHECK:         %[[VAL_1837:.*]] = load float, float* %[[VAL_1836]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1838:.*]] = fdiv float %[[VAL_1834]], %[[VAL_1837]]
// CHECK:         %[[VAL_1839:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1788]] to float*
// CHECK:         %[[VAL_1840:.*]] = getelementptr inbounds float, float* %[[VAL_1839]], i32 %[[VAL_1802]]
// CHECK:         store float %[[VAL_1838]], float* %[[VAL_1840]], align 4
// CHECK:         %[[VAL_1841:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1782]] to float*
// CHECK:         %[[VAL_1842:.*]] = getelementptr inbounds float, float* %[[VAL_1841]], i32 %[[VAL_1806]]
// CHECK:         %[[VAL_1843:.*]] = load float, float* %[[VAL_1842]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1844:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1785]] to float*
// CHECK:         %[[VAL_1845:.*]] = getelementptr inbounds float, float* %[[VAL_1844]], i32 %[[VAL_1806]]
// CHECK:         %[[VAL_1846:.*]] = load float, float* %[[VAL_1845]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1847:.*]] = fdiv float %[[VAL_1843]], %[[VAL_1846]]
// CHECK:         %[[VAL_1848:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1788]] to float*
// CHECK:         %[[VAL_1849:.*]] = getelementptr inbounds float, float* %[[VAL_1848]], i32 %[[VAL_1806]]
// CHECK:         store float %[[VAL_1847]], float* %[[VAL_1849]], align 4
// CHECK:         br label %[[VAL_1812]]
// CHECK:       entry:
// CHECK:         %[[VAL_1850:.*]] = getelementptr inbounds i8, i8* %[[VAL_1851:.*]], i64 0
// CHECK:         %[[VAL_1852:.*]] = bitcast i8* %[[VAL_1850]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1853:.*]] = getelementptr inbounds i8, i8* %[[VAL_1854:.*]], i64 0
// CHECK:         %[[VAL_1855:.*]] = bitcast i8* %[[VAL_1853]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1856:.*]] = getelementptr inbounds i8, i8* %[[VAL_1857:.*]], i64 0
// CHECK:         %[[VAL_1858:.*]] = bitcast i8* %[[VAL_1856]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1859:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1860:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1861:.*]] = mul nuw nsw i32 %[[VAL_1859]], 256
// CHECK:         %[[VAL_1862:.*]] = add nuw nsw i32 %[[VAL_1861]], %[[VAL_1860]]
// CHECK:         %[[VAL_1863:.*]] = icmp ult i32 %[[VAL_1862]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1863]])
// CHECK:         %[[VAL_1864:.*]] = mul nuw nsw i32 %[[VAL_1862]], 4
// CHECK:         %[[VAL_1865:.*]] = udiv i32 %[[VAL_1864]], 1
// CHECK:         %[[VAL_1866:.*]] = urem i32 %[[VAL_1865]], 200
// CHECK:         %[[VAL_1867:.*]] = udiv i32 %[[VAL_1864]], 200
// CHECK:         %[[VAL_1868:.*]] = add nuw nsw i32 %[[VAL_1864]], 1
// CHECK:         %[[VAL_1869:.*]] = udiv i32 %[[VAL_1868]], 1
// CHECK:         %[[VAL_1870:.*]] = urem i32 %[[VAL_1869]], 200
// CHECK:         %[[VAL_1871:.*]] = udiv i32 %[[VAL_1868]], 200
// CHECK:         %[[VAL_1872:.*]] = add nuw nsw i32 %[[VAL_1864]], 2
// CHECK:         %[[VAL_1873:.*]] = udiv i32 %[[VAL_1872]], 1
// CHECK:         %[[VAL_1874:.*]] = urem i32 %[[VAL_1873]], 200
// CHECK:         %[[VAL_1875:.*]] = udiv i32 %[[VAL_1872]], 200
// CHECK:         %[[VAL_1876:.*]] = add nuw nsw i32 %[[VAL_1864]], 3
// CHECK:         %[[VAL_1877:.*]] = udiv i32 %[[VAL_1876]], 1
// CHECK:         %[[VAL_1878:.*]] = urem i32 %[[VAL_1877]], 200
// CHECK:         %[[VAL_1879:.*]] = udiv i32 %[[VAL_1876]], 200
// CHECK:         %[[VAL_1880:.*]] = icmp ult i32 %[[VAL_1864]], 20000
// CHECK:         br i1 %[[VAL_1880]], label %[[VAL_1881:.*]], label %[[VAL_1882:.*]]
// CHECK:       r32.in_bounds-after:                              ; preds = %[[VAL_1881]], %[[VAL_1883:.*]]
// CHECK:         ret void
// CHECK:       r32.in_bounds-true:                               ; preds = %[[VAL_1883]]
// CHECK:         %[[VAL_1884:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1852]] to float*
// CHECK:         %[[VAL_1885:.*]] = getelementptr inbounds float, float* %[[VAL_1884]], i32 %[[VAL_1864]]
// CHECK:         %[[VAL_1886:.*]] = load float, float* %[[VAL_1885]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1887:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1855]] to float*
// CHECK:         %[[VAL_1888:.*]] = getelementptr inbounds float, float* %[[VAL_1887]], i32 %[[VAL_1864]]
// CHECK:         %[[VAL_1889:.*]] = load float, float* %[[VAL_1888]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1890:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1886]], float %[[VAL_1889]])
// CHECK:         %[[VAL_1891:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1858]] to float*
// CHECK:         %[[VAL_1892:.*]] = getelementptr inbounds float, float* %[[VAL_1891]], i32 %[[VAL_1864]]
// CHECK:         store float %[[VAL_1890]], float* %[[VAL_1892]], align 4
// CHECK:         %[[VAL_1893:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1852]] to float*
// CHECK:         %[[VAL_1894:.*]] = getelementptr inbounds float, float* %[[VAL_1893]], i32 %[[VAL_1868]]
// CHECK:         %[[VAL_1895:.*]] = load float, float* %[[VAL_1894]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1896:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1855]] to float*
// CHECK:         %[[VAL_1897:.*]] = getelementptr inbounds float, float* %[[VAL_1896]], i32 %[[VAL_1868]]
// CHECK:         %[[VAL_1898:.*]] = load float, float* %[[VAL_1897]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1899:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1895]], float %[[VAL_1898]])
// CHECK:         %[[VAL_1900:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1858]] to float*
// CHECK:         %[[VAL_1901:.*]] = getelementptr inbounds float, float* %[[VAL_1900]], i32 %[[VAL_1868]]
// CHECK:         store float %[[VAL_1899]], float* %[[VAL_1901]], align 4
// CHECK:         %[[VAL_1902:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1852]] to float*
// CHECK:         %[[VAL_1903:.*]] = getelementptr inbounds float, float* %[[VAL_1902]], i32 %[[VAL_1872]]
// CHECK:         %[[VAL_1904:.*]] = load float, float* %[[VAL_1903]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1905:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1855]] to float*
// CHECK:         %[[VAL_1906:.*]] = getelementptr inbounds float, float* %[[VAL_1905]], i32 %[[VAL_1872]]
// CHECK:         %[[VAL_1907:.*]] = load float, float* %[[VAL_1906]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1908:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1904]], float %[[VAL_1907]])
// CHECK:         %[[VAL_1909:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1858]] to float*
// CHECK:         %[[VAL_1910:.*]] = getelementptr inbounds float, float* %[[VAL_1909]], i32 %[[VAL_1872]]
// CHECK:         store float %[[VAL_1908]], float* %[[VAL_1910]], align 4
// CHECK:         %[[VAL_1911:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1852]] to float*
// CHECK:         %[[VAL_1912:.*]] = getelementptr inbounds float, float* %[[VAL_1911]], i32 %[[VAL_1876]]
// CHECK:         %[[VAL_1913:.*]] = load float, float* %[[VAL_1912]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1914:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1855]] to float*
// CHECK:         %[[VAL_1915:.*]] = getelementptr inbounds float, float* %[[VAL_1914]], i32 %[[VAL_1876]]
// CHECK:         %[[VAL_1916:.*]] = load float, float* %[[VAL_1915]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1917:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1913]], float %[[VAL_1916]])
// CHECK:         %[[VAL_1918:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1858]] to float*
// CHECK:         %[[VAL_1919:.*]] = getelementptr inbounds float, float* %[[VAL_1918]], i32 %[[VAL_1876]]
// CHECK:         store float %[[VAL_1917]], float* %[[VAL_1919]], align 4
// CHECK:         br label %[[VAL_1882]]
// CHECK:       entry:
// CHECK:         %[[VAL_1920:.*]] = getelementptr inbounds i8, i8* %[[VAL_1921:.*]], i64 0
// CHECK:         %[[VAL_1922:.*]] = bitcast i8* %[[VAL_1920]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1923:.*]] = getelementptr inbounds i8, i8* %[[VAL_1924:.*]], i64 0
// CHECK:         %[[VAL_1925:.*]] = bitcast i8* %[[VAL_1923]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1926:.*]] = getelementptr inbounds i8, i8* %[[VAL_1927:.*]], i64 0
// CHECK:         %[[VAL_1928:.*]] = bitcast i8* %[[VAL_1926]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1929:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1930:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1931:.*]] = mul nuw nsw i32 %[[VAL_1929]], 256
// CHECK:         %[[VAL_1932:.*]] = add nuw nsw i32 %[[VAL_1931]], %[[VAL_1930]]
// CHECK:         %[[VAL_1933:.*]] = icmp ult i32 %[[VAL_1932]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1933]])
// CHECK:         %[[VAL_1934:.*]] = mul nuw nsw i32 %[[VAL_1932]], 4
// CHECK:         %[[VAL_1935:.*]] = udiv i32 %[[VAL_1934]], 1
// CHECK:         %[[VAL_1936:.*]] = urem i32 %[[VAL_1935]], 200
// CHECK:         %[[VAL_1937:.*]] = udiv i32 %[[VAL_1934]], 200
// CHECK:         %[[VAL_1938:.*]] = add nuw nsw i32 %[[VAL_1934]], 1
// CHECK:         %[[VAL_1939:.*]] = udiv i32 %[[VAL_1938]], 1
// CHECK:         %[[VAL_1940:.*]] = urem i32 %[[VAL_1939]], 200
// CHECK:         %[[VAL_1941:.*]] = udiv i32 %[[VAL_1938]], 200
// CHECK:         %[[VAL_1942:.*]] = add nuw nsw i32 %[[VAL_1934]], 2
// CHECK:         %[[VAL_1943:.*]] = udiv i32 %[[VAL_1942]], 1
// CHECK:         %[[VAL_1944:.*]] = urem i32 %[[VAL_1943]], 200
// CHECK:         %[[VAL_1945:.*]] = udiv i32 %[[VAL_1942]], 200
// CHECK:         %[[VAL_1946:.*]] = add nuw nsw i32 %[[VAL_1934]], 3
// CHECK:         %[[VAL_1947:.*]] = udiv i32 %[[VAL_1946]], 1
// CHECK:         %[[VAL_1948:.*]] = urem i32 %[[VAL_1947]], 200
// CHECK:         %[[VAL_1949:.*]] = udiv i32 %[[VAL_1946]], 200
// CHECK:         %[[VAL_1950:.*]] = icmp ult i32 %[[VAL_1934]], 20000
// CHECK:         br i1 %[[VAL_1950]], label %[[VAL_1951:.*]], label %[[VAL_1952:.*]]
// CHECK:       r33.in_bounds-after:                              ; preds = %[[VAL_1951]], %[[VAL_1953:.*]]
// CHECK:         ret void
// CHECK:       r33.in_bounds-true:                               ; preds = %[[VAL_1953]]
// CHECK:         %[[VAL_1954:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1922]] to float*
// CHECK:         %[[VAL_1955:.*]] = getelementptr inbounds float, float* %[[VAL_1954]], i32 %[[VAL_1934]]
// CHECK:         %[[VAL_1956:.*]] = load float, float* %[[VAL_1955]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1957:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1925]] to float*
// CHECK:         %[[VAL_1958:.*]] = getelementptr inbounds float, float* %[[VAL_1957]], i32 %[[VAL_1934]]
// CHECK:         %[[VAL_1959:.*]] = load float, float* %[[VAL_1958]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1960:.*]] = call float @llvm.minnum.f32(float %[[VAL_1956]], float %[[VAL_1959]])
// CHECK:         %[[VAL_1961:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1928]] to float*
// CHECK:         %[[VAL_1962:.*]] = getelementptr inbounds float, float* %[[VAL_1961]], i32 %[[VAL_1934]]
// CHECK:         store float %[[VAL_1960]], float* %[[VAL_1962]], align 4
// CHECK:         %[[VAL_1963:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1922]] to float*
// CHECK:         %[[VAL_1964:.*]] = getelementptr inbounds float, float* %[[VAL_1963]], i32 %[[VAL_1938]]
// CHECK:         %[[VAL_1965:.*]] = load float, float* %[[VAL_1964]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1966:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1925]] to float*
// CHECK:         %[[VAL_1967:.*]] = getelementptr inbounds float, float* %[[VAL_1966]], i32 %[[VAL_1938]]
// CHECK:         %[[VAL_1968:.*]] = load float, float* %[[VAL_1967]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1969:.*]] = call float @llvm.minnum.f32(float %[[VAL_1965]], float %[[VAL_1968]])
// CHECK:         %[[VAL_1970:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1928]] to float*
// CHECK:         %[[VAL_1971:.*]] = getelementptr inbounds float, float* %[[VAL_1970]], i32 %[[VAL_1938]]
// CHECK:         store float %[[VAL_1969]], float* %[[VAL_1971]], align 4
// CHECK:         %[[VAL_1972:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1922]] to float*
// CHECK:         %[[VAL_1973:.*]] = getelementptr inbounds float, float* %[[VAL_1972]], i32 %[[VAL_1942]]
// CHECK:         %[[VAL_1974:.*]] = load float, float* %[[VAL_1973]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1975:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1925]] to float*
// CHECK:         %[[VAL_1976:.*]] = getelementptr inbounds float, float* %[[VAL_1975]], i32 %[[VAL_1942]]
// CHECK:         %[[VAL_1977:.*]] = load float, float* %[[VAL_1976]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1978:.*]] = call float @llvm.minnum.f32(float %[[VAL_1974]], float %[[VAL_1977]])
// CHECK:         %[[VAL_1979:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1928]] to float*
// CHECK:         %[[VAL_1980:.*]] = getelementptr inbounds float, float* %[[VAL_1979]], i32 %[[VAL_1942]]
// CHECK:         store float %[[VAL_1978]], float* %[[VAL_1980]], align 4
// CHECK:         %[[VAL_1981:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1922]] to float*
// CHECK:         %[[VAL_1982:.*]] = getelementptr inbounds float, float* %[[VAL_1981]], i32 %[[VAL_1946]]
// CHECK:         %[[VAL_1983:.*]] = load float, float* %[[VAL_1982]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1984:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1925]] to float*
// CHECK:         %[[VAL_1985:.*]] = getelementptr inbounds float, float* %[[VAL_1984]], i32 %[[VAL_1946]]
// CHECK:         %[[VAL_1986:.*]] = load float, float* %[[VAL_1985]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1987:.*]] = call float @llvm.minnum.f32(float %[[VAL_1983]], float %[[VAL_1986]])
// CHECK:         %[[VAL_1988:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1928]] to float*
// CHECK:         %[[VAL_1989:.*]] = getelementptr inbounds float, float* %[[VAL_1988]], i32 %[[VAL_1946]]
// CHECK:         store float %[[VAL_1987]], float* %[[VAL_1989]], align 4
// CHECK:         br label %[[VAL_1952]]
// CHECK:       entry:
// CHECK:         %[[VAL_1990:.*]] = getelementptr inbounds i8, i8* %[[VAL_1991:.*]], i64 0
// CHECK:         %[[VAL_1992:.*]] = bitcast i8* %[[VAL_1990]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1993:.*]] = getelementptr inbounds i8, i8* %[[VAL_1994:.*]], i64 0
// CHECK:         %[[VAL_1995:.*]] = bitcast i8* %[[VAL_1993]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1996:.*]] = getelementptr inbounds i8, i8* %[[VAL_1997:.*]], i64 0
// CHECK:         %[[VAL_1998:.*]] = bitcast i8* %[[VAL_1996]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1999:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2000:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2001:.*]] = mul nuw nsw i32 %[[VAL_1999]], 256
// CHECK:         %[[VAL_2002:.*]] = add nuw nsw i32 %[[VAL_2001]], %[[VAL_2000]]
// CHECK:         %[[VAL_2003:.*]] = icmp ult i32 %[[VAL_2002]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2003]])
// CHECK:         %[[VAL_2004:.*]] = mul nuw nsw i32 %[[VAL_2002]], 4
// CHECK:         %[[VAL_2005:.*]] = udiv i32 %[[VAL_2004]], 1
// CHECK:         %[[VAL_2006:.*]] = urem i32 %[[VAL_2005]], 200
// CHECK:         %[[VAL_2007:.*]] = udiv i32 %[[VAL_2004]], 200
// CHECK:         %[[VAL_2008:.*]] = add nuw nsw i32 %[[VAL_2004]], 1
// CHECK:         %[[VAL_2009:.*]] = udiv i32 %[[VAL_2008]], 1
// CHECK:         %[[VAL_2010:.*]] = urem i32 %[[VAL_2009]], 200
// CHECK:         %[[VAL_2011:.*]] = udiv i32 %[[VAL_2008]], 200
// CHECK:         %[[VAL_2012:.*]] = add nuw nsw i32 %[[VAL_2004]], 2
// CHECK:         %[[VAL_2013:.*]] = udiv i32 %[[VAL_2012]], 1
// CHECK:         %[[VAL_2014:.*]] = urem i32 %[[VAL_2013]], 200
// CHECK:         %[[VAL_2015:.*]] = udiv i32 %[[VAL_2012]], 200
// CHECK:         %[[VAL_2016:.*]] = add nuw nsw i32 %[[VAL_2004]], 3
// CHECK:         %[[VAL_2017:.*]] = udiv i32 %[[VAL_2016]], 1
// CHECK:         %[[VAL_2018:.*]] = urem i32 %[[VAL_2017]], 200
// CHECK:         %[[VAL_2019:.*]] = udiv i32 %[[VAL_2016]], 200
// CHECK:         %[[VAL_2020:.*]] = icmp ult i32 %[[VAL_2004]], 20000
// CHECK:         br i1 %[[VAL_2020]], label %[[VAL_2021:.*]], label %[[VAL_2022:.*]]
// CHECK:       r34.in_bounds-after:                              ; preds = %[[VAL_2021]], %[[VAL_2023:.*]]
// CHECK:         ret void
// CHECK:       r34.in_bounds-true:                               ; preds = %[[VAL_2023]]
// CHECK:         %[[VAL_2024:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1992]] to float*
// CHECK:         %[[VAL_2025:.*]] = getelementptr inbounds float, float* %[[VAL_2024]], i32 %[[VAL_2004]]
// CHECK:         %[[VAL_2026:.*]] = load float, float* %[[VAL_2025]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2027:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1995]] to float*
// CHECK:         %[[VAL_2028:.*]] = getelementptr inbounds float, float* %[[VAL_2027]], i32 %[[VAL_2004]]
// CHECK:         %[[VAL_2029:.*]] = load float, float* %[[VAL_2028]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2030:.*]] = fmul float %[[VAL_2026]], %[[VAL_2029]]
// CHECK:         %[[VAL_2031:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1998]] to float*
// CHECK:         %[[VAL_2032:.*]] = getelementptr inbounds float, float* %[[VAL_2031]], i32 %[[VAL_2004]]
// CHECK:         store float %[[VAL_2030]], float* %[[VAL_2032]], align 4
// CHECK:         %[[VAL_2033:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1992]] to float*
// CHECK:         %[[VAL_2034:.*]] = getelementptr inbounds float, float* %[[VAL_2033]], i32 %[[VAL_2008]]
// CHECK:         %[[VAL_2035:.*]] = load float, float* %[[VAL_2034]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2036:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1995]] to float*
// CHECK:         %[[VAL_2037:.*]] = getelementptr inbounds float, float* %[[VAL_2036]], i32 %[[VAL_2008]]
// CHECK:         %[[VAL_2038:.*]] = load float, float* %[[VAL_2037]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2039:.*]] = fmul float %[[VAL_2035]], %[[VAL_2038]]
// CHECK:         %[[VAL_2040:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1998]] to float*
// CHECK:         %[[VAL_2041:.*]] = getelementptr inbounds float, float* %[[VAL_2040]], i32 %[[VAL_2008]]
// CHECK:         store float %[[VAL_2039]], float* %[[VAL_2041]], align 4
// CHECK:         %[[VAL_2042:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1992]] to float*
// CHECK:         %[[VAL_2043:.*]] = getelementptr inbounds float, float* %[[VAL_2042]], i32 %[[VAL_2012]]
// CHECK:         %[[VAL_2044:.*]] = load float, float* %[[VAL_2043]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2045:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1995]] to float*
// CHECK:         %[[VAL_2046:.*]] = getelementptr inbounds float, float* %[[VAL_2045]], i32 %[[VAL_2012]]
// CHECK:         %[[VAL_2047:.*]] = load float, float* %[[VAL_2046]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2048:.*]] = fmul float %[[VAL_2044]], %[[VAL_2047]]
// CHECK:         %[[VAL_2049:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1998]] to float*
// CHECK:         %[[VAL_2050:.*]] = getelementptr inbounds float, float* %[[VAL_2049]], i32 %[[VAL_2012]]
// CHECK:         store float %[[VAL_2048]], float* %[[VAL_2050]], align 4
// CHECK:         %[[VAL_2051:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1992]] to float*
// CHECK:         %[[VAL_2052:.*]] = getelementptr inbounds float, float* %[[VAL_2051]], i32 %[[VAL_2016]]
// CHECK:         %[[VAL_2053:.*]] = load float, float* %[[VAL_2052]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2054:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1995]] to float*
// CHECK:         %[[VAL_2055:.*]] = getelementptr inbounds float, float* %[[VAL_2054]], i32 %[[VAL_2016]]
// CHECK:         %[[VAL_2056:.*]] = load float, float* %[[VAL_2055]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2057:.*]] = fmul float %[[VAL_2053]], %[[VAL_2056]]
// CHECK:         %[[VAL_2058:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1998]] to float*
// CHECK:         %[[VAL_2059:.*]] = getelementptr inbounds float, float* %[[VAL_2058]], i32 %[[VAL_2016]]
// CHECK:         store float %[[VAL_2057]], float* %[[VAL_2059]], align 4
// CHECK:         br label %[[VAL_2022]]
// CHECK:       entry:
// CHECK:         %[[VAL_2060:.*]] = getelementptr inbounds i8, i8* %[[VAL_2061:.*]], i64 0
// CHECK:         %[[VAL_2062:.*]] = bitcast i8* %[[VAL_2060]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2063:.*]] = getelementptr inbounds i8, i8* %[[VAL_2064:.*]], i64 0
// CHECK:         %[[VAL_2065:.*]] = bitcast i8* %[[VAL_2063]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2066:.*]] = getelementptr inbounds i8, i8* %[[VAL_2067:.*]], i64 0
// CHECK:         %[[VAL_2068:.*]] = bitcast i8* %[[VAL_2066]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2069:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2070:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_2071:.*]] = mul nuw nsw i32 %[[VAL_2069]], 1024
// CHECK:         %[[VAL_2072:.*]] = add nuw nsw i32 %[[VAL_2071]], %[[VAL_2070]]
// CHECK:         %[[VAL_2073:.*]] = icmp ult i32 %[[VAL_2072]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_2073]])
// CHECK:         %[[VAL_2074:.*]] = udiv i32 %[[VAL_2072]], 1
// CHECK:         %[[VAL_2075:.*]] = urem i32 %[[VAL_2074]], 200
// CHECK:         %[[VAL_2076:.*]] = udiv i32 %[[VAL_2072]], 200
// CHECK:         %[[VAL_2077:.*]] = icmp ult i32 %[[VAL_2072]], 20000
// CHECK:         br i1 %[[VAL_2077]], label %[[VAL_2078:.*]], label %[[VAL_2079:.*]]
// CHECK:       r35.in_bounds-after:                              ; preds = %[[VAL_2078]], %[[VAL_2080:.*]]
// CHECK:         ret void
// CHECK:       r35.in_bounds-true:                               ; preds = %[[VAL_2080]]
// CHECK:         %[[VAL_2081:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2062]] to float*
// CHECK:         %[[VAL_2082:.*]] = getelementptr inbounds float, float* %[[VAL_2081]], i32 %[[VAL_2072]]
// CHECK:         %[[VAL_2083:.*]] = load float, float* %[[VAL_2082]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2084:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2065]] to float*
// CHECK:         %[[VAL_2085:.*]] = getelementptr inbounds float, float* %[[VAL_2084]], i32 %[[VAL_2072]]
// CHECK:         %[[VAL_2086:.*]] = load float, float* %[[VAL_2085]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2087:.*]] = call float @__nv_powf(float %[[VAL_2083]], float %[[VAL_2086]])
// CHECK:         %[[VAL_2088:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2068]] to float*
// CHECK:         %[[VAL_2089:.*]] = getelementptr inbounds float, float* %[[VAL_2088]], i32 %[[VAL_2072]]
// CHECK:         store float %[[VAL_2087]], float* %[[VAL_2089]], align 4
// CHECK:         br label %[[VAL_2079]]
// CHECK:       entry:
// CHECK:         %[[VAL_2090:.*]] = getelementptr inbounds i8, i8* %[[VAL_2091:.*]], i64 0
// CHECK:         %[[VAL_2092:.*]] = bitcast i8* %[[VAL_2090]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2093:.*]] = getelementptr inbounds i8, i8* %[[VAL_2094:.*]], i64 0
// CHECK:         %[[VAL_2095:.*]] = bitcast i8* %[[VAL_2093]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2096:.*]] = getelementptr inbounds i8, i8* %[[VAL_2097:.*]], i64 0
// CHECK:         %[[VAL_2098:.*]] = bitcast i8* %[[VAL_2096]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2099:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2100:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2101:.*]] = mul nuw nsw i32 %[[VAL_2099]], 256
// CHECK:         %[[VAL_2102:.*]] = add nuw nsw i32 %[[VAL_2101]], %[[VAL_2100]]
// CHECK:         %[[VAL_2103:.*]] = icmp ult i32 %[[VAL_2102]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2103]])
// CHECK:         %[[VAL_2104:.*]] = mul nuw nsw i32 %[[VAL_2102]], 4
// CHECK:         %[[VAL_2105:.*]] = udiv i32 %[[VAL_2104]], 1
// CHECK:         %[[VAL_2106:.*]] = urem i32 %[[VAL_2105]], 200
// CHECK:         %[[VAL_2107:.*]] = udiv i32 %[[VAL_2104]], 200
// CHECK:         %[[VAL_2108:.*]] = add nuw nsw i32 %[[VAL_2104]], 1
// CHECK:         %[[VAL_2109:.*]] = udiv i32 %[[VAL_2108]], 1
// CHECK:         %[[VAL_2110:.*]] = urem i32 %[[VAL_2109]], 200
// CHECK:         %[[VAL_2111:.*]] = udiv i32 %[[VAL_2108]], 200
// CHECK:         %[[VAL_2112:.*]] = add nuw nsw i32 %[[VAL_2104]], 2
// CHECK:         %[[VAL_2113:.*]] = udiv i32 %[[VAL_2112]], 1
// CHECK:         %[[VAL_2114:.*]] = urem i32 %[[VAL_2113]], 200
// CHECK:         %[[VAL_2115:.*]] = udiv i32 %[[VAL_2112]], 200
// CHECK:         %[[VAL_2116:.*]] = add nuw nsw i32 %[[VAL_2104]], 3
// CHECK:         %[[VAL_2117:.*]] = udiv i32 %[[VAL_2116]], 1
// CHECK:         %[[VAL_2118:.*]] = urem i32 %[[VAL_2117]], 200
// CHECK:         %[[VAL_2119:.*]] = udiv i32 %[[VAL_2116]], 200
// CHECK:         %[[VAL_2120:.*]] = icmp ult i32 %[[VAL_2104]], 20000
// CHECK:         br i1 %[[VAL_2120]], label %[[VAL_2121:.*]], label %[[VAL_2122:.*]]
// CHECK:       r36.in_bounds-after:                              ; preds = %[[VAL_2121]], %[[VAL_2123:.*]]
// CHECK:         ret void
// CHECK:       r36.in_bounds-true:                               ; preds = %[[VAL_2123]]
// CHECK:         %[[VAL_2124:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2092]] to float*
// CHECK:         %[[VAL_2125:.*]] = getelementptr inbounds float, float* %[[VAL_2124]], i32 %[[VAL_2104]]
// CHECK:         %[[VAL_2126:.*]] = load float, float* %[[VAL_2125]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2127:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2095]] to float*
// CHECK:         %[[VAL_2128:.*]] = getelementptr inbounds float, float* %[[VAL_2127]], i32 %[[VAL_2104]]
// CHECK:         %[[VAL_2129:.*]] = load float, float* %[[VAL_2128]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2130:.*]] = call float @__nv_fmodf(float %[[VAL_2126]], float %[[VAL_2129]])
// CHECK:         %[[VAL_2131:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2098]] to float*
// CHECK:         %[[VAL_2132:.*]] = getelementptr inbounds float, float* %[[VAL_2131]], i32 %[[VAL_2104]]
// CHECK:         store float %[[VAL_2130]], float* %[[VAL_2132]], align 4
// CHECK:         %[[VAL_2133:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2092]] to float*
// CHECK:         %[[VAL_2134:.*]] = getelementptr inbounds float, float* %[[VAL_2133]], i32 %[[VAL_2108]]
// CHECK:         %[[VAL_2135:.*]] = load float, float* %[[VAL_2134]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2136:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2095]] to float*
// CHECK:         %[[VAL_2137:.*]] = getelementptr inbounds float, float* %[[VAL_2136]], i32 %[[VAL_2108]]
// CHECK:         %[[VAL_2138:.*]] = load float, float* %[[VAL_2137]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2139:.*]] = call float @__nv_fmodf(float %[[VAL_2135]], float %[[VAL_2138]])
// CHECK:         %[[VAL_2140:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2098]] to float*
// CHECK:         %[[VAL_2141:.*]] = getelementptr inbounds float, float* %[[VAL_2140]], i32 %[[VAL_2108]]
// CHECK:         store float %[[VAL_2139]], float* %[[VAL_2141]], align 4
// CHECK:         %[[VAL_2142:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2092]] to float*
// CHECK:         %[[VAL_2143:.*]] = getelementptr inbounds float, float* %[[VAL_2142]], i32 %[[VAL_2112]]
// CHECK:         %[[VAL_2144:.*]] = load float, float* %[[VAL_2143]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2145:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2095]] to float*
// CHECK:         %[[VAL_2146:.*]] = getelementptr inbounds float, float* %[[VAL_2145]], i32 %[[VAL_2112]]
// CHECK:         %[[VAL_2147:.*]] = load float, float* %[[VAL_2146]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2148:.*]] = call float @__nv_fmodf(float %[[VAL_2144]], float %[[VAL_2147]])
// CHECK:         %[[VAL_2149:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2098]] to float*
// CHECK:         %[[VAL_2150:.*]] = getelementptr inbounds float, float* %[[VAL_2149]], i32 %[[VAL_2112]]
// CHECK:         store float %[[VAL_2148]], float* %[[VAL_2150]], align 4
// CHECK:         %[[VAL_2151:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2092]] to float*
// CHECK:         %[[VAL_2152:.*]] = getelementptr inbounds float, float* %[[VAL_2151]], i32 %[[VAL_2116]]
// CHECK:         %[[VAL_2153:.*]] = load float, float* %[[VAL_2152]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2154:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2095]] to float*
// CHECK:         %[[VAL_2155:.*]] = getelementptr inbounds float, float* %[[VAL_2154]], i32 %[[VAL_2116]]
// CHECK:         %[[VAL_2156:.*]] = load float, float* %[[VAL_2155]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2157:.*]] = call float @__nv_fmodf(float %[[VAL_2153]], float %[[VAL_2156]])
// CHECK:         %[[VAL_2158:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2098]] to float*
// CHECK:         %[[VAL_2159:.*]] = getelementptr inbounds float, float* %[[VAL_2158]], i32 %[[VAL_2116]]
// CHECK:         store float %[[VAL_2157]], float* %[[VAL_2159]], align 4
// CHECK:         br label %[[VAL_2122]]
// CHECK:       entry:
// CHECK:         %[[VAL_2160:.*]] = getelementptr inbounds i8, i8* %[[VAL_2161:.*]], i64 0
// CHECK:         %[[VAL_2162:.*]] = bitcast i8* %[[VAL_2160]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2163:.*]] = getelementptr inbounds i8, i8* %[[VAL_2164:.*]], i64 0
// CHECK:         %[[VAL_2165:.*]] = bitcast i8* %[[VAL_2163]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2166:.*]] = getelementptr inbounds i8, i8* %[[VAL_2167:.*]], i64 0
// CHECK:         %[[VAL_2168:.*]] = bitcast i8* %[[VAL_2166]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2169:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2170:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2171:.*]] = mul nuw nsw i32 %[[VAL_2169]], 256
// CHECK:         %[[VAL_2172:.*]] = add nuw nsw i32 %[[VAL_2171]], %[[VAL_2170]]
// CHECK:         %[[VAL_2173:.*]] = icmp ult i32 %[[VAL_2172]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2173]])
// CHECK:         %[[VAL_2174:.*]] = mul nuw nsw i32 %[[VAL_2172]], 4
// CHECK:         %[[VAL_2175:.*]] = udiv i32 %[[VAL_2174]], 1
// CHECK:         %[[VAL_2176:.*]] = urem i32 %[[VAL_2175]], 200
// CHECK:         %[[VAL_2177:.*]] = udiv i32 %[[VAL_2174]], 200
// CHECK:         %[[VAL_2178:.*]] = add nuw nsw i32 %[[VAL_2174]], 1
// CHECK:         %[[VAL_2179:.*]] = udiv i32 %[[VAL_2178]], 1
// CHECK:         %[[VAL_2180:.*]] = urem i32 %[[VAL_2179]], 200
// CHECK:         %[[VAL_2181:.*]] = udiv i32 %[[VAL_2178]], 200
// CHECK:         %[[VAL_2182:.*]] = add nuw nsw i32 %[[VAL_2174]], 2
// CHECK:         %[[VAL_2183:.*]] = udiv i32 %[[VAL_2182]], 1
// CHECK:         %[[VAL_2184:.*]] = urem i32 %[[VAL_2183]], 200
// CHECK:         %[[VAL_2185:.*]] = udiv i32 %[[VAL_2182]], 200
// CHECK:         %[[VAL_2186:.*]] = add nuw nsw i32 %[[VAL_2174]], 3
// CHECK:         %[[VAL_2187:.*]] = udiv i32 %[[VAL_2186]], 1
// CHECK:         %[[VAL_2188:.*]] = urem i32 %[[VAL_2187]], 200
// CHECK:         %[[VAL_2189:.*]] = udiv i32 %[[VAL_2186]], 200
// CHECK:         %[[VAL_2190:.*]] = icmp ult i32 %[[VAL_2174]], 20000
// CHECK:         br i1 %[[VAL_2190]], label %[[VAL_2191:.*]], label %[[VAL_2192:.*]]
// CHECK:       r37.in_bounds-after:                              ; preds = %[[VAL_2191]], %[[VAL_2193:.*]]
// CHECK:         ret void
// CHECK:       r37.in_bounds-true:                               ; preds = %[[VAL_2193]]
// CHECK:         %[[VAL_2194:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2162]] to float*
// CHECK:         %[[VAL_2195:.*]] = getelementptr inbounds float, float* %[[VAL_2194]], i32 %[[VAL_2174]]
// CHECK:         %[[VAL_2196:.*]] = load float, float* %[[VAL_2195]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2197:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2165]] to float*
// CHECK:         %[[VAL_2198:.*]] = getelementptr inbounds float, float* %[[VAL_2197]], i32 %[[VAL_2174]]
// CHECK:         %[[VAL_2199:.*]] = load float, float* %[[VAL_2198]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2200:.*]] = fsub float %[[VAL_2196]], %[[VAL_2199]]
// CHECK:         %[[VAL_2201:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2168]] to float*
// CHECK:         %[[VAL_2202:.*]] = getelementptr inbounds float, float* %[[VAL_2201]], i32 %[[VAL_2174]]
// CHECK:         store float %[[VAL_2200]], float* %[[VAL_2202]], align 4
// CHECK:         %[[VAL_2203:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2162]] to float*
// CHECK:         %[[VAL_2204:.*]] = getelementptr inbounds float, float* %[[VAL_2203]], i32 %[[VAL_2178]]
// CHECK:         %[[VAL_2205:.*]] = load float, float* %[[VAL_2204]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2206:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2165]] to float*
// CHECK:         %[[VAL_2207:.*]] = getelementptr inbounds float, float* %[[VAL_2206]], i32 %[[VAL_2178]]
// CHECK:         %[[VAL_2208:.*]] = load float, float* %[[VAL_2207]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2209:.*]] = fsub float %[[VAL_2205]], %[[VAL_2208]]
// CHECK:         %[[VAL_2210:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2168]] to float*
// CHECK:         %[[VAL_2211:.*]] = getelementptr inbounds float, float* %[[VAL_2210]], i32 %[[VAL_2178]]
// CHECK:         store float %[[VAL_2209]], float* %[[VAL_2211]], align 4
// CHECK:         %[[VAL_2212:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2162]] to float*
// CHECK:         %[[VAL_2213:.*]] = getelementptr inbounds float, float* %[[VAL_2212]], i32 %[[VAL_2182]]
// CHECK:         %[[VAL_2214:.*]] = load float, float* %[[VAL_2213]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2215:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2165]] to float*
// CHECK:         %[[VAL_2216:.*]] = getelementptr inbounds float, float* %[[VAL_2215]], i32 %[[VAL_2182]]
// CHECK:         %[[VAL_2217:.*]] = load float, float* %[[VAL_2216]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2218:.*]] = fsub float %[[VAL_2214]], %[[VAL_2217]]
// CHECK:         %[[VAL_2219:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2168]] to float*
// CHECK:         %[[VAL_2220:.*]] = getelementptr inbounds float, float* %[[VAL_2219]], i32 %[[VAL_2182]]
// CHECK:         store float %[[VAL_2218]], float* %[[VAL_2220]], align 4
// CHECK:         %[[VAL_2221:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2162]] to float*
// CHECK:         %[[VAL_2222:.*]] = getelementptr inbounds float, float* %[[VAL_2221]], i32 %[[VAL_2186]]
// CHECK:         %[[VAL_2223:.*]] = load float, float* %[[VAL_2222]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2224:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2165]] to float*
// CHECK:         %[[VAL_2225:.*]] = getelementptr inbounds float, float* %[[VAL_2224]], i32 %[[VAL_2186]]
// CHECK:         %[[VAL_2226:.*]] = load float, float* %[[VAL_2225]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2227:.*]] = fsub float %[[VAL_2223]], %[[VAL_2226]]
// CHECK:         %[[VAL_2228:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2168]] to float*
// CHECK:         %[[VAL_2229:.*]] = getelementptr inbounds float, float* %[[VAL_2228]], i32 %[[VAL_2186]]
// CHECK:         store float %[[VAL_2227]], float* %[[VAL_2229]], align 4
// CHECK:         br label %[[VAL_2192]]
// CHECK:       entry:
// CHECK:         %[[VAL_2230:.*]] = getelementptr inbounds i8, i8* %[[VAL_2231:.*]], i64 0
// CHECK:         %[[VAL_2232:.*]] = bitcast i8* %[[VAL_2230]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2233:.*]] = getelementptr inbounds i8, i8* %[[VAL_2234:.*]], i64 0
// CHECK:         %[[VAL_2235:.*]] = bitcast i8* %[[VAL_2233]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2236:.*]] = getelementptr inbounds i8, i8* %[[VAL_2237:.*]], i64 0
// CHECK:         %[[VAL_2238:.*]] = bitcast i8* %[[VAL_2236]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2239:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2240:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2241:.*]] = mul nuw nsw i32 %[[VAL_2239]], 256
// CHECK:         %[[VAL_2242:.*]] = add nuw nsw i32 %[[VAL_2241]], %[[VAL_2240]]
// CHECK:         %[[VAL_2243:.*]] = icmp ult i32 %[[VAL_2242]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2243]])
// CHECK:         %[[VAL_2244:.*]] = mul nuw nsw i32 %[[VAL_2242]], 4
// CHECK:         %[[VAL_2245:.*]] = udiv i32 %[[VAL_2244]], 1
// CHECK:         %[[VAL_2246:.*]] = urem i32 %[[VAL_2245]], 200
// CHECK:         %[[VAL_2247:.*]] = udiv i32 %[[VAL_2244]], 200
// CHECK:         %[[VAL_2248:.*]] = add nuw nsw i32 %[[VAL_2244]], 1
// CHECK:         %[[VAL_2249:.*]] = udiv i32 %[[VAL_2248]], 1
// CHECK:         %[[VAL_2250:.*]] = urem i32 %[[VAL_2249]], 200
// CHECK:         %[[VAL_2251:.*]] = udiv i32 %[[VAL_2248]], 200
// CHECK:         %[[VAL_2252:.*]] = add nuw nsw i32 %[[VAL_2244]], 2
// CHECK:         %[[VAL_2253:.*]] = udiv i32 %[[VAL_2252]], 1
// CHECK:         %[[VAL_2254:.*]] = urem i32 %[[VAL_2253]], 200
// CHECK:         %[[VAL_2255:.*]] = udiv i32 %[[VAL_2252]], 200
// CHECK:         %[[VAL_2256:.*]] = add nuw nsw i32 %[[VAL_2244]], 3
// CHECK:         %[[VAL_2257:.*]] = udiv i32 %[[VAL_2256]], 1
// CHECK:         %[[VAL_2258:.*]] = urem i32 %[[VAL_2257]], 200
// CHECK:         %[[VAL_2259:.*]] = udiv i32 %[[VAL_2256]], 200
// CHECK:         %[[VAL_2260:.*]] = icmp ult i32 %[[VAL_2244]], 20000
// CHECK:         br i1 %[[VAL_2260]], label %[[VAL_2261:.*]], label %[[VAL_2262:.*]]
// CHECK:       r38.in_bounds-after:                              ; preds = %[[VAL_2261]], %[[VAL_2263:.*]]
// CHECK:         ret void
// CHECK:       r38.in_bounds-true:                               ; preds = %[[VAL_2263]]
// CHECK:         %[[VAL_2264:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2232]] to i8*
// CHECK:         %[[VAL_2265:.*]] = getelementptr inbounds i8, i8* %[[VAL_2264]], i32 %[[VAL_2244]]
// CHECK:         %[[VAL_2266:.*]] = load i8, i8* %[[VAL_2265]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2267:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2235]] to i8*
// CHECK:         %[[VAL_2268:.*]] = getelementptr inbounds i8, i8* %[[VAL_2267]], i32 %[[VAL_2244]]
// CHECK:         %[[VAL_2269:.*]] = load i8, i8* %[[VAL_2268]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2270:.*]] = and i8 %[[VAL_2266]], %[[VAL_2269]]
// CHECK:         %[[VAL_2271:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2238]] to i8*
// CHECK:         %[[VAL_2272:.*]] = getelementptr inbounds i8, i8* %[[VAL_2271]], i32 %[[VAL_2244]]
// CHECK:         store i8 %[[VAL_2270]], i8* %[[VAL_2272]], align 1
// CHECK:         %[[VAL_2273:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2232]] to i8*
// CHECK:         %[[VAL_2274:.*]] = getelementptr inbounds i8, i8* %[[VAL_2273]], i32 %[[VAL_2248]]
// CHECK:         %[[VAL_2275:.*]] = load i8, i8* %[[VAL_2274]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2276:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2235]] to i8*
// CHECK:         %[[VAL_2277:.*]] = getelementptr inbounds i8, i8* %[[VAL_2276]], i32 %[[VAL_2248]]
// CHECK:         %[[VAL_2278:.*]] = load i8, i8* %[[VAL_2277]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2279:.*]] = and i8 %[[VAL_2275]], %[[VAL_2278]]
// CHECK:         %[[VAL_2280:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2238]] to i8*
// CHECK:         %[[VAL_2281:.*]] = getelementptr inbounds i8, i8* %[[VAL_2280]], i32 %[[VAL_2248]]
// CHECK:         store i8 %[[VAL_2279]], i8* %[[VAL_2281]], align 1
// CHECK:         %[[VAL_2282:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2232]] to i8*
// CHECK:         %[[VAL_2283:.*]] = getelementptr inbounds i8, i8* %[[VAL_2282]], i32 %[[VAL_2252]]
// CHECK:         %[[VAL_2284:.*]] = load i8, i8* %[[VAL_2283]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2285:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2235]] to i8*
// CHECK:         %[[VAL_2286:.*]] = getelementptr inbounds i8, i8* %[[VAL_2285]], i32 %[[VAL_2252]]
// CHECK:         %[[VAL_2287:.*]] = load i8, i8* %[[VAL_2286]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2288:.*]] = and i8 %[[VAL_2284]], %[[VAL_2287]]
// CHECK:         %[[VAL_2289:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2238]] to i8*
// CHECK:         %[[VAL_2290:.*]] = getelementptr inbounds i8, i8* %[[VAL_2289]], i32 %[[VAL_2252]]
// CHECK:         store i8 %[[VAL_2288]], i8* %[[VAL_2290]], align 1
// CHECK:         %[[VAL_2291:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2232]] to i8*
// CHECK:         %[[VAL_2292:.*]] = getelementptr inbounds i8, i8* %[[VAL_2291]], i32 %[[VAL_2256]]
// CHECK:         %[[VAL_2293:.*]] = load i8, i8* %[[VAL_2292]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2294:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2235]] to i8*
// CHECK:         %[[VAL_2295:.*]] = getelementptr inbounds i8, i8* %[[VAL_2294]], i32 %[[VAL_2256]]
// CHECK:         %[[VAL_2296:.*]] = load i8, i8* %[[VAL_2295]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2297:.*]] = and i8 %[[VAL_2293]], %[[VAL_2296]]
// CHECK:         %[[VAL_2298:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2238]] to i8*
// CHECK:         %[[VAL_2299:.*]] = getelementptr inbounds i8, i8* %[[VAL_2298]], i32 %[[VAL_2256]]
// CHECK:         store i8 %[[VAL_2297]], i8* %[[VAL_2299]], align 1
// CHECK:         br label %[[VAL_2262]]
// CHECK:       entry:
// CHECK:         %[[VAL_2300:.*]] = getelementptr inbounds i8, i8* %[[VAL_2301:.*]], i64 0
// CHECK:         %[[VAL_2302:.*]] = bitcast i8* %[[VAL_2300]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2303:.*]] = getelementptr inbounds i8, i8* %[[VAL_2304:.*]], i64 0
// CHECK:         %[[VAL_2305:.*]] = bitcast i8* %[[VAL_2303]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2306:.*]] = getelementptr inbounds i8, i8* %[[VAL_2307:.*]], i64 0
// CHECK:         %[[VAL_2308:.*]] = bitcast i8* %[[VAL_2306]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2309:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2310:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2311:.*]] = mul nuw nsw i32 %[[VAL_2309]], 256
// CHECK:         %[[VAL_2312:.*]] = add nuw nsw i32 %[[VAL_2311]], %[[VAL_2310]]
// CHECK:         %[[VAL_2313:.*]] = icmp ult i32 %[[VAL_2312]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2313]])
// CHECK:         %[[VAL_2314:.*]] = mul nuw nsw i32 %[[VAL_2312]], 4
// CHECK:         %[[VAL_2315:.*]] = udiv i32 %[[VAL_2314]], 1
// CHECK:         %[[VAL_2316:.*]] = urem i32 %[[VAL_2315]], 200
// CHECK:         %[[VAL_2317:.*]] = udiv i32 %[[VAL_2314]], 200
// CHECK:         %[[VAL_2318:.*]] = add nuw nsw i32 %[[VAL_2314]], 1
// CHECK:         %[[VAL_2319:.*]] = udiv i32 %[[VAL_2318]], 1
// CHECK:         %[[VAL_2320:.*]] = urem i32 %[[VAL_2319]], 200
// CHECK:         %[[VAL_2321:.*]] = udiv i32 %[[VAL_2318]], 200
// CHECK:         %[[VAL_2322:.*]] = add nuw nsw i32 %[[VAL_2314]], 2
// CHECK:         %[[VAL_2323:.*]] = udiv i32 %[[VAL_2322]], 1
// CHECK:         %[[VAL_2324:.*]] = urem i32 %[[VAL_2323]], 200
// CHECK:         %[[VAL_2325:.*]] = udiv i32 %[[VAL_2322]], 200
// CHECK:         %[[VAL_2326:.*]] = add nuw nsw i32 %[[VAL_2314]], 3
// CHECK:         %[[VAL_2327:.*]] = udiv i32 %[[VAL_2326]], 1
// CHECK:         %[[VAL_2328:.*]] = urem i32 %[[VAL_2327]], 200
// CHECK:         %[[VAL_2329:.*]] = udiv i32 %[[VAL_2326]], 200
// CHECK:         %[[VAL_2330:.*]] = icmp ult i32 %[[VAL_2314]], 20000
// CHECK:         br i1 %[[VAL_2330]], label %[[VAL_2331:.*]], label %[[VAL_2332:.*]]
// CHECK:       r39.in_bounds-after:                              ; preds = %[[VAL_2331]], %[[VAL_2333:.*]]
// CHECK:         ret void
// CHECK:       r39.in_bounds-true:                               ; preds = %[[VAL_2333]]
// CHECK:         %[[VAL_2334:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2302]] to i8*
// CHECK:         %[[VAL_2335:.*]] = getelementptr inbounds i8, i8* %[[VAL_2334]], i32 %[[VAL_2314]]
// CHECK:         %[[VAL_2336:.*]] = load i8, i8* %[[VAL_2335]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2337:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2305]] to i8*
// CHECK:         %[[VAL_2338:.*]] = getelementptr inbounds i8, i8* %[[VAL_2337]], i32 %[[VAL_2314]]
// CHECK:         %[[VAL_2339:.*]] = load i8, i8* %[[VAL_2338]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2340:.*]] = or i8 %[[VAL_2336]], %[[VAL_2339]]
// CHECK:         %[[VAL_2341:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2308]] to i8*
// CHECK:         %[[VAL_2342:.*]] = getelementptr inbounds i8, i8* %[[VAL_2341]], i32 %[[VAL_2314]]
// CHECK:         store i8 %[[VAL_2340]], i8* %[[VAL_2342]], align 1
// CHECK:         %[[VAL_2343:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2302]] to i8*
// CHECK:         %[[VAL_2344:.*]] = getelementptr inbounds i8, i8* %[[VAL_2343]], i32 %[[VAL_2318]]
// CHECK:         %[[VAL_2345:.*]] = load i8, i8* %[[VAL_2344]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2346:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2305]] to i8*
// CHECK:         %[[VAL_2347:.*]] = getelementptr inbounds i8, i8* %[[VAL_2346]], i32 %[[VAL_2318]]
// CHECK:         %[[VAL_2348:.*]] = load i8, i8* %[[VAL_2347]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2349:.*]] = or i8 %[[VAL_2345]], %[[VAL_2348]]
// CHECK:         %[[VAL_2350:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2308]] to i8*
// CHECK:         %[[VAL_2351:.*]] = getelementptr inbounds i8, i8* %[[VAL_2350]], i32 %[[VAL_2318]]
// CHECK:         store i8 %[[VAL_2349]], i8* %[[VAL_2351]], align 1
// CHECK:         %[[VAL_2352:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2302]] to i8*
// CHECK:         %[[VAL_2353:.*]] = getelementptr inbounds i8, i8* %[[VAL_2352]], i32 %[[VAL_2322]]
// CHECK:         %[[VAL_2354:.*]] = load i8, i8* %[[VAL_2353]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2355:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2305]] to i8*
// CHECK:         %[[VAL_2356:.*]] = getelementptr inbounds i8, i8* %[[VAL_2355]], i32 %[[VAL_2322]]
// CHECK:         %[[VAL_2357:.*]] = load i8, i8* %[[VAL_2356]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2358:.*]] = or i8 %[[VAL_2354]], %[[VAL_2357]]
// CHECK:         %[[VAL_2359:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2308]] to i8*
// CHECK:         %[[VAL_2360:.*]] = getelementptr inbounds i8, i8* %[[VAL_2359]], i32 %[[VAL_2322]]
// CHECK:         store i8 %[[VAL_2358]], i8* %[[VAL_2360]], align 1
// CHECK:         %[[VAL_2361:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2302]] to i8*
// CHECK:         %[[VAL_2362:.*]] = getelementptr inbounds i8, i8* %[[VAL_2361]], i32 %[[VAL_2326]]
// CHECK:         %[[VAL_2363:.*]] = load i8, i8* %[[VAL_2362]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2364:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2305]] to i8*
// CHECK:         %[[VAL_2365:.*]] = getelementptr inbounds i8, i8* %[[VAL_2364]], i32 %[[VAL_2326]]
// CHECK:         %[[VAL_2366:.*]] = load i8, i8* %[[VAL_2365]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2367:.*]] = or i8 %[[VAL_2363]], %[[VAL_2366]]
// CHECK:         %[[VAL_2368:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2308]] to i8*
// CHECK:         %[[VAL_2369:.*]] = getelementptr inbounds i8, i8* %[[VAL_2368]], i32 %[[VAL_2326]]
// CHECK:         store i8 %[[VAL_2367]], i8* %[[VAL_2369]], align 1
// CHECK:         br label %[[VAL_2332]]
// CHECK:       entry:
// CHECK:         %[[VAL_2370:.*]] = getelementptr inbounds i8, i8* %[[VAL_2371:.*]], i64 0
// CHECK:         %[[VAL_2372:.*]] = bitcast i8* %[[VAL_2370]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2373:.*]] = getelementptr inbounds i8, i8* %[[VAL_2374:.*]], i64 0
// CHECK:         %[[VAL_2375:.*]] = bitcast i8* %[[VAL_2373]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2376:.*]] = getelementptr inbounds i8, i8* %[[VAL_2377:.*]], i64 0
// CHECK:         %[[VAL_2378:.*]] = bitcast i8* %[[VAL_2376]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2379:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2380:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2381:.*]] = mul nuw nsw i32 %[[VAL_2379]], 256
// CHECK:         %[[VAL_2382:.*]] = add nuw nsw i32 %[[VAL_2381]], %[[VAL_2380]]
// CHECK:         %[[VAL_2383:.*]] = icmp ult i32 %[[VAL_2382]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2383]])
// CHECK:         %[[VAL_2384:.*]] = mul nuw nsw i32 %[[VAL_2382]], 4
// CHECK:         %[[VAL_2385:.*]] = udiv i32 %[[VAL_2384]], 1
// CHECK:         %[[VAL_2386:.*]] = urem i32 %[[VAL_2385]], 200
// CHECK:         %[[VAL_2387:.*]] = udiv i32 %[[VAL_2384]], 200
// CHECK:         %[[VAL_2388:.*]] = add nuw nsw i32 %[[VAL_2384]], 1
// CHECK:         %[[VAL_2389:.*]] = udiv i32 %[[VAL_2388]], 1
// CHECK:         %[[VAL_2390:.*]] = urem i32 %[[VAL_2389]], 200
// CHECK:         %[[VAL_2391:.*]] = udiv i32 %[[VAL_2388]], 200
// CHECK:         %[[VAL_2392:.*]] = add nuw nsw i32 %[[VAL_2384]], 2
// CHECK:         %[[VAL_2393:.*]] = udiv i32 %[[VAL_2392]], 1
// CHECK:         %[[VAL_2394:.*]] = urem i32 %[[VAL_2393]], 200
// CHECK:         %[[VAL_2395:.*]] = udiv i32 %[[VAL_2392]], 200
// CHECK:         %[[VAL_2396:.*]] = add nuw nsw i32 %[[VAL_2384]], 3
// CHECK:         %[[VAL_2397:.*]] = udiv i32 %[[VAL_2396]], 1
// CHECK:         %[[VAL_2398:.*]] = urem i32 %[[VAL_2397]], 200
// CHECK:         %[[VAL_2399:.*]] = udiv i32 %[[VAL_2396]], 200
// CHECK:         %[[VAL_2400:.*]] = icmp ult i32 %[[VAL_2384]], 20000
// CHECK:         br i1 %[[VAL_2400]], label %[[VAL_2401:.*]], label %[[VAL_2402:.*]]
// CHECK:       r40.in_bounds-after:                              ; preds = %[[VAL_2401]], %[[VAL_2403:.*]]
// CHECK:         ret void
// CHECK:       r40.in_bounds-true:                               ; preds = %[[VAL_2403]]
// CHECK:         %[[VAL_2404:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2372]] to i8*
// CHECK:         %[[VAL_2405:.*]] = getelementptr inbounds i8, i8* %[[VAL_2404]], i32 %[[VAL_2384]]
// CHECK:         %[[VAL_2406:.*]] = load i8, i8* %[[VAL_2405]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2407:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2375]] to i8*
// CHECK:         %[[VAL_2408:.*]] = getelementptr inbounds i8, i8* %[[VAL_2407]], i32 %[[VAL_2384]]
// CHECK:         %[[VAL_2409:.*]] = load i8, i8* %[[VAL_2408]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2410:.*]] = xor i8 %[[VAL_2406]], %[[VAL_2409]]
// CHECK:         %[[VAL_2411:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2378]] to i8*
// CHECK:         %[[VAL_2412:.*]] = getelementptr inbounds i8, i8* %[[VAL_2411]], i32 %[[VAL_2384]]
// CHECK:         store i8 %[[VAL_2410]], i8* %[[VAL_2412]], align 1
// CHECK:         %[[VAL_2413:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2372]] to i8*
// CHECK:         %[[VAL_2414:.*]] = getelementptr inbounds i8, i8* %[[VAL_2413]], i32 %[[VAL_2388]]
// CHECK:         %[[VAL_2415:.*]] = load i8, i8* %[[VAL_2414]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2416:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2375]] to i8*
// CHECK:         %[[VAL_2417:.*]] = getelementptr inbounds i8, i8* %[[VAL_2416]], i32 %[[VAL_2388]]
// CHECK:         %[[VAL_2418:.*]] = load i8, i8* %[[VAL_2417]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2419:.*]] = xor i8 %[[VAL_2415]], %[[VAL_2418]]
// CHECK:         %[[VAL_2420:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2378]] to i8*
// CHECK:         %[[VAL_2421:.*]] = getelementptr inbounds i8, i8* %[[VAL_2420]], i32 %[[VAL_2388]]
// CHECK:         store i8 %[[VAL_2419]], i8* %[[VAL_2421]], align 1
// CHECK:         %[[VAL_2422:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2372]] to i8*
// CHECK:         %[[VAL_2423:.*]] = getelementptr inbounds i8, i8* %[[VAL_2422]], i32 %[[VAL_2392]]
// CHECK:         %[[VAL_2424:.*]] = load i8, i8* %[[VAL_2423]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2425:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2375]] to i8*
// CHECK:         %[[VAL_2426:.*]] = getelementptr inbounds i8, i8* %[[VAL_2425]], i32 %[[VAL_2392]]
// CHECK:         %[[VAL_2427:.*]] = load i8, i8* %[[VAL_2426]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2428:.*]] = xor i8 %[[VAL_2424]], %[[VAL_2427]]
// CHECK:         %[[VAL_2429:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2378]] to i8*
// CHECK:         %[[VAL_2430:.*]] = getelementptr inbounds i8, i8* %[[VAL_2429]], i32 %[[VAL_2392]]
// CHECK:         store i8 %[[VAL_2428]], i8* %[[VAL_2430]], align 1
// CHECK:         %[[VAL_2431:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2372]] to i8*
// CHECK:         %[[VAL_2432:.*]] = getelementptr inbounds i8, i8* %[[VAL_2431]], i32 %[[VAL_2396]]
// CHECK:         %[[VAL_2433:.*]] = load i8, i8* %[[VAL_2432]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2434:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2375]] to i8*
// CHECK:         %[[VAL_2435:.*]] = getelementptr inbounds i8, i8* %[[VAL_2434]], i32 %[[VAL_2396]]
// CHECK:         %[[VAL_2436:.*]] = load i8, i8* %[[VAL_2435]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2437:.*]] = xor i8 %[[VAL_2433]], %[[VAL_2436]]
// CHECK:         %[[VAL_2438:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2378]] to i8*
// CHECK:         %[[VAL_2439:.*]] = getelementptr inbounds i8, i8* %[[VAL_2438]], i32 %[[VAL_2396]]
// CHECK:         store i8 %[[VAL_2437]], i8* %[[VAL_2439]], align 1
// CHECK:         br label %[[VAL_2402]]
// CHECK:       entry:
// CHECK:         %[[VAL_2440:.*]] = getelementptr inbounds i8, i8* %[[VAL_2441:.*]], i64 0
// CHECK:         %[[VAL_2442:.*]] = bitcast i8* %[[VAL_2440]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2443:.*]] = getelementptr inbounds i8, i8* %[[VAL_2444:.*]], i64 0
// CHECK:         %[[VAL_2445:.*]] = bitcast i8* %[[VAL_2443]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2446:.*]] = getelementptr inbounds i8, i8* %[[VAL_2447:.*]], i64 0
// CHECK:         %[[VAL_2448:.*]] = bitcast i8* %[[VAL_2446]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2449:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2450:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2451:.*]] = mul nuw nsw i32 %[[VAL_2449]], 256
// CHECK:         %[[VAL_2452:.*]] = add nuw nsw i32 %[[VAL_2451]], %[[VAL_2450]]
// CHECK:         %[[VAL_2453:.*]] = icmp ult i32 %[[VAL_2452]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2453]])
// CHECK:         %[[VAL_2454:.*]] = mul nuw nsw i32 %[[VAL_2452]], 4
// CHECK:         %[[VAL_2455:.*]] = udiv i32 %[[VAL_2454]], 1
// CHECK:         %[[VAL_2456:.*]] = urem i32 %[[VAL_2455]], 200
// CHECK:         %[[VAL_2457:.*]] = udiv i32 %[[VAL_2454]], 200
// CHECK:         %[[VAL_2458:.*]] = add nuw nsw i32 %[[VAL_2454]], 1
// CHECK:         %[[VAL_2459:.*]] = udiv i32 %[[VAL_2458]], 1
// CHECK:         %[[VAL_2460:.*]] = urem i32 %[[VAL_2459]], 200
// CHECK:         %[[VAL_2461:.*]] = udiv i32 %[[VAL_2458]], 200
// CHECK:         %[[VAL_2462:.*]] = add nuw nsw i32 %[[VAL_2454]], 2
// CHECK:         %[[VAL_2463:.*]] = udiv i32 %[[VAL_2462]], 1
// CHECK:         %[[VAL_2464:.*]] = urem i32 %[[VAL_2463]], 200
// CHECK:         %[[VAL_2465:.*]] = udiv i32 %[[VAL_2462]], 200
// CHECK:         %[[VAL_2466:.*]] = add nuw nsw i32 %[[VAL_2454]], 3
// CHECK:         %[[VAL_2467:.*]] = udiv i32 %[[VAL_2466]], 1
// CHECK:         %[[VAL_2468:.*]] = urem i32 %[[VAL_2467]], 200
// CHECK:         %[[VAL_2469:.*]] = udiv i32 %[[VAL_2466]], 200
// CHECK:         %[[VAL_2470:.*]] = icmp ult i32 %[[VAL_2454]], 20000
// CHECK:         br i1 %[[VAL_2470]], label %[[VAL_2471:.*]], label %[[VAL_2472:.*]]
// CHECK:       r41.in_bounds-after:                              ; preds = %[[VAL_2471]], %[[VAL_2473:.*]]
// CHECK:         ret void
// CHECK:       r41.in_bounds-true:                               ; preds = %[[VAL_2473]]
// CHECK:         %[[VAL_2474:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2442]] to i8*
// CHECK:         %[[VAL_2475:.*]] = getelementptr inbounds i8, i8* %[[VAL_2474]], i32 %[[VAL_2454]]
// CHECK:         %[[VAL_2476:.*]] = load i8, i8* %[[VAL_2475]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2477:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2445]] to i8*
// CHECK:         %[[VAL_2478:.*]] = getelementptr inbounds i8, i8* %[[VAL_2477]], i32 %[[VAL_2454]]
// CHECK:         %[[VAL_2479:.*]] = load i8, i8* %[[VAL_2478]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2480:.*]] = or i8 %[[VAL_2476]], %[[VAL_2479]]
// CHECK:         %[[VAL_2481:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2448]] to i8*
// CHECK:         %[[VAL_2482:.*]] = getelementptr inbounds i8, i8* %[[VAL_2481]], i32 %[[VAL_2454]]
// CHECK:         store i8 %[[VAL_2480]], i8* %[[VAL_2482]], align 1
// CHECK:         %[[VAL_2483:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2442]] to i8*
// CHECK:         %[[VAL_2484:.*]] = getelementptr inbounds i8, i8* %[[VAL_2483]], i32 %[[VAL_2458]]
// CHECK:         %[[VAL_2485:.*]] = load i8, i8* %[[VAL_2484]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2486:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2445]] to i8*
// CHECK:         %[[VAL_2487:.*]] = getelementptr inbounds i8, i8* %[[VAL_2486]], i32 %[[VAL_2458]]
// CHECK:         %[[VAL_2488:.*]] = load i8, i8* %[[VAL_2487]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2489:.*]] = or i8 %[[VAL_2485]], %[[VAL_2488]]
// CHECK:         %[[VAL_2490:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2448]] to i8*
// CHECK:         %[[VAL_2491:.*]] = getelementptr inbounds i8, i8* %[[VAL_2490]], i32 %[[VAL_2458]]
// CHECK:         store i8 %[[VAL_2489]], i8* %[[VAL_2491]], align 1
// CHECK:         %[[VAL_2492:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2442]] to i8*
// CHECK:         %[[VAL_2493:.*]] = getelementptr inbounds i8, i8* %[[VAL_2492]], i32 %[[VAL_2462]]
// CHECK:         %[[VAL_2494:.*]] = load i8, i8* %[[VAL_2493]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2495:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2445]] to i8*
// CHECK:         %[[VAL_2496:.*]] = getelementptr inbounds i8, i8* %[[VAL_2495]], i32 %[[VAL_2462]]
// CHECK:         %[[VAL_2497:.*]] = load i8, i8* %[[VAL_2496]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2498:.*]] = or i8 %[[VAL_2494]], %[[VAL_2497]]
// CHECK:         %[[VAL_2499:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2448]] to i8*
// CHECK:         %[[VAL_2500:.*]] = getelementptr inbounds i8, i8* %[[VAL_2499]], i32 %[[VAL_2462]]
// CHECK:         store i8 %[[VAL_2498]], i8* %[[VAL_2500]], align 1
// CHECK:         %[[VAL_2501:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2442]] to i8*
// CHECK:         %[[VAL_2502:.*]] = getelementptr inbounds i8, i8* %[[VAL_2501]], i32 %[[VAL_2466]]
// CHECK:         %[[VAL_2503:.*]] = load i8, i8* %[[VAL_2502]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2504:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2445]] to i8*
// CHECK:         %[[VAL_2505:.*]] = getelementptr inbounds i8, i8* %[[VAL_2504]], i32 %[[VAL_2466]]
// CHECK:         %[[VAL_2506:.*]] = load i8, i8* %[[VAL_2505]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2507:.*]] = or i8 %[[VAL_2503]], %[[VAL_2506]]
// CHECK:         %[[VAL_2508:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2448]] to i8*
// CHECK:         %[[VAL_2509:.*]] = getelementptr inbounds i8, i8* %[[VAL_2508]], i32 %[[VAL_2466]]
// CHECK:         store i8 %[[VAL_2507]], i8* %[[VAL_2509]], align 1
// CHECK:         br label %[[VAL_2472]]
// CHECK:       entry:
// CHECK:         %[[VAL_2510:.*]] = getelementptr inbounds i8, i8* %[[VAL_2511:.*]], i64 0
// CHECK:         %[[VAL_2512:.*]] = bitcast i8* %[[VAL_2510]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2513:.*]] = getelementptr inbounds i8, i8* %[[VAL_2514:.*]], i64 0
// CHECK:         %[[VAL_2515:.*]] = bitcast i8* %[[VAL_2513]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2516:.*]] = getelementptr inbounds i8, i8* %[[VAL_2517:.*]], i64 0
// CHECK:         %[[VAL_2518:.*]] = bitcast i8* %[[VAL_2516]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2519:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2520:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2521:.*]] = mul nuw nsw i32 %[[VAL_2519]], 256
// CHECK:         %[[VAL_2522:.*]] = add nuw nsw i32 %[[VAL_2521]], %[[VAL_2520]]
// CHECK:         %[[VAL_2523:.*]] = icmp ult i32 %[[VAL_2522]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2523]])
// CHECK:         %[[VAL_2524:.*]] = mul nuw nsw i32 %[[VAL_2522]], 4
// CHECK:         %[[VAL_2525:.*]] = udiv i32 %[[VAL_2524]], 1
// CHECK:         %[[VAL_2526:.*]] = urem i32 %[[VAL_2525]], 200
// CHECK:         %[[VAL_2527:.*]] = udiv i32 %[[VAL_2524]], 200
// CHECK:         %[[VAL_2528:.*]] = add nuw nsw i32 %[[VAL_2524]], 1
// CHECK:         %[[VAL_2529:.*]] = udiv i32 %[[VAL_2528]], 1
// CHECK:         %[[VAL_2530:.*]] = urem i32 %[[VAL_2529]], 200
// CHECK:         %[[VAL_2531:.*]] = udiv i32 %[[VAL_2528]], 200
// CHECK:         %[[VAL_2532:.*]] = add nuw nsw i32 %[[VAL_2524]], 2
// CHECK:         %[[VAL_2533:.*]] = udiv i32 %[[VAL_2532]], 1
// CHECK:         %[[VAL_2534:.*]] = urem i32 %[[VAL_2533]], 200
// CHECK:         %[[VAL_2535:.*]] = udiv i32 %[[VAL_2532]], 200
// CHECK:         %[[VAL_2536:.*]] = add nuw nsw i32 %[[VAL_2524]], 3
// CHECK:         %[[VAL_2537:.*]] = udiv i32 %[[VAL_2536]], 1
// CHECK:         %[[VAL_2538:.*]] = urem i32 %[[VAL_2537]], 200
// CHECK:         %[[VAL_2539:.*]] = udiv i32 %[[VAL_2536]], 200
// CHECK:         %[[VAL_2540:.*]] = icmp ult i32 %[[VAL_2524]], 20000
// CHECK:         br i1 %[[VAL_2540]], label %[[VAL_2541:.*]], label %[[VAL_2542:.*]]
// CHECK:       r42.in_bounds-after:                              ; preds = %[[VAL_2541]], %[[VAL_2543:.*]]
// CHECK:         ret void
// CHECK:       r42.in_bounds-true:                               ; preds = %[[VAL_2543]]
// CHECK:         %[[VAL_2544:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2512]] to i32*
// CHECK:         %[[VAL_2545:.*]] = getelementptr inbounds i32, i32* %[[VAL_2544]], i32 %[[VAL_2524]]
// CHECK:         %[[VAL_2546:.*]] = load i32, i32* %[[VAL_2545]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2547:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2515]] to i32*
// CHECK:         %[[VAL_2548:.*]] = getelementptr inbounds i32, i32* %[[VAL_2547]], i32 %[[VAL_2524]]
// CHECK:         %[[VAL_2549:.*]] = load i32, i32* %[[VAL_2548]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2550:.*]] = shl i32 %[[VAL_2546]], %[[VAL_2549]]
// CHECK:         %[[VAL_2551:.*]] = icmp ult i32 %[[VAL_2549]], 32
// CHECK:         %[[VAL_2552:.*]] = select i1 %[[VAL_2551]], i32 %[[VAL_2550]], i32 0
// CHECK:         %[[VAL_2553:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2518]] to i32*
// CHECK:         %[[VAL_2554:.*]] = getelementptr inbounds i32, i32* %[[VAL_2553]], i32 %[[VAL_2524]]
// CHECK:         store i32 %[[VAL_2552]], i32* %[[VAL_2554]], align 4
// CHECK:         %[[VAL_2555:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2512]] to i32*
// CHECK:         %[[VAL_2556:.*]] = getelementptr inbounds i32, i32* %[[VAL_2555]], i32 %[[VAL_2528]]
// CHECK:         %[[VAL_2557:.*]] = load i32, i32* %[[VAL_2556]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2558:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2515]] to i32*
// CHECK:         %[[VAL_2559:.*]] = getelementptr inbounds i32, i32* %[[VAL_2558]], i32 %[[VAL_2528]]
// CHECK:         %[[VAL_2560:.*]] = load i32, i32* %[[VAL_2559]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2561:.*]] = shl i32 %[[VAL_2557]], %[[VAL_2560]]
// CHECK:         %[[VAL_2562:.*]] = icmp ult i32 %[[VAL_2560]], 32
// CHECK:         %[[VAL_2563:.*]] = select i1 %[[VAL_2562]], i32 %[[VAL_2561]], i32 0
// CHECK:         %[[VAL_2564:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2518]] to i32*
// CHECK:         %[[VAL_2565:.*]] = getelementptr inbounds i32, i32* %[[VAL_2564]], i32 %[[VAL_2528]]
// CHECK:         store i32 %[[VAL_2563]], i32* %[[VAL_2565]], align 4
// CHECK:         %[[VAL_2566:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2512]] to i32*
// CHECK:         %[[VAL_2567:.*]] = getelementptr inbounds i32, i32* %[[VAL_2566]], i32 %[[VAL_2532]]
// CHECK:         %[[VAL_2568:.*]] = load i32, i32* %[[VAL_2567]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2569:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2515]] to i32*
// CHECK:         %[[VAL_2570:.*]] = getelementptr inbounds i32, i32* %[[VAL_2569]], i32 %[[VAL_2532]]
// CHECK:         %[[VAL_2571:.*]] = load i32, i32* %[[VAL_2570]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2572:.*]] = shl i32 %[[VAL_2568]], %[[VAL_2571]]
// CHECK:         %[[VAL_2573:.*]] = icmp ult i32 %[[VAL_2571]], 32
// CHECK:         %[[VAL_2574:.*]] = select i1 %[[VAL_2573]], i32 %[[VAL_2572]], i32 0
// CHECK:         %[[VAL_2575:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2518]] to i32*
// CHECK:         %[[VAL_2576:.*]] = getelementptr inbounds i32, i32* %[[VAL_2575]], i32 %[[VAL_2532]]
// CHECK:         store i32 %[[VAL_2574]], i32* %[[VAL_2576]], align 4
// CHECK:         %[[VAL_2577:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2512]] to i32*
// CHECK:         %[[VAL_2578:.*]] = getelementptr inbounds i32, i32* %[[VAL_2577]], i32 %[[VAL_2536]]
// CHECK:         %[[VAL_2579:.*]] = load i32, i32* %[[VAL_2578]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2580:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2515]] to i32*
// CHECK:         %[[VAL_2581:.*]] = getelementptr inbounds i32, i32* %[[VAL_2580]], i32 %[[VAL_2536]]
// CHECK:         %[[VAL_2582:.*]] = load i32, i32* %[[VAL_2581]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2583:.*]] = shl i32 %[[VAL_2579]], %[[VAL_2582]]
// CHECK:         %[[VAL_2584:.*]] = icmp ult i32 %[[VAL_2582]], 32
// CHECK:         %[[VAL_2585:.*]] = select i1 %[[VAL_2584]], i32 %[[VAL_2583]], i32 0
// CHECK:         %[[VAL_2586:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2518]] to i32*
// CHECK:         %[[VAL_2587:.*]] = getelementptr inbounds i32, i32* %[[VAL_2586]], i32 %[[VAL_2536]]
// CHECK:         store i32 %[[VAL_2585]], i32* %[[VAL_2587]], align 4
// CHECK:         br label %[[VAL_2542]]
// CHECK:       entry:
// CHECK:         %[[VAL_2588:.*]] = getelementptr inbounds i8, i8* %[[VAL_2589:.*]], i64 0
// CHECK:         %[[VAL_2590:.*]] = bitcast i8* %[[VAL_2588]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2591:.*]] = getelementptr inbounds i8, i8* %[[VAL_2592:.*]], i64 0
// CHECK:         %[[VAL_2593:.*]] = bitcast i8* %[[VAL_2591]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2594:.*]] = getelementptr inbounds i8, i8* %[[VAL_2595:.*]], i64 0
// CHECK:         %[[VAL_2596:.*]] = bitcast i8* %[[VAL_2594]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2597:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2598:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2599:.*]] = mul nuw nsw i32 %[[VAL_2597]], 256
// CHECK:         %[[VAL_2600:.*]] = add nuw nsw i32 %[[VAL_2599]], %[[VAL_2598]]
// CHECK:         %[[VAL_2601:.*]] = icmp ult i32 %[[VAL_2600]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2601]])
// CHECK:         %[[VAL_2602:.*]] = mul nuw nsw i32 %[[VAL_2600]], 4
// CHECK:         %[[VAL_2603:.*]] = udiv i32 %[[VAL_2602]], 1
// CHECK:         %[[VAL_2604:.*]] = urem i32 %[[VAL_2603]], 200
// CHECK:         %[[VAL_2605:.*]] = udiv i32 %[[VAL_2602]], 200
// CHECK:         %[[VAL_2606:.*]] = add nuw nsw i32 %[[VAL_2602]], 1
// CHECK:         %[[VAL_2607:.*]] = udiv i32 %[[VAL_2606]], 1
// CHECK:         %[[VAL_2608:.*]] = urem i32 %[[VAL_2607]], 200
// CHECK:         %[[VAL_2609:.*]] = udiv i32 %[[VAL_2606]], 200
// CHECK:         %[[VAL_2610:.*]] = add nuw nsw i32 %[[VAL_2602]], 2
// CHECK:         %[[VAL_2611:.*]] = udiv i32 %[[VAL_2610]], 1
// CHECK:         %[[VAL_2612:.*]] = urem i32 %[[VAL_2611]], 200
// CHECK:         %[[VAL_2613:.*]] = udiv i32 %[[VAL_2610]], 200
// CHECK:         %[[VAL_2614:.*]] = add nuw nsw i32 %[[VAL_2602]], 3
// CHECK:         %[[VAL_2615:.*]] = udiv i32 %[[VAL_2614]], 1
// CHECK:         %[[VAL_2616:.*]] = urem i32 %[[VAL_2615]], 200
// CHECK:         %[[VAL_2617:.*]] = udiv i32 %[[VAL_2614]], 200
// CHECK:         %[[VAL_2618:.*]] = icmp ult i32 %[[VAL_2602]], 20000
// CHECK:         br i1 %[[VAL_2618]], label %[[VAL_2619:.*]], label %[[VAL_2620:.*]]
// CHECK:       r43.in_bounds-after:                              ; preds = %[[VAL_2619]], %[[VAL_2621:.*]]
// CHECK:         ret void
// CHECK:       r43.in_bounds-true:                               ; preds = %[[VAL_2621]]
// CHECK:         %[[VAL_2622:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2590]] to i32*
// CHECK:         %[[VAL_2623:.*]] = getelementptr inbounds i32, i32* %[[VAL_2622]], i32 %[[VAL_2602]]
// CHECK:         %[[VAL_2624:.*]] = load i32, i32* %[[VAL_2623]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2625:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2593]] to i32*
// CHECK:         %[[VAL_2626:.*]] = getelementptr inbounds i32, i32* %[[VAL_2625]], i32 %[[VAL_2602]]
// CHECK:         %[[VAL_2627:.*]] = load i32, i32* %[[VAL_2626]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2628:.*]] = ashr i32 %[[VAL_2624]], %[[VAL_2627]]
// CHECK:         %[[VAL_2629:.*]] = icmp slt i32 %[[VAL_2624]], 0
// CHECK:         %[[VAL_2630:.*]] = select i1 %[[VAL_2629]], i32 -1, i32 0
// CHECK:         %[[VAL_2631:.*]] = icmp ult i32 %[[VAL_2627]], 32
// CHECK:         %[[VAL_2632:.*]] = select i1 %[[VAL_2631]], i32 %[[VAL_2628]], i32 %[[VAL_2630]]
// CHECK:         %[[VAL_2633:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2596]] to i32*
// CHECK:         %[[VAL_2634:.*]] = getelementptr inbounds i32, i32* %[[VAL_2633]], i32 %[[VAL_2602]]
// CHECK:         store i32 %[[VAL_2632]], i32* %[[VAL_2634]], align 4
// CHECK:         %[[VAL_2635:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2590]] to i32*
// CHECK:         %[[VAL_2636:.*]] = getelementptr inbounds i32, i32* %[[VAL_2635]], i32 %[[VAL_2606]]
// CHECK:         %[[VAL_2637:.*]] = load i32, i32* %[[VAL_2636]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2638:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2593]] to i32*
// CHECK:         %[[VAL_2639:.*]] = getelementptr inbounds i32, i32* %[[VAL_2638]], i32 %[[VAL_2606]]
// CHECK:         %[[VAL_2640:.*]] = load i32, i32* %[[VAL_2639]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2641:.*]] = ashr i32 %[[VAL_2637]], %[[VAL_2640]]
// CHECK:         %[[VAL_2642:.*]] = icmp slt i32 %[[VAL_2637]], 0
// CHECK:         %[[VAL_2643:.*]] = select i1 %[[VAL_2642]], i32 -1, i32 0
// CHECK:         %[[VAL_2644:.*]] = icmp ult i32 %[[VAL_2640]], 32
// CHECK:         %[[VAL_2645:.*]] = select i1 %[[VAL_2644]], i32 %[[VAL_2641]], i32 %[[VAL_2643]]
// CHECK:         %[[VAL_2646:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2596]] to i32*
// CHECK:         %[[VAL_2647:.*]] = getelementptr inbounds i32, i32* %[[VAL_2646]], i32 %[[VAL_2606]]
// CHECK:         store i32 %[[VAL_2645]], i32* %[[VAL_2647]], align 4
// CHECK:         %[[VAL_2648:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2590]] to i32*
// CHECK:         %[[VAL_2649:.*]] = getelementptr inbounds i32, i32* %[[VAL_2648]], i32 %[[VAL_2610]]
// CHECK:         %[[VAL_2650:.*]] = load i32, i32* %[[VAL_2649]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2651:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2593]] to i32*
// CHECK:         %[[VAL_2652:.*]] = getelementptr inbounds i32, i32* %[[VAL_2651]], i32 %[[VAL_2610]]
// CHECK:         %[[VAL_2653:.*]] = load i32, i32* %[[VAL_2652]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2654:.*]] = ashr i32 %[[VAL_2650]], %[[VAL_2653]]
// CHECK:         %[[VAL_2655:.*]] = icmp slt i32 %[[VAL_2650]], 0
// CHECK:         %[[VAL_2656:.*]] = select i1 %[[VAL_2655]], i32 -1, i32 0
// CHECK:         %[[VAL_2657:.*]] = icmp ult i32 %[[VAL_2653]], 32
// CHECK:         %[[VAL_2658:.*]] = select i1 %[[VAL_2657]], i32 %[[VAL_2654]], i32 %[[VAL_2656]]
// CHECK:         %[[VAL_2659:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2596]] to i32*
// CHECK:         %[[VAL_2660:.*]] = getelementptr inbounds i32, i32* %[[VAL_2659]], i32 %[[VAL_2610]]
// CHECK:         store i32 %[[VAL_2658]], i32* %[[VAL_2660]], align 4
// CHECK:         %[[VAL_2661:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2590]] to i32*
// CHECK:         %[[VAL_2662:.*]] = getelementptr inbounds i32, i32* %[[VAL_2661]], i32 %[[VAL_2614]]
// CHECK:         %[[VAL_2663:.*]] = load i32, i32* %[[VAL_2662]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2664:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2593]] to i32*
// CHECK:         %[[VAL_2665:.*]] = getelementptr inbounds i32, i32* %[[VAL_2664]], i32 %[[VAL_2614]]
// CHECK:         %[[VAL_2666:.*]] = load i32, i32* %[[VAL_2665]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2667:.*]] = ashr i32 %[[VAL_2663]], %[[VAL_2666]]
// CHECK:         %[[VAL_2668:.*]] = icmp slt i32 %[[VAL_2663]], 0
// CHECK:         %[[VAL_2669:.*]] = select i1 %[[VAL_2668]], i32 -1, i32 0
// CHECK:         %[[VAL_2670:.*]] = icmp ult i32 %[[VAL_2666]], 32
// CHECK:         %[[VAL_2671:.*]] = select i1 %[[VAL_2670]], i32 %[[VAL_2667]], i32 %[[VAL_2669]]
// CHECK:         %[[VAL_2672:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2596]] to i32*
// CHECK:         %[[VAL_2673:.*]] = getelementptr inbounds i32, i32* %[[VAL_2672]], i32 %[[VAL_2614]]
// CHECK:         store i32 %[[VAL_2671]], i32* %[[VAL_2673]], align 4
// CHECK:         br label %[[VAL_2620]]
// CHECK:       entry:
// CHECK:         %[[VAL_2674:.*]] = getelementptr inbounds i8, i8* %[[VAL_2675:.*]], i64 0
// CHECK:         %[[VAL_2676:.*]] = bitcast i8* %[[VAL_2674]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2677:.*]] = getelementptr inbounds i8, i8* %[[VAL_2678:.*]], i64 0
// CHECK:         %[[VAL_2679:.*]] = bitcast i8* %[[VAL_2677]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2680:.*]] = getelementptr inbounds i8, i8* %[[VAL_2681:.*]], i64 0
// CHECK:         %[[VAL_2682:.*]] = bitcast i8* %[[VAL_2680]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2683:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2684:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2685:.*]] = mul nuw nsw i32 %[[VAL_2683]], 256
// CHECK:         %[[VAL_2686:.*]] = add nuw nsw i32 %[[VAL_2685]], %[[VAL_2684]]
// CHECK:         %[[VAL_2687:.*]] = icmp ult i32 %[[VAL_2686]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2687]])
// CHECK:         %[[VAL_2688:.*]] = mul nuw nsw i32 %[[VAL_2686]], 4
// CHECK:         %[[VAL_2689:.*]] = udiv i32 %[[VAL_2688]], 1
// CHECK:         %[[VAL_2690:.*]] = urem i32 %[[VAL_2689]], 200
// CHECK:         %[[VAL_2691:.*]] = udiv i32 %[[VAL_2688]], 200
// CHECK:         %[[VAL_2692:.*]] = add nuw nsw i32 %[[VAL_2688]], 1
// CHECK:         %[[VAL_2693:.*]] = udiv i32 %[[VAL_2692]], 1
// CHECK:         %[[VAL_2694:.*]] = urem i32 %[[VAL_2693]], 200
// CHECK:         %[[VAL_2695:.*]] = udiv i32 %[[VAL_2692]], 200
// CHECK:         %[[VAL_2696:.*]] = add nuw nsw i32 %[[VAL_2688]], 2
// CHECK:         %[[VAL_2697:.*]] = udiv i32 %[[VAL_2696]], 1
// CHECK:         %[[VAL_2698:.*]] = urem i32 %[[VAL_2697]], 200
// CHECK:         %[[VAL_2699:.*]] = udiv i32 %[[VAL_2696]], 200
// CHECK:         %[[VAL_2700:.*]] = add nuw nsw i32 %[[VAL_2688]], 3
// CHECK:         %[[VAL_2701:.*]] = udiv i32 %[[VAL_2700]], 1
// CHECK:         %[[VAL_2702:.*]] = urem i32 %[[VAL_2701]], 200
// CHECK:         %[[VAL_2703:.*]] = udiv i32 %[[VAL_2700]], 200
// CHECK:         %[[VAL_2704:.*]] = icmp ult i32 %[[VAL_2688]], 20000
// CHECK:         br i1 %[[VAL_2704]], label %[[VAL_2705:.*]], label %[[VAL_2706:.*]]
// CHECK:       r44.in_bounds-after:                              ; preds = %[[VAL_2705]], %[[VAL_2707:.*]]
// CHECK:         ret void
// CHECK:       r44.in_bounds-true:                               ; preds = %[[VAL_2707]]
// CHECK:         %[[VAL_2708:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2676]] to i32*
// CHECK:         %[[VAL_2709:.*]] = getelementptr inbounds i32, i32* %[[VAL_2708]], i32 %[[VAL_2688]]
// CHECK:         %[[VAL_2710:.*]] = load i32, i32* %[[VAL_2709]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2711:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2679]] to i32*
// CHECK:         %[[VAL_2712:.*]] = getelementptr inbounds i32, i32* %[[VAL_2711]], i32 %[[VAL_2688]]
// CHECK:         %[[VAL_2713:.*]] = load i32, i32* %[[VAL_2712]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2714:.*]] = lshr i32 %[[VAL_2710]], %[[VAL_2713]]
// CHECK:         %[[VAL_2715:.*]] = icmp ult i32 %[[VAL_2713]], 32
// CHECK:         %[[VAL_2716:.*]] = select i1 %[[VAL_2715]], i32 %[[VAL_2714]], i32 0
// CHECK:         %[[VAL_2717:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2682]] to i32*
// CHECK:         %[[VAL_2718:.*]] = getelementptr inbounds i32, i32* %[[VAL_2717]], i32 %[[VAL_2688]]
// CHECK:         store i32 %[[VAL_2716]], i32* %[[VAL_2718]], align 4
// CHECK:         %[[VAL_2719:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2676]] to i32*
// CHECK:         %[[VAL_2720:.*]] = getelementptr inbounds i32, i32* %[[VAL_2719]], i32 %[[VAL_2692]]
// CHECK:         %[[VAL_2721:.*]] = load i32, i32* %[[VAL_2720]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2722:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2679]] to i32*
// CHECK:         %[[VAL_2723:.*]] = getelementptr inbounds i32, i32* %[[VAL_2722]], i32 %[[VAL_2692]]
// CHECK:         %[[VAL_2724:.*]] = load i32, i32* %[[VAL_2723]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2725:.*]] = lshr i32 %[[VAL_2721]], %[[VAL_2724]]
// CHECK:         %[[VAL_2726:.*]] = icmp ult i32 %[[VAL_2724]], 32
// CHECK:         %[[VAL_2727:.*]] = select i1 %[[VAL_2726]], i32 %[[VAL_2725]], i32 0
// CHECK:         %[[VAL_2728:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2682]] to i32*
// CHECK:         %[[VAL_2729:.*]] = getelementptr inbounds i32, i32* %[[VAL_2728]], i32 %[[VAL_2692]]
// CHECK:         store i32 %[[VAL_2727]], i32* %[[VAL_2729]], align 4
// CHECK:         %[[VAL_2730:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2676]] to i32*
// CHECK:         %[[VAL_2731:.*]] = getelementptr inbounds i32, i32* %[[VAL_2730]], i32 %[[VAL_2696]]
// CHECK:         %[[VAL_2732:.*]] = load i32, i32* %[[VAL_2731]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2733:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2679]] to i32*
// CHECK:         %[[VAL_2734:.*]] = getelementptr inbounds i32, i32* %[[VAL_2733]], i32 %[[VAL_2696]]
// CHECK:         %[[VAL_2735:.*]] = load i32, i32* %[[VAL_2734]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2736:.*]] = lshr i32 %[[VAL_2732]], %[[VAL_2735]]
// CHECK:         %[[VAL_2737:.*]] = icmp ult i32 %[[VAL_2735]], 32
// CHECK:         %[[VAL_2738:.*]] = select i1 %[[VAL_2737]], i32 %[[VAL_2736]], i32 0
// CHECK:         %[[VAL_2739:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2682]] to i32*
// CHECK:         %[[VAL_2740:.*]] = getelementptr inbounds i32, i32* %[[VAL_2739]], i32 %[[VAL_2696]]
// CHECK:         store i32 %[[VAL_2738]], i32* %[[VAL_2740]], align 4
// CHECK:         %[[VAL_2741:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2676]] to i32*
// CHECK:         %[[VAL_2742:.*]] = getelementptr inbounds i32, i32* %[[VAL_2741]], i32 %[[VAL_2700]]
// CHECK:         %[[VAL_2743:.*]] = load i32, i32* %[[VAL_2742]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2744:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2679]] to i32*
// CHECK:         %[[VAL_2745:.*]] = getelementptr inbounds i32, i32* %[[VAL_2744]], i32 %[[VAL_2700]]
// CHECK:         %[[VAL_2746:.*]] = load i32, i32* %[[VAL_2745]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2747:.*]] = lshr i32 %[[VAL_2743]], %[[VAL_2746]]
// CHECK:         %[[VAL_2748:.*]] = icmp ult i32 %[[VAL_2746]], 32
// CHECK:         %[[VAL_2749:.*]] = select i1 %[[VAL_2748]], i32 %[[VAL_2747]], i32 0
// CHECK:         %[[VAL_2750:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2682]] to i32*
// CHECK:         %[[VAL_2751:.*]] = getelementptr inbounds i32, i32* %[[VAL_2750]], i32 %[[VAL_2700]]
// CHECK:         store i32 %[[VAL_2749]], i32* %[[VAL_2751]], align 4
// CHECK:         br label %[[VAL_2706]]
// CHECK:       entry:
// CHECK:         %[[VAL_2752:.*]] = getelementptr inbounds i8, i8* %[[VAL_2753:.*]], i64 0
// CHECK:         %[[VAL_2754:.*]] = bitcast i8* %[[VAL_2752]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2755:.*]] = getelementptr inbounds i8, i8* %[[VAL_2756:.*]], i64 0
// CHECK:         %[[VAL_2757:.*]] = bitcast i8* %[[VAL_2755]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2758:.*]] = getelementptr inbounds i8, i8* %[[VAL_2759:.*]], i64 0
// CHECK:         %[[VAL_2760:.*]] = bitcast i8* %[[VAL_2758]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2761:.*]] = getelementptr inbounds i8, i8* %[[VAL_2762:.*]], i64 0
// CHECK:         %[[VAL_2763:.*]] = bitcast i8* %[[VAL_2761]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2764:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2765:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2766:.*]] = mul nuw nsw i32 %[[VAL_2764]], 256
// CHECK:         %[[VAL_2767:.*]] = add nuw nsw i32 %[[VAL_2766]], %[[VAL_2765]]
// CHECK:         %[[VAL_2768:.*]] = icmp ult i32 %[[VAL_2767]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2768]])
// CHECK:         %[[VAL_2769:.*]] = mul nuw nsw i32 %[[VAL_2767]], 4
// CHECK:         %[[VAL_2770:.*]] = udiv i32 %[[VAL_2769]], 1
// CHECK:         %[[VAL_2771:.*]] = urem i32 %[[VAL_2770]], 200
// CHECK:         %[[VAL_2772:.*]] = udiv i32 %[[VAL_2769]], 200
// CHECK:         %[[VAL_2773:.*]] = add nuw nsw i32 %[[VAL_2769]], 1
// CHECK:         %[[VAL_2774:.*]] = udiv i32 %[[VAL_2773]], 1
// CHECK:         %[[VAL_2775:.*]] = urem i32 %[[VAL_2774]], 200
// CHECK:         %[[VAL_2776:.*]] = udiv i32 %[[VAL_2773]], 200
// CHECK:         %[[VAL_2777:.*]] = add nuw nsw i32 %[[VAL_2769]], 2
// CHECK:         %[[VAL_2778:.*]] = udiv i32 %[[VAL_2777]], 1
// CHECK:         %[[VAL_2779:.*]] = urem i32 %[[VAL_2778]], 200
// CHECK:         %[[VAL_2780:.*]] = udiv i32 %[[VAL_2777]], 200
// CHECK:         %[[VAL_2781:.*]] = add nuw nsw i32 %[[VAL_2769]], 3
// CHECK:         %[[VAL_2782:.*]] = udiv i32 %[[VAL_2781]], 1
// CHECK:         %[[VAL_2783:.*]] = urem i32 %[[VAL_2782]], 200
// CHECK:         %[[VAL_2784:.*]] = udiv i32 %[[VAL_2781]], 200
// CHECK:         %[[VAL_2785:.*]] = icmp ult i32 %[[VAL_2769]], 20000
// CHECK:         br i1 %[[VAL_2785]], label %[[VAL_2786:.*]], label %[[VAL_2787:.*]]
// CHECK:       r45.in_bounds-after:                              ; preds = %[[VAL_2786]], %[[VAL_2788:.*]]
// CHECK:         ret void
// CHECK:       r45.in_bounds-true:                               ; preds = %[[VAL_2788]]
// CHECK:         %[[VAL_2789:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2754]] to i8*
// CHECK:         %[[VAL_2790:.*]] = getelementptr inbounds i8, i8* %[[VAL_2789]], i32 %[[VAL_2769]]
// CHECK:         %[[VAL_2791:.*]] = load i8, i8* %[[VAL_2790]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2792:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2757]] to float*
// CHECK:         %[[VAL_2793:.*]] = getelementptr inbounds float, float* %[[VAL_2792]], i32 %[[VAL_2769]]
// CHECK:         %[[VAL_2794:.*]] = load float, float* %[[VAL_2793]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2795:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2760]] to float*
// CHECK:         %[[VAL_2796:.*]] = getelementptr inbounds float, float* %[[VAL_2795]], i32 %[[VAL_2769]]
// CHECK:         %[[VAL_2797:.*]] = load float, float* %[[VAL_2796]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2798:.*]] = trunc i8 %[[VAL_2791]] to i1
// CHECK:         %[[VAL_2799:.*]] = select i1 %[[VAL_2798]], float %[[VAL_2794]], float %[[VAL_2797]]
// CHECK:         %[[VAL_2800:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2763]] to float*
// CHECK:         %[[VAL_2801:.*]] = getelementptr inbounds float, float* %[[VAL_2800]], i32 %[[VAL_2769]]
// CHECK:         store float %[[VAL_2799]], float* %[[VAL_2801]], align 4
// CHECK:         %[[VAL_2802:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2754]] to i8*
// CHECK:         %[[VAL_2803:.*]] = getelementptr inbounds i8, i8* %[[VAL_2802]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2804:.*]] = load i8, i8* %[[VAL_2803]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2805:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2757]] to float*
// CHECK:         %[[VAL_2806:.*]] = getelementptr inbounds float, float* %[[VAL_2805]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2807:.*]] = load float, float* %[[VAL_2806]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2808:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2760]] to float*
// CHECK:         %[[VAL_2809:.*]] = getelementptr inbounds float, float* %[[VAL_2808]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2810:.*]] = load float, float* %[[VAL_2809]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2811:.*]] = trunc i8 %[[VAL_2804]] to i1
// CHECK:         %[[VAL_2812:.*]] = select i1 %[[VAL_2811]], float %[[VAL_2807]], float %[[VAL_2810]]
// CHECK:         %[[VAL_2813:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2763]] to float*
// CHECK:         %[[VAL_2814:.*]] = getelementptr inbounds float, float* %[[VAL_2813]], i32 %[[VAL_2773]]
// CHECK:         store float %[[VAL_2812]], float* %[[VAL_2814]], align 4
// CHECK:         %[[VAL_2815:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2754]] to i8*
// CHECK:         %[[VAL_2816:.*]] = getelementptr inbounds i8, i8* %[[VAL_2815]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2817:.*]] = load i8, i8* %[[VAL_2816]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2818:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2757]] to float*
// CHECK:         %[[VAL_2819:.*]] = getelementptr inbounds float, float* %[[VAL_2818]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2820:.*]] = load float, float* %[[VAL_2819]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2821:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2760]] to float*
// CHECK:         %[[VAL_2822:.*]] = getelementptr inbounds float, float* %[[VAL_2821]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2823:.*]] = load float, float* %[[VAL_2822]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2824:.*]] = trunc i8 %[[VAL_2817]] to i1
// CHECK:         %[[VAL_2825:.*]] = select i1 %[[VAL_2824]], float %[[VAL_2820]], float %[[VAL_2823]]
// CHECK:         %[[VAL_2826:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2763]] to float*
// CHECK:         %[[VAL_2827:.*]] = getelementptr inbounds float, float* %[[VAL_2826]], i32 %[[VAL_2777]]
// CHECK:         store float %[[VAL_2825]], float* %[[VAL_2827]], align 4
// CHECK:         %[[VAL_2828:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2754]] to i8*
// CHECK:         %[[VAL_2829:.*]] = getelementptr inbounds i8, i8* %[[VAL_2828]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2830:.*]] = load i8, i8* %[[VAL_2829]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2831:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2757]] to float*
// CHECK:         %[[VAL_2832:.*]] = getelementptr inbounds float, float* %[[VAL_2831]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2833:.*]] = load float, float* %[[VAL_2832]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2834:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2760]] to float*
// CHECK:         %[[VAL_2835:.*]] = getelementptr inbounds float, float* %[[VAL_2834]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2836:.*]] = load float, float* %[[VAL_2835]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2837:.*]] = trunc i8 %[[VAL_2830]] to i1
// CHECK:         %[[VAL_2838:.*]] = select i1 %[[VAL_2837]], float %[[VAL_2833]], float %[[VAL_2836]]
// CHECK:         %[[VAL_2839:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2763]] to float*
// CHECK:         %[[VAL_2840:.*]] = getelementptr inbounds float, float* %[[VAL_2839]], i32 %[[VAL_2781]]
// CHECK:         store float %[[VAL_2838]], float* %[[VAL_2840]], align 4
// CHECK:         br label %[[VAL_2787]]
// CHECK:       entry:
// CHECK:         %[[VAL_2841:.*]] = getelementptr inbounds i8, i8* %[[VAL_2842:.*]], i64 0
// CHECK:         %[[VAL_2843:.*]] = bitcast i8* %[[VAL_2841]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2844:.*]] = getelementptr inbounds i8, i8* %[[VAL_2845:.*]], i64 0
// CHECK:         %[[VAL_2846:.*]] = bitcast i8* %[[VAL_2844]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2847:.*]] = getelementptr inbounds i8, i8* %[[VAL_2848:.*]], i64 0
// CHECK:         %[[VAL_2849:.*]] = bitcast i8* %[[VAL_2847]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2850:.*]] = getelementptr inbounds i8, i8* %[[VAL_2851:.*]], i64 0
// CHECK:         %[[VAL_2852:.*]] = bitcast i8* %[[VAL_2850]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2853:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2854:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2855:.*]] = mul nuw nsw i32 %[[VAL_2853]], 256
// CHECK:         %[[VAL_2856:.*]] = add nuw nsw i32 %[[VAL_2855]], %[[VAL_2854]]
// CHECK:         %[[VAL_2857:.*]] = icmp ult i32 %[[VAL_2856]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2857]])
// CHECK:         %[[VAL_2858:.*]] = mul nuw nsw i32 %[[VAL_2856]], 4
// CHECK:         %[[VAL_2859:.*]] = udiv i32 %[[VAL_2858]], 1
// CHECK:         %[[VAL_2860:.*]] = urem i32 %[[VAL_2859]], 200
// CHECK:         %[[VAL_2861:.*]] = udiv i32 %[[VAL_2858]], 200
// CHECK:         %[[VAL_2862:.*]] = add nuw nsw i32 %[[VAL_2858]], 1
// CHECK:         %[[VAL_2863:.*]] = udiv i32 %[[VAL_2862]], 1
// CHECK:         %[[VAL_2864:.*]] = urem i32 %[[VAL_2863]], 200
// CHECK:         %[[VAL_2865:.*]] = udiv i32 %[[VAL_2862]], 200
// CHECK:         %[[VAL_2866:.*]] = add nuw nsw i32 %[[VAL_2858]], 2
// CHECK:         %[[VAL_2867:.*]] = udiv i32 %[[VAL_2866]], 1
// CHECK:         %[[VAL_2868:.*]] = urem i32 %[[VAL_2867]], 200
// CHECK:         %[[VAL_2869:.*]] = udiv i32 %[[VAL_2866]], 200
// CHECK:         %[[VAL_2870:.*]] = add nuw nsw i32 %[[VAL_2858]], 3
// CHECK:         %[[VAL_2871:.*]] = udiv i32 %[[VAL_2870]], 1
// CHECK:         %[[VAL_2872:.*]] = urem i32 %[[VAL_2871]], 200
// CHECK:         %[[VAL_2873:.*]] = udiv i32 %[[VAL_2870]], 200
// CHECK:         %[[VAL_2874:.*]] = icmp ult i32 %[[VAL_2858]], 20000
// CHECK:         br i1 %[[VAL_2874]], label %[[VAL_2875:.*]], label %[[VAL_2876:.*]]
// CHECK:       r46.in_bounds-after:                              ; preds = %[[VAL_2875]], %[[VAL_2877:.*]]
// CHECK:         ret void
// CHECK:       r46.in_bounds-true:                               ; preds = %[[VAL_2877]]
// CHECK:         %[[VAL_2878:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2843]] to float*
// CHECK:         %[[VAL_2879:.*]] = getelementptr inbounds float, float* %[[VAL_2878]], i32 %[[VAL_2858]]
// CHECK:         %[[VAL_2880:.*]] = load float, float* %[[VAL_2879]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2881:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2846]] to float*
// CHECK:         %[[VAL_2882:.*]] = getelementptr inbounds float, float* %[[VAL_2881]], i32 %[[VAL_2858]]
// CHECK:         %[[VAL_2883:.*]] = load float, float* %[[VAL_2882]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2884:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2849]] to float*
// CHECK:         %[[VAL_2885:.*]] = getelementptr inbounds float, float* %[[VAL_2884]], i32 %[[VAL_2858]]
// CHECK:         %[[VAL_2886:.*]] = load float, float* %[[VAL_2885]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2887:.*]] = fcmp uge float %[[VAL_2880]], %[[VAL_2883]]
// CHECK:         %[[VAL_2888:.*]] = select i1 %[[VAL_2887]], float %[[VAL_2880]], float %[[VAL_2883]]
// CHECK:         %[[VAL_2889:.*]] = fcmp ule float %[[VAL_2886]], %[[VAL_2888]]
// CHECK:         %[[VAL_2890:.*]] = select i1 %[[VAL_2889]], float %[[VAL_2886]], float %[[VAL_2888]]
// CHECK:         %[[VAL_2891:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2852]] to float*
// CHECK:         %[[VAL_2892:.*]] = getelementptr inbounds float, float* %[[VAL_2891]], i32 %[[VAL_2858]]
// CHECK:         store float %[[VAL_2890]], float* %[[VAL_2892]], align 4
// CHECK:         %[[VAL_2893:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2843]] to float*
// CHECK:         %[[VAL_2894:.*]] = getelementptr inbounds float, float* %[[VAL_2893]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2895:.*]] = load float, float* %[[VAL_2894]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2896:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2846]] to float*
// CHECK:         %[[VAL_2897:.*]] = getelementptr inbounds float, float* %[[VAL_2896]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2898:.*]] = load float, float* %[[VAL_2897]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2899:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2849]] to float*
// CHECK:         %[[VAL_2900:.*]] = getelementptr inbounds float, float* %[[VAL_2899]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2901:.*]] = load float, float* %[[VAL_2900]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2902:.*]] = fcmp uge float %[[VAL_2895]], %[[VAL_2898]]
// CHECK:         %[[VAL_2903:.*]] = select i1 %[[VAL_2902]], float %[[VAL_2895]], float %[[VAL_2898]]
// CHECK:         %[[VAL_2904:.*]] = fcmp ule float %[[VAL_2901]], %[[VAL_2903]]
// CHECK:         %[[VAL_2905:.*]] = select i1 %[[VAL_2904]], float %[[VAL_2901]], float %[[VAL_2903]]
// CHECK:         %[[VAL_2906:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2852]] to float*
// CHECK:         %[[VAL_2907:.*]] = getelementptr inbounds float, float* %[[VAL_2906]], i32 %[[VAL_2862]]
// CHECK:         store float %[[VAL_2905]], float* %[[VAL_2907]], align 4
// CHECK:         %[[VAL_2908:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2843]] to float*
// CHECK:         %[[VAL_2909:.*]] = getelementptr inbounds float, float* %[[VAL_2908]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2910:.*]] = load float, float* %[[VAL_2909]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2911:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2846]] to float*
// CHECK:         %[[VAL_2912:.*]] = getelementptr inbounds float, float* %[[VAL_2911]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2913:.*]] = load float, float* %[[VAL_2912]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2914:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2849]] to float*
// CHECK:         %[[VAL_2915:.*]] = getelementptr inbounds float, float* %[[VAL_2914]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2916:.*]] = load float, float* %[[VAL_2915]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2917:.*]] = fcmp uge float %[[VAL_2910]], %[[VAL_2913]]
// CHECK:         %[[VAL_2918:.*]] = select i1 %[[VAL_2917]], float %[[VAL_2910]], float %[[VAL_2913]]
// CHECK:         %[[VAL_2919:.*]] = fcmp ule float %[[VAL_2916]], %[[VAL_2918]]
// CHECK:         %[[VAL_2920:.*]] = select i1 %[[VAL_2919]], float %[[VAL_2916]], float %[[VAL_2918]]
// CHECK:         %[[VAL_2921:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2852]] to float*
// CHECK:         %[[VAL_2922:.*]] = getelementptr inbounds float, float* %[[VAL_2921]], i32 %[[VAL_2866]]
// CHECK:         store float %[[VAL_2920]], float* %[[VAL_2922]], align 4
// CHECK:         %[[VAL_2923:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2843]] to float*
// CHECK:         %[[VAL_2924:.*]] = getelementptr inbounds float, float* %[[VAL_2923]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2925:.*]] = load float, float* %[[VAL_2924]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2926:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2846]] to float*
// CHECK:         %[[VAL_2927:.*]] = getelementptr inbounds float, float* %[[VAL_2926]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2928:.*]] = load float, float* %[[VAL_2927]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2929:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2849]] to float*
// CHECK:         %[[VAL_2930:.*]] = getelementptr inbounds float, float* %[[VAL_2929]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2931:.*]] = load float, float* %[[VAL_2930]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2932:.*]] = fcmp uge float %[[VAL_2925]], %[[VAL_2928]]
// CHECK:         %[[VAL_2933:.*]] = select i1 %[[VAL_2932]], float %[[VAL_2925]], float %[[VAL_2928]]
// CHECK:         %[[VAL_2934:.*]] = fcmp ule float %[[VAL_2931]], %[[VAL_2933]]
// CHECK:         %[[VAL_2935:.*]] = select i1 %[[VAL_2934]], float %[[VAL_2931]], float %[[VAL_2933]]
// CHECK:         %[[VAL_2936:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2852]] to float*
// CHECK:         %[[VAL_2937:.*]] = getelementptr inbounds float, float* %[[VAL_2936]], i32 %[[VAL_2870]]
// CHECK:         store float %[[VAL_2935]], float* %[[VAL_2937]], align 4
// CHECK:         br label %[[VAL_2876]]
// CHECK:       entry:
// CHECK:         %[[VAL_2938:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2939:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2940:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2941:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2942:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2943:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2944:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2945:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2946:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2947:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2948:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2949:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2950:.*]] = getelementptr inbounds i8, i8* %[[VAL_2951:.*]], i64 0
// CHECK:         %[[VAL_2952:.*]] = bitcast i8* %[[VAL_2950]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2953:.*]] = getelementptr inbounds i8, i8* %[[VAL_2954:.*]], i64 0
// CHECK:         %[[VAL_2955:.*]] = bitcast i8* %[[VAL_2953]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2956:.*]] = getelementptr inbounds i8, i8* %[[VAL_2957:.*]], i64 0
// CHECK:         %[[VAL_2958:.*]] = bitcast i8* %[[VAL_2956]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2959:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2960:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2961:.*]] = mul nuw nsw i32 %[[VAL_2959]], 256
// CHECK:         %[[VAL_2962:.*]] = add nuw nsw i32 %[[VAL_2961]], %[[VAL_2960]]
// CHECK:         %[[VAL_2963:.*]] = icmp ult i32 %[[VAL_2962]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2963]])
// CHECK:         %[[VAL_2964:.*]] = mul nuw nsw i32 %[[VAL_2962]], 4
// CHECK:         %[[VAL_2965:.*]] = udiv i32 %[[VAL_2964]], 1
// CHECK:         %[[VAL_2966:.*]] = urem i32 %[[VAL_2965]], 200
// CHECK:         %[[VAL_2967:.*]] = udiv i32 %[[VAL_2964]], 200
// CHECK:         %[[VAL_2968:.*]] = add nuw nsw i32 %[[VAL_2964]], 1
// CHECK:         %[[VAL_2969:.*]] = udiv i32 %[[VAL_2968]], 1
// CHECK:         %[[VAL_2970:.*]] = urem i32 %[[VAL_2969]], 200
// CHECK:         %[[VAL_2971:.*]] = udiv i32 %[[VAL_2968]], 200
// CHECK:         %[[VAL_2972:.*]] = add nuw nsw i32 %[[VAL_2964]], 2
// CHECK:         %[[VAL_2973:.*]] = udiv i32 %[[VAL_2972]], 1
// CHECK:         %[[VAL_2974:.*]] = urem i32 %[[VAL_2973]], 200
// CHECK:         %[[VAL_2975:.*]] = udiv i32 %[[VAL_2972]], 200
// CHECK:         %[[VAL_2976:.*]] = add nuw nsw i32 %[[VAL_2964]], 3
// CHECK:         %[[VAL_2977:.*]] = udiv i32 %[[VAL_2976]], 1
// CHECK:         %[[VAL_2978:.*]] = urem i32 %[[VAL_2977]], 200
// CHECK:         %[[VAL_2979:.*]] = udiv i32 %[[VAL_2976]], 200
// CHECK:         %[[VAL_2980:.*]] = icmp ult i32 %[[VAL_2964]], 20000
// CHECK:         br i1 %[[VAL_2980]], label %[[VAL_2981:.*]], label %[[VAL_2982:.*]]
// CHECK:       r47.in_bounds-after:                              ; preds = %[[VAL_2981]], %[[VAL_2983:.*]]
// CHECK:         ret void
// CHECK:       r47.in_bounds-true:                               ; preds = %[[VAL_2983]]
// CHECK:         %[[VAL_2984:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2952]] to float*
// CHECK:         %[[VAL_2985:.*]] = getelementptr inbounds float, float* %[[VAL_2984]], i32 %[[VAL_2964]]
// CHECK:         %[[VAL_2986:.*]] = load float, float* %[[VAL_2985]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2987:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2955]] to float*
// CHECK:         %[[VAL_2988:.*]] = getelementptr inbounds float, float* %[[VAL_2987]], i32 %[[VAL_2964]]
// CHECK:         %[[VAL_2989:.*]] = load float, float* %[[VAL_2988]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_2986]], float* %[[VAL_2948]], align 4
// CHECK:         store float %[[VAL_2989]], float* %[[VAL_2947]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2948]], float* %[[VAL_2947]], float* %[[VAL_2949]])
// CHECK:         %[[VAL_2990:.*]] = load float, float* %[[VAL_2949]], align 4
// CHECK:         %[[VAL_2991:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2958]] to float*
// CHECK:         %[[VAL_2992:.*]] = getelementptr inbounds float, float* %[[VAL_2991]], i32 %[[VAL_2964]]
// CHECK:         store float %[[VAL_2990]], float* %[[VAL_2992]], align 4
// CHECK:         %[[VAL_2993:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2952]] to float*
// CHECK:         %[[VAL_2994:.*]] = getelementptr inbounds float, float* %[[VAL_2993]], i32 %[[VAL_2968]]
// CHECK:         %[[VAL_2995:.*]] = load float, float* %[[VAL_2994]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2996:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2955]] to float*
// CHECK:         %[[VAL_2997:.*]] = getelementptr inbounds float, float* %[[VAL_2996]], i32 %[[VAL_2968]]
// CHECK:         %[[VAL_2998:.*]] = load float, float* %[[VAL_2997]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_2995]], float* %[[VAL_2945]], align 4
// CHECK:         store float %[[VAL_2998]], float* %[[VAL_2944]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2945]], float* %[[VAL_2944]], float* %[[VAL_2946]])
// CHECK:         %[[VAL_2999:.*]] = load float, float* %[[VAL_2946]], align 4
// CHECK:         %[[VAL_3000:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2958]] to float*
// CHECK:         %[[VAL_3001:.*]] = getelementptr inbounds float, float* %[[VAL_3000]], i32 %[[VAL_2968]]
// CHECK:         store float %[[VAL_2999]], float* %[[VAL_3001]], align 4
// CHECK:         %[[VAL_3002:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2952]] to float*
// CHECK:         %[[VAL_3003:.*]] = getelementptr inbounds float, float* %[[VAL_3002]], i32 %[[VAL_2972]]
// CHECK:         %[[VAL_3004:.*]] = load float, float* %[[VAL_3003]], align 4, !invariant.load !94
// CHECK:         %[[VAL_3005:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2955]] to float*
// CHECK:         %[[VAL_3006:.*]] = getelementptr inbounds float, float* %[[VAL_3005]], i32 %[[VAL_2972]]
// CHECK:         %[[VAL_3007:.*]] = load float, float* %[[VAL_3006]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_3004]], float* %[[VAL_2942]], align 4
// CHECK:         store float %[[VAL_3007]], float* %[[VAL_2941]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2942]], float* %[[VAL_2941]], float* %[[VAL_2943]])
// CHECK:         %[[VAL_3008:.*]] = load float, float* %[[VAL_2943]], align 4
// CHECK:         %[[VAL_3009:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2958]] to float*
// CHECK:         %[[VAL_3010:.*]] = getelementptr inbounds float, float* %[[VAL_3009]], i32 %[[VAL_2972]]
// CHECK:         store float %[[VAL_3008]], float* %[[VAL_3010]], align 4
// CHECK:         %[[VAL_3011:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2952]] to float*
// CHECK:         %[[VAL_3012:.*]] = getelementptr inbounds float, float* %[[VAL_3011]], i32 %[[VAL_2976]]
// CHECK:         %[[VAL_3013:.*]] = load float, float* %[[VAL_3012]], align 4, !invariant.load !94
// CHECK:         %[[VAL_3014:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2955]] to float*
// CHECK:         %[[VAL_3015:.*]] = getelementptr inbounds float, float* %[[VAL_3014]], i32 %[[VAL_2976]]
// CHECK:         %[[VAL_3016:.*]] = load float, float* %[[VAL_3015]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_3013]], float* %[[VAL_2939]], align 4
// CHECK:         store float %[[VAL_3016]], float* %[[VAL_2938]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2939]], float* %[[VAL_2938]], float* %[[VAL_2940]])
// CHECK:         %[[VAL_3017:.*]] = load float, float* %[[VAL_2940]], align 4
// CHECK:         %[[VAL_3018:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2958]] to float*
// CHECK:         %[[VAL_3019:.*]] = getelementptr inbounds float, float* %[[VAL_3018]], i32 %[[VAL_2976]]
// CHECK:         store float %[[VAL_3017]], float* %[[VAL_3019]], align 4
// CHECK:         br label %[[VAL_2982]]
// CHECK:       entry:
// CHECK:         %[[VAL_3020:.*]] = alloca float, align 4
// CHECK:         %[[VAL_3021:.*]] = load float, float* %[[VAL_3022:.*]], align 4
// CHECK:         %[[VAL_3023:.*]] = load float, float* %[[VAL_3024:.*]], align 4
// CHECK:         %[[VAL_3025:.*]] = fadd float %[[VAL_3021]], %[[VAL_3023]]
// CHECK:         store float %[[VAL_3025]], float* %[[VAL_3020]], align 4
// CHECK:         %[[VAL_3026:.*]] = load float, float* %[[VAL_3020]], align 4
// CHECK:         store float %[[VAL_3026]], float* %[[VAL_3027:.*]], align 4
// CHECK:         ret void

HloModule Test

add_F32 {
  lhs = f32[] parameter(0)
  rhs = f32[] parameter(1)
  ROOT add = f32[] add(lhs, rhs)
}

ENTRY main {
  a = f32[100, 200]{1,0} parameter(0)
  b = f32[100, 200]{1,0} parameter(1)
  c = f32[100, 200]{1,0} parameter(2)
  i0 = s32[100, 200]{1,0} parameter(3)
  i1 = s32[100, 200]{1,0} parameter(4)
  cplx = c64[100, 200]{1,0} parameter(5)
  p0 = pred[100, 200]{1,0} parameter(6)
  p1 = pred[100, 200]{1,0} parameter(7)

  r0 = f32[100, 200]{1,0} abs(a)
  r1 = f32[100, 200]{1,0} round-nearest-afz(a)
  r2 = f32[100, 200]{1,0} ceil(a)
  r3 = s32[100, 200]{1,0} count-leading-zeros(i0)
  r4 = f32[100, 200]{1,0} convert(a)
  r5 = f32[100, 200]{1,0} bitcast-convert(a)
  r6 = f32[100, 200]{1,0} copy(a)
  r7 = f32[100, 200]{1,0} cosine(a)
  r8 = f32[100, 200]{1,0} exponential(a)
  r9 = f32[100, 200]{1,0} exponential-minus-one(a)
  r10 = f32[100, 200]{1,0} floor(a)
  r11 = f32[100, 200]{1,0} imag(cplx)
  r12 = pred[100, 200]{1,0} is-finite(a)
  r13 = f32[100, 200]{1,0} log(a)
  r14 = f32[100, 200]{1,0} log-plus-one(a)
  r15 = pred[100, 200]{1,0} not(p0)
  r16 = f32[100, 200]{1,0} negate(a)
  r17 = s32[100, 200]{1,0} popcnt(i0)
  r18 = f32[100, 200]{1,0} real(cplx)
  r19 = f32[100, 200]{1,0} reduce-precision(a), exponent_bits=5, mantissa_bits=12
  r20 = f32[100, 200]{1,0} rsqrt(a)
  // r21 = f32[100, 200]{1,0} logistic(a)
  r22 = f32[100, 200]{1,0} sign(a)
  r23 = f32[100, 200]{1,0} sine(a)
  r24 = f32[100, 200]{1,0} sqrt(a)
  r25 = f32[100, 200]{1,0} cbrt(a)
  r26 = f32[100, 200]{1,0} tanh(a)

  r27 = f32[100, 200]{1,0} add(a, b)
  r28 = f32[100, 200]{1,0} atan2(a, b)
  r29 = pred[100, 200]{1,0} compare(a, b), direction=EQ
  r30 = c64[100, 200]{1,0} complex(a, b)
  r31 = f32[100, 200]{1,0} divide(a, b)
  r32 = f32[100, 200]{1,0} maximum(a, b)
  r33 = f32[100, 200]{1,0} minimum(a, b)
  r34 = f32[100, 200]{1,0} multiply(a, b)
  r35 = f32[100, 200]{1,0} power(a, b)
  r36 = f32[100, 200]{1,0} remainder(a, b)
  r37 = f32[100, 200]{1,0} subtract(a, b)
  r38 = pred[100, 200]{1,0} and(p0, p1)
  r39 = pred[100, 200]{1,0} or(p0, p1)
  r40 = pred[100, 200]{1,0} xor(p0, p1)
  r41 = pred[100, 200]{1,0} add(p0, p1)
  r42 = s32[100, 200]{1,0} shift-left(i0, i1)
  r43 = s32[100, 200]{1,0} shift-right-arithmetic(i0, i1)
  r44 = s32[100, 200]{1,0} shift-right-logical(i0, i1)

  r45 = f32[100, 200]{1,0} select(p0, b, c)
  r46 = f32[100, 200]{1,0} clamp(a, b, c)

  ROOT r47 = f32[100, 200]{1,0} map(a, b), dimensions={0, 1}, to_apply=add_F32
}
